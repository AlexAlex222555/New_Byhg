
#Область ПрограммныйИнтерфейс

// Выполняет разузлование продукции и полуфабрикатов и для каждого элемента в структуре изделий
//  получает заданный набор данных ресурсной спецификации. В процессе обработки так же выполняется
//  укрупнение партий выпуска продукции и полуфабрикатов.
//
// Параметры:
//  Изделия	              - ТаблицаЗначений - таблица с номенклатурой, структуру производства которой необходимо получить.
//	ПараметрыРазузлования - Структура - см. РазузлованиеИзделий.ПараметрыРазузлования().
//  ПараметрыВыборки      - Структура - параметры выборки данных ресурсной спецификации
//		см. Справочники.РесурсныеСпецификации.ПараметрыВыборкиДанных().
// 
// Возвращаемое значение:
//  Структура - структура с элементами:
//  	* ДанныеСпецификаций - Массив, Неопределено - элементами массива являются структуры, содержащие данные ресурсных спецификаций.
//  	* ЕстьОшибка - Булево - Истина если при разузловании возникла ошибка (ДанныеСпецификаций в этом случае имеют значение Неопределено).
//  	* ОшибкаТекст - Строка - описание возникшей ошибки.
//  	* ОшибкаСсылка - СправочникСсылка, ДокументСсылка - ссылка на объект, с которым связана ошибка.
//
Функция Разузловать(Изделия, ПараметрыРазузлования, ПараметрыВыборки) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ДанныеСпецификаций", Неопределено);
	Результат.Вставить("ЕстьОшибка",         Ложь);
	Результат.Вставить("ОшибкаТекст",        "");
	Результат.Вставить("ОшибкаСсылка",       Неопределено);
	
	Потребности = ВыгрузитьВходящиеИзделияДляОбработки(Изделия);
	ПараметрыВыборки.ПереченьДанных = Справочники.РесурсныеСпецификации.ПереченьДанныхСпецификации();
	РазузловатьПотребностиРекурсивно(Потребности, Потребности, ПараметрыРазузлования, ПараметрыВыборки);
	
	ОписаниеОшибки = Новый Структура("ЕстьОшибка, ОшибкаТекст, ОшибкаСсылка", Ложь, "", Неопределено);
	ПроверитьКорректностьСпецификаций(Потребности.ВыгрузитьКолонку("Спецификация"), ОписаниеОшибки);
	
	Если НЕ ОписаниеОшибки.ЕстьОшибка Тогда
		
		
		Результат.ДанныеСпецификаций = РазделитьПотребностиНаПартии(Потребности, ПараметрыРазузлования);
		
	Иначе
		ЗаполнитьЗначенияСвойств(Результат, ОписаниеОшибки);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Функция - конструктор структуры, определяющей параметры разузлования изделий.
//
// Возвращаемое значение:
//  Структура - структура параметров.
Функция ПараметрыРазузлования() Экспорт
	
	Результат = Новый Структура;
	
	// Разделять результат разузлования на опт. партии либо возвращать его одной партией.
	Результат.Вставить("РазделятьНаОптимальныеПартии", Истина);
	
	// Параметр ГруппироватьДанные определяет необходимость объединения (укрупнения) 
	// данных, относящихся к одной спецификации. Помимо спецификации можно задать
	// произвольный набор полей в разрезе которых будет выполняться объединение - ПоляГруппировки.
	// В качестве значения следует указать имена колонок таблицы изделий без пробелов, разделенных запятыми.
	// Поля группировки так же будут перенесены в результат разузлования.
	Результат.Вставить("ГруппироватьДанные", Ложь);
	Результат.Вставить("ПоляГруппировки", "");
	
	// Параметр содержит имена колонок таблицы изделий которые необходимо "протянуть" сквозь всю
	// структуру изделий, наследуя их значений от родителя к его потомкам. Значения полей переносятся
	// в результат разузлования. При группировке доп. информация наследуется от одного из изделий,
	// выбираемого произвольным образом.
	Результат.Вставить("ДополнительнаяИнформация", "");
	
	// Если параметры РезервПФСоСклада и/или РезервПФИзЗаказов имеют значение Истина,
	// то по производимым в процессе ПФ вначале выполняется попытка сделать резерв на
	// складе/в графике, и дальнейшее разузлование выполняется на недостающую часть.
	// Если при резерве необходимо так же анализировать обособленные остатки, то таблица
	// изделий должна содержать колонку с соответствующим назначением, а имя колонки
	// следует передать через параметр РезервПФИмяПоляНазначение. Для резервирования
	// исключительно обособленных остатков служит параметр РезервПФТолькоОбособленно.
	Результат.Вставить("РезервПФСоСклада", Ложь);
	Результат.Вставить("РезервПФИзЗаказов", Ложь);
	Результат.Вставить("РезервПФИмяПоляНазначение", "");
	Результат.Вставить("РезервПФТолькоОбособленно", Ложь);
	
	
	Возврат Результат;
	
КонецФункции

// Функция - определяет поля группировки для разузлования изделий
//
// Параметры:
//  Поля - Строка - список полей, необходимый потребителю интерфейса разузлования
//
// Возвращаемое значение:
//  Строка - список полей, дополненный обязательными полями
Функция ПоляГруппировки(Поля = "") Экспорт
	
	Результат = Новый Массив;
	
	Если НЕ ПустаяСтрока(Поля) Тогда
		Результат.Добавить(Поля);
	КонецЕсли;
	
	Для каждого ИмяПараметра Из СтрРазделить("НаправлениеДеятельности,ПодразделениеДиспетчер", ",") Цикл
		Если УправлениеДаннымиОбИзделияхПовтИсп.ПараметрНазначенияИспользуется(
				Перечисления.ВидыПараметровНазначенияСпецификаций[ИмяПараметра]) Тогда
			Результат.Добавить(ИмяПараметра);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрСоединить(Результат, ",");
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Возвращаемое значение:
// 	ТаблицаЗначений:
// * Идентификатор - Число -
// * ДанныеСпецификации - Структура -
// * Входы - см. НовыйСвязиПотребностей
// * Выходы - см. НовыйСвязиПотребностей
// * СвернутыеВходящиеПотребности - Массив -
// * Обеспечение - см. НовыйОбеспечениеПотребности
// * Аналоги - см. НовыйАналогиПотребности
// * ПланироватьНеРанее - СправочникСсылка.ЭтапыПроизводства -
// * ЭтоРазборка - Булево -
// * ЭтоРемонт - Булево -
// * ЭтоВходящаяПотребность - Булево -
// * ЭтоТолкающаяСхема - Булево -
// * Начало - Дата -
// * Окончание - Дата -
// * ДатаОбеспеченияПФ - Дата -
// * МаксимальныйСрокПролеживания - Число -
// * СрокПролеживания - Дата -
// * ПартияВыпуска - Структура -
// * НекратныйВыпуск - Булево -
// * КоличествоНаПартию - Число -
// * ДнейОтПотребности - Число -
// * ПодразделениеДиспетчер - СправочникСсылка.СтруктураПредприятия -
// * НаправлениеДеятельности - СправочникСсылка.НаправленияДеятельности -
// * СписатьНаРасходы - Булево -
// * СтатьяРасходов - ПланВидовХарактеристикСсылка.СтатьиРасходов, ПланВидовХарактеристикСсылка.СтатьиАктивовПассивов -
// * АналитикаРасходов 
// * АналитикаАктивовПассивов 
// * ПодразделениеПолучатель - СправочникСсылка.Склады, СправочникСсылка.СтруктураПредприятия -
// * НачалоПроизводства - Дата -
// * Родитель - СтрокаТаблицыЗначений -
// * Свернута - Булево -
// * Обработана - Булево -
// * Отправитель - СправочникСсылка.Склады - 
// * Получатель - СправочникСсылка.Склады -
//
Функция ВыгрузитьВходящиеИзделияДляОбработки(Изделия)
	
	Потребности = Изделия.Скопировать();
	
	Потребности.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Потребности.Колонки.Добавить("ДанныеСпецификации", Новый ОписаниеТипов("Структура"));
	
	Потребности.Колонки.Добавить("Входы", Новый ОписаниеТипов("ТаблицаЗначений"));
	Потребности.Колонки.Добавить("Выходы", Новый ОписаниеТипов("ТаблицаЗначений"));
	Потребности.Колонки.Добавить("СвернутыеВходящиеПотребности", Новый ОписаниеТипов("Массив"));
	Потребности.Колонки.Добавить("Обеспечение", Новый ОписаниеТипов("ТаблицаЗначений"));
	
	Потребности.Колонки.Добавить("ПланироватьНеРанее", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	
	Потребности.Колонки.Добавить("ЭтоРазборка", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("ЭтоРемонт", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("ЭтоВходящаяПотребность", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("ЭтоТолкающаяСхема", Новый ОписаниеТипов("Булево"));
	
	Потребности.Колонки.Добавить("Начало", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	Потребности.Колонки.Добавить("Окончание", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	Потребности.Колонки.Добавить("ДатаОбеспеченияПФ", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	
	Потребности.Колонки.Добавить("МаксимальныйСрокПролеживания", Новый ОписаниеТипов("Число"));
	Потребности.Колонки.Добавить("СрокПролеживания", Новый ОписаниеТипов("Дата"));
	
	Потребности.Колонки.Добавить("ПартияВыпуска", Новый ОписаниеТипов("Структура"));
	Потребности.Колонки.Добавить("НекратныйВыпуск", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("КоличествоНаПартию", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Потребности.Колонки.Добавить("ДнейОтПотребности", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	Если Потребности.Колонки.Найти("ПодразделениеДиспетчер") = Неопределено Тогда
		Потребности.Колонки.Добавить("ПодразделениеДиспетчер",
			Новый ОписаниеТипов("СправочникСсылка.СтруктураПредприятия"));
	КонецЕсли;
		
	Если Потребности.Колонки.Найти("НаправлениеДеятельности") = Неопределено Тогда
		Потребности.Колонки.Добавить("НаправлениеДеятельности",
			Новый ОписаниеТипов("СправочникСсылка.НаправленияДеятельности"));
	КонецЕсли;
		
	Если Потребности.Колонки.Найти("СписатьНаРасходы") = Неопределено Тогда
		
		ТипыСтатей = Новый Массив;
		ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиРасходов"));
		ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиАктивовПассивов"));
		
		Потребности.Колонки.Добавить("СписатьНаРасходы"         , Новый ОписаниеТипов("Булево"));
		Потребности.Колонки.Добавить("СтатьяРасходов"           , Новый ОписаниеТипов(ТипыСтатей));
		Потребности.Колонки.Добавить("АналитикаРасходов"        , Метаданные.ПланыВидовХарактеристик.СтатьиРасходов.Тип);
		Потребности.Колонки.Добавить("АналитикаАктивовПассивов" , Метаданные.ПланыВидовХарактеристик.СтатьиАктивовПассивов.Тип);
		
	КонецЕсли;
	
	ТипыПолучатель = Новый Массив;
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.СтруктураПредприятия"));
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.Склады"));
	Потребности.Колонки.Добавить("ПодразделениеПолучатель", Новый ОписаниеТипов(ТипыПолучатель));
	Потребности.Колонки.Добавить("НачалоПроизводства", Новый ОписаниеТипов("Дата"));
	
	// Служебные поля
	Потребности.Колонки.Добавить("Родитель", Новый ОписаниеТипов("Null, СтрокаТаблицыЗначений"));
	Потребности.Колонки.Добавить("Свернута", Новый ОписаниеТипов("Булево"));
	Потребности.Колонки.Добавить("Обработана", Новый ОписаниеТипов("Булево"));
	
	Идентификатор = 1;
	
	Для каждого Строка Из Потребности Цикл
		
		Строка.Идентификатор = Идентификатор;
		Строка.ЭтоВходящаяПотребность = Истина;
		Строка.Входы = НовыйСвязиПотребностей();
		Строка.Выходы = НовыйСвязиПотребностей();
		Строка.Обеспечение = НовыйОбеспечениеПотребности();
		Строка.НачалоПроизводства = Строка.ДатаЗапуска;
		
		Идентификатор = Идентификатор + 1;
		
	КонецЦикла;
	
	Возврат Потребности;
	
КонецФункции

// Параметры:
// 	Потребности - см. ВыгрузитьВходящиеИзделияДляОбработки
// 	СтрокиДляОбработки - см. ВыгрузитьВходящиеИзделияДляОбработки
// 	ПараметрыРазузлования - см. ПараметрыРазузлования
// 	ПараметрыВыборки - см. Справочники.РесурсныеСпецификации.ПараметрыВыборкиДанных
// 	Идентификатор - Число - идентификатор текущей строки
// 	РезервыПФ - см. НовыйРезервыПолуфабрикатов
//
Процедура РазузловатьПотребностиРекурсивно(Потребности, СтрокиДляОбработки, ПараметрыРазузлования, ПараметрыВыборки, Идентификатор = Неопределено, РезервыПФ = Неопределено)
	
	ДанныеСпецификаций = Справочники.РесурсныеСпецификации.ДанныеСпецификации(
		?(ТипЗнч(СтрокиДляОбработки) = Тип("Массив"), Потребности.Скопировать(СтрокиДляОбработки), СтрокиДляОбработки),
		ПараметрыВыборки);
	
	Если ПараметрыРазузлования.РезервПФСоСклада
		ИЛИ ПараметрыРазузлования.РезервПФИзЗаказов Тогда
		
		ЗаменятьПФНаАналоги = Ложь;
		ОчередьПодбораПФ = НовыйОчередьПодбораПолуфабрикатов(ЗаменятьПФНаАналоги);
		
		Если РезервыПФ = Неопределено Тогда
			РезервыПФ = НовыйРезервыПолуфабрикатов();
		КонецЕсли;
		
	Иначе
		ОчередьПодбораПФ = Неопределено;
	КонецЕсли;
	
	Идентификатор = ?(Идентификатор = Неопределено, Потребности.Количество(), Идентификатор);
	ОчередьРазузлования = Новый Массив;
	
	Для Индекс = 0 По СтрокиДляОбработки.Количество()-1 Цикл
		
		Потребность = СтрокиДляОбработки[Индекс];
		ДанныеСпецификации = ДанныеСпецификаций[Потребность.Идентификатор]; // См. Справочники.РесурсныеСпецификации.ДанныеСпецификацииКонструктор
		
		ДанныеПоНоменклатуре = Справочники.РесурсныеСпецификации.ДанныеПоНоменклатуреРасширенный();
		ЗаполнитьЗначенияСвойств(ДанныеПоНоменклатуре, Потребность);
		ПартияВыпуска = Справочники.РесурсныеСпецификации.РассчитатьПартиюВыпускаПоНоменклатуре(
			ДанныеПоНоменклатуре, ДанныеСпецификации);
		
		РассчитатьКоличествоНаПартиюВыпуска(
			ПараметрыРазузлования, ПартияВыпуска, ДанныеСпецификации, ДанныеПоНоменклатуре);
		
		// Поля заполняются при расчете нормативного графика
		ДанныеСпецификации.Этапы.Колонки.Добавить("КодЭтапа",
			Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		ДанныеСпецификации.Этапы.Колонки.Добавить("ЖелаемаяДатаОбеспечения",
			Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
		
		Потребность.ДанныеСпецификации = ДанныеСпецификации;
		Потребность.ПартияВыпуска = ПартияВыпуска;
		Потребность.МаксимальныйСрокПролеживания = ДанныеСпецификации.МаксимальныйСрокПролеживанияВДнях * 86400;
		Потребность.НекратныйВыпуск = ПотребностьНеКратнаВыпускуРазборке(Потребность, ДанныеСпецификации);
		Потребность.ЭтоРазборка =
			ДанныеСпецификации.ТипПроизводственногоПроцесса = Перечисления.ТипыПроизводственныхПроцессов.Разборка;
		Потребность.ЭтоРемонт = 
			ДанныеСпецификации.ТипПроизводственногоПроцесса = Перечисления.ТипыПроизводственныхПроцессов.Ремонт;
		Потребность.ЭтоТолкающаяСхема = Потребность.ЭтоРазборка 
			ИЛИ (Потребность.ЭтоРемонт И Не Потребность.ЭтоВходящаяПотребность);
		
		#Область ДополнениеСвязей
		
		Для каждого Выход Из Потребность.Выходы Цикл
			НайденныеСтроки = ДанныеСпецификации.ВыходныеИзделия.НайтиСтроки(
				Новый Структура("Номенклатура, Характеристика",
					Выход.Связь.СтрокаРС.Номенклатура, Выход.Связь.СтрокаРС.Характеристика));
			Если НайденныеСтроки.Количество() = 1 Тогда
				Выход.СтрокаРС = НайденныеСтроки[0];
				Выход.СтрокаРСИмяВладельца = "ВыходныеИзделия";
				Выход.Связь.СвязьЭтап = НайденныеСтроки[0].Этап;
			Иначе
				Выход.Связь.Владелец().Удалить(Выход.Связь);
				Потребность.Выходы.Удалить(Выход);
			КонецЕсли;
		КонецЦикла;
		#КонецОбласти
		
		СтрокиДляРазузлования = СтрокиСпецификацииДляРазузлования(ДанныеСпецификации);
		
		Для каждого Данные Из СтрокиДляРазузлования Цикл
			
			// Контроль зацикливания спецификаций
			Родитель = Потребность;
			Пока Родитель <> Неопределено Цикл
				Если Родитель.Спецификация = Данные.Спецификация Тогда
					ВызватьИсключение СтрШаблон(
						НСтр("ru='В процессе разузлования изделий обнаружено зацикливание на спецификации ""%1"".';uk='В процесі розвузлування виробів виявлено зациклення на специфікації ""%1"".'"),
						Потребность.Спецификация);
				КонецЕсли;
				Родитель = Родитель.Родитель
			КонецЦикла;
			
			// Добавление потребности
			Строка = Данные.Строка;
			
			Если НЕ Данные.ЭтоРазборка Тогда
				ТребуетсяУточнитьМатериал = НЕ ЗначениеЗаполнено(Строка.Номенклатура)
					ИЛИ НЕ ЗначениеЗаполнено(Строка.Характеристика) И Строка.ХарактеристикиИспользуются
					ИЛИ НЕ ЗначениеЗаполнено(Строка.Количество);
				Если ТребуетсяУточнитьМатериал Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			Идентификатор = Идентификатор + 1;
			
			НоваяСтрока = Потребности.Добавить();
			
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Потребность,
				"ПодразделениеДиспетчер,
				|НаправлениеДеятельности,
				|НачалоПроизводства,
				|ДатаЗапуска,
				|ДатаВыпуска,
				|РазмещениеВыпуска"
					+ ?(ПустаяСтрока(ПараметрыРазузлования.ПоляГруппировки), "", "," + ПараметрыРазузлования.ПоляГруппировки)
					+ ?(ПустаяСтрока(ПараметрыРазузлования.ДополнительнаяИнформация), "", "," + ПараметрыРазузлования.ДополнительнаяИнформация)
					+ ?(ПустаяСтрока(ПараметрыРазузлования.РезервПФИмяПоляНазначение), "", "," + ПараметрыРазузлования.РезервПФИмяПоляНазначение));
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Данные, "Спецификация, КоличествоНаПартию");
			
			НоваяСтрока.Идентификатор = Идентификатор;
			НоваяСтрока.Входы = НовыйСвязиПотребностей();
			НоваяСтрока.Выходы = НовыйСвязиПотребностей();
			НоваяСтрока.Обеспечение = НовыйОбеспечениеПотребности();
			НоваяСтрока.Родитель = Потребность;
			
			#Область ПостроениеСвязей
			Если Данные.ЭтоРазборка Тогда
				
				Связь1 = Потребность.Выходы.Добавить();
				Связь1.СтрокаРС = Строка;
				Связь1.СтрокаРСИмяВладельца = Данные.СтрокаРСИмяВладельца;
				Связь1.СвязьИдентификатор = Идентификатор;
				
				Связь2 = НоваяСтрока.Входы.Добавить();
				Связь2.СвязьЭтап = Строка.Этап;
				Связь2.СвязьИдентификатор = Потребность.Идентификатор;
				Связь2.Родитель = Истина;
				Связь2.Связь = Связь1;
				
				Связь1.Связь = Связь2;
				
			Иначе
				
				// Сборка и Ремонт
				Связь1 = Потребность.Входы.Добавить();
				Связь1.СтрокаРС = Строка;
				Связь1.СтрокаРСИмяВладельца = Данные.СтрокаРСИмяВладельца;
				Связь1.СвязьИдентификатор = Идентификатор;
				
				Связь2 = НоваяСтрока.Выходы.Добавить();
				Связь2.СвязьЭтап = Строка.Этап;
				Связь2.СвязьИдентификатор = Потребность.Идентификатор;
				Связь2.Родитель = Истина;
				Связь2.Связь = Связь1;
				
				Связь1.Связь = Связь2;
				
				Если Данные.ЭтоРемонт Тогда
					
					// ремонтируемое изделие - передача
					СтруктураПоиска = Новый Структура("Номенклатура, Характеристика, Этап",
						Строка.Номенклатура, Строка.Характеристика, Строка.ИсточникПолученияПолуфабриката);
					НайденныеСтроки = ДанныеСпецификации.ВозвратныеОтходы.НайтиСтроки(СтруктураПоиска);
					Связь1 = Неопределено;
					
					Для каждого СтрокаВыпуск Из НайденныеСтроки Цикл
						Связь1 = Потребность.Выходы.Добавить();
						Связь1.СтрокаРС = СтрокаВыпуск;
						Связь1.СтрокаРСИмяВладельца = "ВозвратныеОтходы";
						Связь1.СвязьИдентификатор = Идентификатор;
					КонецЦикла;
					
					// ремонтируемое изделие - получение
					Связь2 = НоваяСтрока.Входы.Добавить();
					Связь2.СвязьЭтап = Строка.ИсточникПолученияПолуфабриката;
					Связь2.СвязьИдентификатор = Потребность.Идентификатор;
					Связь2.Родитель = Истина;
					
					Если НайденныеСтроки.Количество() = 1 Тогда
						Связь2.Связь = Связь1;
						Связь1.Связь = Связь2;
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли;
			#КонецОбласти
			
			ОчередьРазузлования.Добавить(НоваяСтрока);
			
			Если ОчередьПодбораПФ <> Неопределено
				И Не (Данные.ЭтоРазборка ИЛИ Данные.ЭтоРемонт ИЛИ Данные.ЭтоРабота) Тогда
				
				СтрокаПодбор = ОчередьПодбораПФ.Добавить();
				
				ЗаполнитьЗначенияСвойств(СтрокаПодбор, Строка);
				
				СтрокаПодбор.Идентификатор = ОчередьРазузлования.ВГраница();
				СтрокаПодбор.ДатаОтгрузки = Потребность.ДатаЗапуска;
				СтрокаПодбор.ВариантОбеспечения = ?(ПараметрыРазузлования.РезервПФТолькоОбособленно,
					Перечисления.ВариантыОбеспечения.Обособленно,
					Перечисления.ВариантыОбеспечения.Требуется);
				СтрокаПодбор.Назначение = ?(ПустаяСтрока(ПараметрыРазузлования.РезервПФИмяПоляНазначение),
					Неопределено,
					Потребность[ПараметрыРазузлования.РезервПФИмяПоляНазначение]);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Подбор остатков и аналогов ПФ
	Если ЗначениеЗаполнено(ОчередьПодбораПФ) Тогда
		
		ОчередьПодбораПФ.Индексы.Добавить("Идентификатор");
		
		Если ПараметрыРазузлования.РезервПФСоСклада
				ИЛИ ПараметрыРазузлования.РезервПФИзЗаказов Тогда
			ПодобратьОстаткиПолуфабрикатов(ОчередьРазузлования, ОчередьПодбораПФ, РезервыПФ, ПараметрыРазузлования);
		КонецЕсли;
		
		
		Для Индекс = -ОчередьРазузлования.ВГраница() По 0 Цикл
			Потребность = ОчередьРазузлования[-Индекс];
			Если Потребность.Количество = 0 Тогда
				Потребность.Выходы[0].Связь.Владелец().Удалить(Потребность.Выходы[0].Связь);
				Потребность.Владелец().Удалить(Потребность);
				ОчередьРазузлования.Удалить(-Индекс);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	// Рекурсивное разузлование
	Если ОчередьРазузлования.ВГраница() <> -1 Тогда
		РазузловатьПотребностиРекурсивно(
			Потребности, ОчередьРазузлования, ПараметрыРазузлования, ПараметрыВыборки, Идентификатор, РезервыПФ);
	КонецЕсли;
	
КонецПроцедуры

Функция СтрокиСпецификацииДляРазузлования(ДанныеСпецификации)
	
	Результат = Новый ТаблицаЗначений;
	
	Результат.Колонки.Добавить("Строка", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Результат.Колонки.Добавить("СтрокаРСИмяВладельца", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки));
	Результат.Колонки.Добавить("Спецификация", Новый ОписаниеТипов("СправочникСсылка.РесурсныеСпецификации"));
	Результат.Колонки.Добавить("ЭтоРазборка", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЭтоРемонт", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("ЭтоРабота", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("КоличествоНаПартию", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	// Материалы - сборка и ремонт
	СтруктураПоиска = Новый Структура("ПроизводитсяВПроцессе", Истина);
	
	Для каждого Строка Из ДанныеСпецификации.МатериалыИУслуги.НайтиСтроки(СтруктураПоиска) Цикл
		
		Если Строка.СпособПолученияМатериала = Перечисления.СпособыПолученияМатериаловВСпецификации.ПроизвестиПоСпецификации Тогда
			
			Если Строка.Спецификация.Пустая() Тогда
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Не удалось подобрать спецификацию для материала в строке %1 (спецификация ""%2"")';uk='Не вдалося підібрати специфікацію для матеріалу в рядку %1 (специфікація ""%2"")'"),
					Строка.НомерСтроки,
					ДанныеСпецификации.Спецификация);
			КонецЕсли;
			
			НоваяСтрока = Результат.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.СтрокаРСИмяВладельца = "МатериалыИУслуги";
			НоваяСтрока.Спецификация = Строка.Спецификация;
			НоваяСтрока.ЭтоРабота = Строка.ТипНоменклатуры = Перечисления.ТипыНоменклатуры.Работа;
			НоваяСтрока.КоличествоНаПартию = Строка.Количество;
			
		ИначеЕсли Строка.СпособПолученияМатериала = Перечисления.СпособыПолученияМатериаловВСпецификации.ПроизводитсяНаЭтапе
			И НЕ Строка.СпецификацияРемонта.Пустая() Тогда
			
			НоваяСтрока = Результат.Добавить();
			НоваяСтрока.Строка = Строка;
			НоваяСтрока.СтрокаРСИмяВладельца = "МатериалыИУслуги";
			НоваяСтрока.Спецификация = Строка.СпецификацияРемонта;
			НоваяСтрока.ЭтоРемонт = Истина;
			НоваяСтрока.КоличествоНаПартию = Строка.Количество;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Выходные изделия - разборка
	СтруктураПоиска = Новый Структура("ОбработатьПоСпецификации", Истина);
	
	Для каждого Строка Из ДанныеСпецификации.ВыходныеИзделия.НайтиСтроки(СтруктураПоиска) Цикл
			
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.СтрокаРСИмяВладельца = "ВыходныеИзделия";
		НоваяСтрока.Спецификация = Строка.Спецификация;
		НоваяСтрока.ЭтоРазборка = Истина;
		НоваяСтрока.КоличествоНаПартию = Строка.Количество;
		
	КонецЦикла;
	
	// Возвратные отходы - разборка
	Для каждого Строка Из ДанныеСпецификации.ВозвратныеОтходы.НайтиСтроки(СтруктураПоиска) Цикл
		
		НоваяСтрока = Результат.Добавить();
		НоваяСтрока.Строка = Строка;
		НоваяСтрока.СтрокаРСИмяВладельца = "ВозвратныеОтходы";
		НоваяСтрока.Спецификация = Строка.Спецификация;
		НоваяСтрока.ЭтоРазборка = Истина;
		НоваяСтрока.КоличествоНаПартию = Строка.Количество;
			
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ПодобратьОстаткиПолуфабрикатов(СтрокиПотребности, ТаблицаМатериалов, РезервыПФ, ПараметрыРазузлования)
	
	// Получение данных
	ТаблицаОформлено = Новый ТаблицаЗначений;
	ТаблицаОформлено.Колонки.Добавить("КодСтроки");
	ТаблицаОформлено.Колонки.Добавить("Ссылка");
	ТаблицаОформлено.Колонки.Добавить("Номенклатура");
	ТаблицаОформлено.Колонки.Добавить("Характеристика");
	ТаблицаОформлено.Колонки.Добавить("Склад");
	ТаблицаОформлено.Колонки.Добавить("Серия");
	ТаблицаОформлено.Колонки.Добавить("Количество");
	ТаблицаОформлено.Колонки.Добавить("КоличествоПриход");
	ТаблицаОформлено.Колонки.Добавить("КоличествоКорректировка");
	
	ПереченьВариантов = Новый Массив;
	Если ПараметрыРазузлования.РезервПФСоСклада Тогда
		ПереченьВариантов.Добавить(Перечисления.ВариантыОбеспечения.СоСклада);
	КонецЕсли;
	Если ПараметрыРазузлования.РезервПФИзЗаказов Тогда
		ПереченьВариантов.Добавить(Перечисления.ВариантыОбеспечения.ИзЗаказов);
	КонецЕсли;
	ПереченьВариантов.Добавить(Перечисления.ВариантыОбеспечения.Требуется);
	
	ПараметрыЗаполнения = Новый Структура;
	ПараметрыЗаполнения.Вставить("ПереченьВариантов", ПереченьВариантов);
	ПараметрыЗаполнения.Вставить("ИзменятьОбособление", Не ПараметрыРазузлования.РезервПФТолькоОбособленно);
	ПараметрыЗаполнения.Вставить("УчитыватьГрафикОтгрузки", Истина);
	
	Обеспечение = ОбеспечениеСервер.ТаблицаЗаполнениеОбеспеченияУниверсальный(
		ТаблицаМатериалов,
		ТаблицаОформлено,
		РезервыПФ,
		Неопределено,
		Неопределено,
		ОбеспечениеСервер.ТаблицаПотребностей(),
		ПараметрыЗаполнения);
		
	// Сортировка строк по приоритетам вариантов обеспечения: Обособленно - СоСклада - ИзЗаказов
	// В дальнейшем обеспечение распределяется на партии выпуска в заданном порядке
	ПереченьВариантов.Удалить(ПереченьВариантов.Найти(Перечисления.ВариантыОбеспечения.Требуется));
	ПереченьВариантов.Вставить(0, Перечисления.ВариантыОбеспечения.Обособленно);
	НачальныйИндекс = 0;
	Для Индекс = 0 По ПереченьВариантов.ВГраница() Цикл
		
		ВариантОбеспечения = ПереченьВариантов[Индекс];
		Если Обеспечение.Найти(ВариантОбеспечения, "ВариантОбеспечения") = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Смещение = 0;
		Для ИндексСтр = НачальныйИндекс По Обеспечение.Количество()-1 Цикл
			
			Если Обеспечение[ИндексСтр].ВариантОбеспечения = ВариантОбеспечения Тогда
				НачальныйИндекс = НачальныйИндекс + 1;
				Если Смещение <> 0 Тогда
					Обеспечение.Сдвинуть(Обеспечение[ИндексСтр], Смещение);
				КонецЕсли;
			Иначе
				Смещение = Смещение - 1;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Обработка данных
	СтруктураПоиска = Новый Структура("ВариантОбеспечения, СтрокаИндекс", Перечисления.ВариантыОбеспечения.Обособленно);
	Для Индекс = 0 По Обеспечение.Количество()-1 Цикл
		
		ДанныеОбеспечения = Обеспечение[Индекс];
		Если ДанныеОбеспечения.ВариантОбеспечения = Перечисления.ВариантыОбеспечения.Требуется Тогда
			Продолжить;
		КонецЕсли;
		
		// Уменьшение потребности
		Потребность = СтрокиПотребности[ДанныеОбеспечения.Идентификатор];
		Потребность.Количество = Потребность.Количество - ДанныеОбеспечения.Количество;
		
		СтрокаМатериал = ТаблицаМатериалов.Найти(ДанныеОбеспечения.Идентификатор, "Идентификатор");
		СтрокаМатериал.Количество = СтрокаМатериал.Количество - ДанныеОбеспечения.Количество;
		
		// Добавление резервов - они учитываются при следующих вызовах
		НоваяСтрока = РезервыПФ.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаМатериал);
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеОбеспечения);
		
		Если СтрокаМатериал.Количество = 0 Тогда
			ТаблицаМатериалов.Удалить(СтрокаМатериал);
		КонецЕсли;
		
		// Добавление сведений об обеспечении в родительскую потребность
		СтрокаОбеспечение = Потребность.Выходы[0].Связь.СтрокаРС; // СтрокаТаблицыЗначений
		СтрокаОбеспечениеИндекс = СтрокаОбеспечение.Владелец().Индекс(СтрокаОбеспечение);
		Если ДанныеОбеспечения.ВариантОбеспечения = Перечисления.ВариантыОбеспечения.Обособленно Тогда
			// Строки с действием "Обеспечивать обособленно" сворачиваются
			СтруктураПоиска.СтрокаИндекс = СтрокаОбеспечениеИндекс;
			НайденныеСтроки = Потребность.Родитель.Обеспечение.НайтиСтроки(СтруктураПоиска);
			Если НайденныеСтроки.ВГраница() <> -1 Тогда
				НайденныеСтроки[0].Количество = НайденныеСтроки[0].Количество + ДанныеОбеспечения.Количество;
			Иначе
				НоваяСтрока = Потребность.Родитель.Обеспечение.Добавить();
				НоваяСтрока.СтрокаИндекс = СтрокаОбеспечениеИндекс;
				ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеОбеспечения, "Количество, ВариантОбеспечения");
			КонецЕсли;
		Иначе
			НоваяСтрока = Потребность.Родитель.Обеспечение.Добавить();
			НоваяСтрока.СтрокаИндекс = СтрокаОбеспечениеИндекс;
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеОбеспечения, "Количество, ДатаОтгрузки, ВариантОбеспечения");
		КонецЕсли;
		Потребность.Родитель.ДатаОбеспеченияПФ = Макс(Потребность.Родитель.ДатаОбеспеченияПФ, ДанныеОбеспечения.ДатаОтгрузки);
		
	КонецЦикла;
	
КонецПроцедуры


Функция ПотребностьНеКратнаВыпускуРазборке(Потребность, ДанныеСпецификации)
	
	Если Потребность.КоличествоНаПартию = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Результат = Ложь;
	
	Если Потребность.ЭтоРазборка Тогда
		
		СтруктураПоиска = Новый Структура("Номенклатура, Характеристика",
			Потребность.Номенклатура, Потребность.Характеристика);
		НайденныеСтроки = ДанныеСпецификации.МатериалыИУслуги.НайтиСтроки(СтруктураПоиска);
		
		Если НайденныеСтроки.Количество() = 1 Тогда
			
			КоличествоПартияВыпуска = ?(НайденныеСтроки[0].Количество <> 0, НайденныеСтроки[0].Количество, 1);
			
			Результат = (Потребность.КоличествоНаПартию % КоличествоПартияВыпуска) > 0;
			
		КонецЕсли;
		
	Иначе
		
		Если ДанныеСпецификации.ВыходныеИзделия.Количество() > 0 Тогда
			
			КоличествоПартияВыпуска = ДанныеСпецификации.ВыходныеИзделия[0].КоличествоИзделие;
			КоличествоПартияВыпуска = ?(КоличествоПартияВыпуска <> 0, КоличествоПартияВыпуска, 1);
			
			Результат = (Потребность.КоличествоНаПартию % КоличествоПартияВыпуска) > 0;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция РазделитьПотребностиНаПартии(Потребности, ПараметрыРазузлования)
	
	Результат = Новый Массив;
	
	Входы = Новый ТаблицаЗначений;
	Входы.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Входы.Колонки.Добавить("Этап", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	Входы.Колонки.Добавить("СтрокаРС", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Входы.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Входы.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Входы.Колонки.Добавить("КодЭтапа", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Входы.Колонки.Добавить("ДанныеСпецификации", Новый ОписаниеТипов("Структура"));
	
	Выходы = Новый ТаблицаЗначений;
	Выходы.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	Выходы.Колонки.Добавить("Этап", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	Выходы.Колонки.Добавить("СтрокаРС", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	Выходы.Колонки.Добавить("СтрокаРСИмяВладельца", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки));
	Выходы.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Выходы.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Выходы.Колонки.Добавить("ДанныеСпецификации", Новый ОписаниеТипов("Структура"));
	Выходы.Колонки.Добавить("Потребность", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	
	СтПоискаПФНаЭтапе = Новый Структура("СпособПолученияМатериала, СпецификацияРемонта",
		Перечисления.СпособыПолученияМатериаловВСпецификации.ПроизводитсяНаЭтапе,
		Справочники.РесурсныеСпецификации.ПустаяСсылка());
	СтПоискаНХЭтап = Новый Структура("Номенклатура, Характеристика, Этап");
	
	Потребности.Сортировать("Начало, Окончание");
	
	КодЭтапа = 10000000;
	Для ИндексПотребность = 0 По Потребности.Количество()-1 Цикл
		
		Потребность = Потребности[ИндексПотребность];
		Если Потребность.Свернута Тогда
			Продолжить;
		КонецЕсли;
		
		ВсегоПартий = 1;
		Если ПараметрыРазузлования.РазделятьНаОптимальныеПартии
				И Потребность.ПартияВыпуска.Расшифровка <> Неопределено Тогда
			ВсегоПартий = Потребность.ПартияВыпуска.Расшифровка.Количество();
		КонецЕсли;
		
		Для СчПартий = 1 По ВсегоПартий Цикл
			
			// Заполнение партии
			Если ВсегоПартий = 1 Тогда
				ДанныеСпецификации = Потребность.ДанныеСпецификации;
				ПартияВыпуска = Потребность.ПартияВыпуска;
			Иначе
				ДанныеСпецификации = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(Потребность.ДанныеСпецификации);
				
				ПартияВыпуска = Потребность.ПартияВыпуска.Расшифровка[СчПартий-1];
				ДанныеПоНоменклатуре = Справочники.РесурсныеСпецификации.ДанныеПоНоменклатуреРасширенный();
				ЗаполнитьЗначенияСвойств(ДанныеПоНоменклатуре, Потребность);
				Справочники.РесурсныеСпецификации.РассчитатьКоличествоНаПартиюВыпуска(ПартияВыпуска, ДанныеСпецификации, ДанныеПоНоменклатуре);
				
				Для каждого Этап Из ДанныеСпецификации.Этапы Цикл
					Этап.КодЭтапа = КодЭтапа;
					КодЭтапа = КодЭтапа + 1;
				КонецЦикла;
			КонецЕсли;
			
			ДобавитьПоляВДанныеСпецификации(ДанныеСпецификации, ПараметрыРазузлования);
			
			ЗаполнитьЗначенияСвойств(
				ДанныеСпецификации,
				Потребность,
				"ДатаЗапуска, ДатаВыпуска, Начало, Окончание, РазмещениеВыпуска, НекратныйВыпуск"
				+ ?(ПустаяСтрока(ПараметрыРазузлования.ПоляГруппировки), "", "," + ПараметрыРазузлования.ПоляГруппировки)
				+ ?(ПустаяСтрока(ПараметрыРазузлования.ДополнительнаяИнформация), "", "," + ПараметрыРазузлования.ДополнительнаяИнформация));
			
			ДанныеСпецификации.ПартияВыпуска = ПартияВыпуска;
			
			Если ДанныеСпецификации.ВыходныеИзделия.Количество() <> 0 Тогда
				ДанныеСпецификации.ВыходныеИзделия.ЗагрузитьКолонку(
					ДанныеСпецификации.ВыходныеИзделия.ВыгрузитьКолонку("Склад"), "Получатель");
			КонецЕсли;
			Если ДанныеСпецификации.ВозвратныеОтходы.Количество() <> 0 Тогда
				ДанныеСпецификации.ВозвратныеОтходы.ЗагрузитьКолонку(
					ДанныеСпецификации.ВозвратныеОтходы.ВыгрузитьКолонку("Склад"), "Получатель");
			КонецЕсли;
			
			// Заполнение реквизитов по входящим данным
			Для Индекс = 0 По Потребность.СвернутыеВходящиеПотребности.Количество() Цикл
				ВхПотребность = ?(Индекс = 0,
					?(Потребность.ЭтоВходящаяПотребность, Потребность, Неопределено),
					Потребность.СвернутыеВходящиеПотребности[Индекс - 1]);
				Если ВхПотребность = Неопределено ИЛИ ВхПотребность.Количество = 0 Тогда
					Продолжить;
				КонецЕсли;
				
					
					Для Сч = 1 По 2 Цикл
						Для каждого Строка Из ДанныеСпецификации[?(Сч = 1, "ВыходныеИзделия", "ВозвратныеОтходы")] Цикл
							Если Строка.Распределено = Строка.Количество
								ИЛИ Строка.Номенклатура <> ВхПотребность.Номенклатура
								ИЛИ Строка.Характеристика <> ВхПотребность.Характеристика
									И ЗначениеЗаполнено(Строка.Характеристика)
									И НЕ Строка.ЛюбаяХарактеристика Тогда
								Продолжить;
							КонецЕсли;
							
							Распределено = Мин(Строка.Количество-Строка.Распределено, ВхПотребность.Количество);
							
							Если (Строка.Распределено = 0
									И ВхПотребность.Количество >= Строка.Количество)
								ИЛИ (СтрокиИдентичны(Строка, ВхПотребность,
										"Характеристика,Получатель,Назначение,СписатьНаРасходы,СтатьяРасходов,АналитикаРасходов,АналитикаАктивовПассивов")
									И Строка.ЭтапПотребитель = ВхПотребность.ЭтапИсточник) Тогда
								
								// Разделять строку не нужно
								СтрокаЗаполнить = Строка;
								
							ИначеЕсли Строка.Округлить
								И НЕ Строка.ЭтоЦеховаяКладовая
								И Окр(Строка.Количество - Распределено) <> (Строка.Количество - Распределено) Тогда
								
								// При разделении строки будут нарушены правила округления
								Если Строка.Распределено = 0 Тогда
									Строка.Округлить = Ложь;
									СтрокаЗаполнить = Строка;
								Иначе
									ВладелецСтроки = Строка.Владелец(); // ТаблицаЗначений
									НоваяСтрока = ВладелецСтроки.Добавить();
									ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
									НоваяСтрока.Количество = Строка.Количество - Строка.Распределено;
									НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество
										* НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
									НоваяСтрока.Распределено = 0;
									НоваяСтрока.Округлить = Ложь;
									СтрокаЗаполнить = НоваяСтрока;
									
									Строка.Количество = Строка.Распределено;
									Строка.КоличествоУпаковок = Строка.Количество
										* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
									Если Сч = 1 Тогда
										ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
											НоваяСтрока, Строка, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
									КонецЕсли;
								КонецЕсли;
								
							Иначе
								
								// Разделение строки
								ВладелецСтроки = Строка.Владелец(); // ТаблицаЗначений
								НоваяСтрока = ВладелецСтроки.Добавить();
								ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
								НоваяСтрока.Количество = Распределено;
								НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество
									* НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
								НоваяСтрока.Распределено = 0;
								СтрокаЗаполнить = НоваяСтрока;
								
								Строка.Количество = Строка.Количество - Распределено;
								Строка.КоличествоУпаковок = Строка.Количество
									* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
								Если Сч = 1 Тогда
									ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
										НоваяСтрока, Строка, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
								КонецЕсли;
								
							КонецЕсли;
							
							ЗаполнитьЗначенияСвойств(СтрокаЗаполнить, ВхПотребность,
								"Характеристика,Получатель,Назначение,СписатьНаРасходы,СтатьяРасходов,АналитикаРасходов,АналитикаАктивовПассивов");
							СтрокаЗаполнить.ЭтапПотребитель = ВхПотребность.ЭтапИсточник;
							СтрокаЗаполнить.Распределено = СтрокаЗаполнить.Распределено + Распределено;
							
							ВхПотребность.Количество = ВхПотребность.Количество - Распределено;
							Если ВхПотребность.Количество = 0 Тогда
								Прервать;
							КонецЕсли;
							
						КонецЦикла;
						Если ВхПотребность.Количество = 0 Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
			КонецЦикла;
			
			// Зачет данных обеспечения
			Свертка = Новый Соответствие;
			МатериалыУдалить = Новый Массив;
			Для каждого Обеспечение Из Потребность.Обеспечение Цикл
				Строка = ДанныеСпецификации.МатериалыИУслуги[Обеспечение.СтрокаИндекс];
				Если Обеспечение.Количество = 0 ИЛИ Строка.Количество = 0 ИЛИ НЕ Строка.Производится Тогда
					Продолжить;
				КонецЕсли;
				
				КоличествоЗачет = Мин(Строка.Количество, Обеспечение.Количество);
				
					
					// Обеспечение из остатков на складе (в графике)
					ЖелаемаяДата = '00010101';
					СвернутьСтроку = Ложь;
					СвернутаяСтрока = Неопределено;
					Если Обеспечение.ВариантОбеспечения = Перечисления.ВариантыОбеспечения.ИзЗаказов Тогда
						ЖелаемаяДата = ДанныеСпецификации.Этапы.Найти(Строка.Этап, "Этап").ЖелаемаяДатаОбеспечения;
						СвернутьСтроку = Обеспечение.ДатаОтгрузки < НачалоДня(ЖелаемаяДата);
						СвернутаяСтрока = Свертка[Строка.КлючСвязи];
					КонецЕсли;
					
					СтрокаЗаполнить = Неопределено;
					Если Строка.Количество = КоличествоЗачет Тогда
						Если СвернутьСтроку И СвернутаяСтрока <> Неопределено Тогда
							Строка.Количество = Строка.Количество + СвернутаяСтрока.Количество;
							Строка.КоличествоУпаковок = Строка.Количество
								* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
							ДанныеСпецификации.МатериалыИУслуги.Удалить(СвернутаяСтрока);
							Свертка.Удалить(Строка.КлючСвязи);
						КонецЕсли;
						СтрокаЗаполнить = Строка;
					Иначе
						Если СвернутьСтроку И СвернутаяСтрока <> Неопределено Тогда
							СвернутаяСтрока.Количество = СвернутаяСтрока.Количество + КоличествоЗачет;
							СвернутаяСтрока.КоличествоУпаковок = СвернутаяСтрока.Количество
								* СвернутаяСтрока.ДанныеУпаковки.Знаменатель / СвернутаяСтрока.ДанныеУпаковки.Числитель;
						Иначе
							НоваяСтрока = ДанныеСпецификации.МатериалыИУслуги.Добавить();
							ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
							НоваяСтрока.Количество = КоличествоЗачет;
							НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество
								* НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
							СтрокаЗаполнить = НоваяСтрока;
							
							Если СвернутьСтроку Тогда
								Свертка.Вставить(Строка.КлючСвязи, НоваяСтрока);
							КонецЕсли;
						КонецЕсли;
						Строка.Количество = Строка.Количество - КоличествоЗачет;
						Строка.КоличествоУпаковок = Строка.Количество
							* Строка.ДанныеУпаковки.Знаменатель / Строка.ДанныеУпаковки.Числитель;
					КонецЕсли;
					
					Если СтрокаЗаполнить <> Неопределено Тогда
						СтрокаЗаполнить.Производится = Ложь;
						СтрокаЗаполнить.ПроизводитсяВПроцессе = Ложь;
						СтрокаЗаполнить.ИсточникПолученияПолуфабриката = Справочники.РесурсныеСпецификации.ПустаяСсылка();
						СтрокаЗаполнить.СпособПолученияПолуфабриката = Перечисления.СпособыПолученияМатериаловВСпецификации.ПустаяСсылка();
						СтрокаЗаполнить.Спецификация = Справочники.РесурсныеСпецификации.ПустаяСсылка();
						СтрокаЗаполнить.СтатьяКалькуляции = Справочники.СтатьиКалькуляции.ПустаяСсылка();
						СтрокаЗаполнить.ВариантОбеспечения = Обеспечение.ВариантОбеспечения;
						СтрокаЗаполнить.ДатаОтгрузки = ?(СвернутьСтроку, ЖелаемаяДата, Обеспечение.ДатаОтгрузки);
					КонецЕсли;
				
				Обеспечение.Количество = Обеспечение.Количество - КоличествоЗачет;
			КонецЦикла;
			
			// Добавление выходов
			Для каждого Связь Из Потребность.Выходы Цикл
				Связь.Связь = Неопределено; // Разрыв циклических ссылок
				
				Если ВсегоПартий = 1 Тогда
					СтрокаРС = Связь.СтрокаРС;
				Иначе
					ТаблицаРС = Связь.СтрокаРС.Владелец(); // ТаблицаЗначений
					СтрокаРС = ДанныеСпецификации[Связь.СтрокаРСИмяВладельца][ТаблицаРС.Индекс(Связь.СтрокаРС)];
				КонецЕсли;
				
				Выход = Выходы.Добавить();
				Выход.Идентификатор = Связь.СвязьИдентификатор;
				Выход.Этап = Связь.СвязьЭтап;
				Выход.СтрокаРС = СтрокаРС;
				Выход.СтрокаРСИмяВладельца = Связь.СтрокаРСИмяВладельца;
				Выход.Номенклатура = Связь.СтрокаРС.Номенклатура;
				Выход.Характеристика = Связь.СтрокаРС.Характеристика;
				Выход.ДанныеСпецификации = ДанныеСпецификации;
				Выход.Потребность = Потребность;
			КонецЦикла;
			
			// Добавление входов
			Для каждого Связь Из Потребность.Входы Цикл
				Связь.Связь = Неопределено; // Разрыв циклических ссылок
				
				Если ВсегоПартий = 1 Тогда
					СтрокаРС = Связь.СтрокаРС;
				Иначе
					ТаблицаРС = Связь.СтрокаРС.Владелец(); // ТаблицаЗначений
					СтрокаРС = ДанныеСпецификации[Связь.СтрокаРСИмяВладельца][ТаблицаРС.Индекс(Связь.СтрокаРС)];
				КонецЕсли;
				Если Связь.Родитель                  // Связи с родительскими потребностями добавляются через входящие изделия
					ИЛИ НЕ СтрокаРС.Производится Тогда // Потребность закрыта обеспечением
					Продолжить; 
				КонецЕсли;
				
				Вход = Входы.Добавить();
				Вход.Идентификатор = Потребность.Идентификатор;
				Вход.Этап = СтрокаРС.Этап;
				Вход.СтрокаРС = СтрокаРС;
				Вход.Номенклатура = Связь.СтрокаРС.Номенклатура;
				Вход.Характеристика = Связь.СтрокаРС.Характеристика;
				Вход.КодЭтапа = ДанныеСпецификации.Этапы.Найти(Вход.СтрокаРС.Этап, "Этап").КодЭтапа;
				Вход.ДанныеСпецификации = ДанныеСпецификации;
			КонецЦикла;
			
			// Добавление связей по ПФ, производимым на этапе
			Для каждого Строка Из ДанныеСпецификации.МатериалыИУслуги.НайтиСтроки(СтПоискаПФНаЭтапе) Цикл
				Вход = Входы.Добавить();
				Вход.Идентификатор = Потребность.Идентификатор;
				Вход.Этап = Строка.Этап;
				Вход.СтрокаРС = Строка;
				Вход.Номенклатура = Строка.Номенклатура;
				Вход.Характеристика = Строка.Характеристика;
				Вход.КодЭтапа = ДанныеСпецификации.Этапы.Найти(Строка.Этап, "Этап").КодЭтапа;
				Вход.ДанныеСпецификации = ДанныеСпецификации;
				
				СтПоискаНХЭтап.Номенклатура = Строка.Номенклатура;
				СтПоискаНХЭтап.Характеристика = Строка.Характеристика;
				СтПоискаНХЭтап.Этап = Строка.ИсточникПолученияПолуфабриката;
				
				Для каждого СтрокаВыход Из ДанныеСпецификации.ВозвратныеОтходы.НайтиСтроки(СтПоискаНХЭтап) Цикл
					Выход = Выходы.Добавить();
					Выход.Идентификатор = Потребность.Идентификатор;
					Выход.Этап = Строка.Этап;
					Выход.СтрокаРС = СтрокаВыход;
					Выход.СтрокаРСИмяВладельца = "ВозвратныеОтходы";
					Выход.Номенклатура = СтрокаВыход.Номенклатура;
					Выход.Характеристика = СтрокаВыход.Характеристика;
					Выход.ДанныеСпецификации = ДанныеСпецификации;
					Выход.Потребность = Потребность;
				КонецЦикла;
			КонецЦикла;
			
			Для каждого Строка Из МатериалыУдалить Цикл
				ДанныеСпецификации.МатериалыИУслуги.Удалить(Строка);
			КонецЦикла;
			
			Результат.Добавить(ДанныеСпецификации);
		КонецЦикла;
	КонецЦикла;
	
	// Построение связей
	Входы.Сортировать("Идентификатор, Этап, Номенклатура, Характеристика");
	Выходы.Сортировать("Идентификатор, Этап, Номенклатура, Характеристика");
	ИндВыход = 0;
	ИндВыходМакс = Выходы.Количество()-1;
	
	Для ИндВход = 0 По Входы.Количество()-1 Цикл
		Вход = Входы[ИндВход];
		Остаток = Вход.СтрокаРС.Количество;
		ИндВыход = ?(ИндВыход <= ИндВыходМакс, ИндВыход, 0);
		Пока ИндВыход <= ИндВыходМакс Цикл
			Выход = Выходы[ИндВыход];
			
			Если Выход.СтрокаРС.Распределено = Выход.СтрокаРС.Количество
				ИЛИ Выход.СтрокаРС.Количество = 0
				ИЛИ Выход.Идентификатор <> Вход.Идентификатор
				ИЛИ Выход.Этап <> Вход.Этап
				ИЛИ Выход.Номенклатура <> Вход.Номенклатура
				ИЛИ Выход.Характеристика <> Вход.Характеристика
					И ЗначениеЗаполнено(Выход.Характеристика)
					И НЕ Выход.СтрокаРС.ЛюбаяХарактеристика Тогда
				ИндВыход = ИндВыход + 1;
				Продолжить;
			КонецЕсли;
			
			Если Не Выход.Потребность.ПланироватьНеРанее.Пустая() Тогда // Привязка к этапу ПланироватьНеРанее
				Выход.ДанныеСпецификации.ПланироватьНеРанееКодЭтапа =
					Вход.ДанныеСпецификации.Этапы.Найти(Выход.Потребность.ПланироватьНеРанее, "Этап").КодЭтапа;
			КонецЕсли;
			
			Если Выход.СтрокаРС.Распределено <> 0 
				ИЛИ Выход.СтрокаРС.Количество > Остаток Тогда
				СтрокаВыход = Выход.СтрокаРС.Владелец().Вставить(0);
				ЗаполнитьЗначенияСвойств(СтрокаВыход, Выход.СтрокаРС);
				СтрокаВыход.Количество = Мин((Выход.СтрокаРС.Количество-Выход.СтрокаРС.Распределено), Остаток);
				СтрокаВыход.КоличествоУпаковок = СтрокаВыход.Количество * СтрокаВыход.ДанныеУпаковки.Знаменатель / СтрокаВыход.ДанныеУпаковки.Числитель;
				
				Выход.СтрокаРС.Количество = Выход.СтрокаРС.Количество - СтрокаВыход.Количество;
				Выход.СтрокаРС.КоличествоУпаковок = Выход.СтрокаРС.Количество * Выход.СтрокаРС.ДанныеУпаковки.Знаменатель / Выход.СтрокаРС.ДанныеУпаковки.Числитель;
				
				Если Выход.СтрокаРСИмяВладельца = "ВыходныеИзделия" Тогда
					ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
						СтрокаВыход, Выход.СтрокаРС, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
				КонецЕсли;
				
				// Контроль соблюдения правил округления
				Если Выход.СтрокаРС.Округлить
					И НЕ Выход.СтрокаРС.ЭтоЦеховаяКладовая
					И Окр(Выход.СтрокаРС.Количество) <> Выход.СтрокаРС.Количество Тогда
					
					Если Выход.СтрокаРС.Распределено = 0 Тогда
						Выход.СтрокаРС.Получатель = Вход.СтрокаРС.Склад;
						Выход.СтрокаРС.Округлить = Ложь;
					ИначеЕсли Выход.СтрокаРС.Количество > Выход.СтрокаРС.Распределено Тогда
						НоваяСтрока = Выход.СтрокаРС.Владелец().Вставить(0);
						ЗаполнитьЗначенияСвойств(НоваяСтрока, Выход.СтрокаРС);
						НоваяСтрока.Количество = Выход.СтрокаРС.Количество - Выход.СтрокаРС.Распределено;
						НоваяСтрока.КоличествоУпаковок = НоваяСтрока.Количество * НоваяСтрока.ДанныеУпаковки.Знаменатель / НоваяСтрока.ДанныеУпаковки.Числитель;
						НоваяСтрока.Распределено = 0;
						НоваяСтрока.Получатель = Вход.СтрокаРС.Склад;
						НоваяСтрока.Округлить = Ложь;
						
						Выход.СтрокаРС.Количество = Выход.СтрокаРС.Распределено;
						Выход.СтрокаРС.КоличествоУпаковок = Выход.СтрокаРС.Количество * Выход.СтрокаРС.ДанныеУпаковки.Знаменатель / Выход.СтрокаРС.ДанныеУпаковки.Числитель;
						
						Если Выход.СтрокаРСИмяВладельца = "ВыходныеИзделия" Тогда
							ПроизводствоКлиентСервер.ПересчитатьДолюСтоимостиПриРазбиенииСтроки(
								НоваяСтрока, Выход.СтрокаРС, ДанныеСпецификации.СпособРаспределенияЗатратНаВыходныеИзделия);
						КонецЕсли;
					КонецЕсли;	
				КонецЕсли;
			Иначе
				СтрокаВыход = Выход.СтрокаРС;
				ИндВыход = ИндВыход + 1;
			КонецЕсли;
			
			СтрокаВыход.Характеристика = Вход.СтрокаРС.Характеристика;
			СтрокаВыход.Получатель = ?(Вход.СтрокаРС.ТипНоменклатуры = Перечисления.ТипыНоменклатуры.Работа,
				Вход.СтрокаРС.Подразделение,
				Вход.СтрокаРС.Склад);
			СтрокаВыход.КодЭтапаПолучателя = Вход.КодЭтапа;
			СтрокаВыход.Распределено = СтрокаВыход.Количество;
			
			Остаток = Остаток - СтрокаВыход.Количество;
			Если Остаток = 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ДобавитьПоляВДанныеСпецификации(ДанныеСпецификации, ПараметрыРазузлования)
	
	ДанныеСпецификации.Вставить("ДатаЗапуска");
	ДанныеСпецификации.Вставить("ДатаВыпуска");
	ДанныеСпецификации.Вставить("Начало");
	ДанныеСпецификации.Вставить("Окончание");
	ДанныеСпецификации.Вставить("РазмещениеВыпуска");
	ДанныеСпецификации.Вставить("НекратныйВыпуск");
	ДанныеСпецификации.Вставить("ПартияВыпуска");
	ДанныеСпецификации.Вставить("ПланироватьНеРанееКодЭтапа");
	
	Если ПараметрыРазузлования.ГруппироватьДанные Тогда
		Для каждого Поле Из СтрРазделить(ПараметрыРазузлования.ПоляГруппировки, ",", Ложь) Цикл
			ДанныеСпецификации.Вставить(Поле);
		КонецЦикла;
		Для каждого Поле Из СтрРазделить(ПараметрыРазузлования.ДополнительнаяИнформация, ",", Ложь) Цикл
			ДанныеСпецификации.Вставить(Поле);
		КонецЦикла;
	КонецЕсли;
	
	ТипыПолучатель = Новый Массив;
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.СтруктураПредприятия"));
	ТипыПолучатель.Добавить(Тип("СправочникСсылка.Склады"));
	ОТПолучатель = Новый ОписаниеТипов(ТипыПолучатель);
		
	ОТЭтап = Новый ОписаниеТипов("Неопределено");
	
	ТипыСтатей = Новый Массив;
	ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиРасходов"));
	ТипыСтатей.Добавить(Тип("ПланВидовХарактеристикСсылка.СтатьиАктивовПассивов"));
	ОТСтатьяРасходов = Новый ОписаниеТипов(ТипыСтатей);
	
	// Выходные изделия и возвратные отходы
	Для Сч = 1 По 2 Цикл
		
		Таблица = ДанныеСпецификации[?(Сч = 1, "ВыходныеИзделия", "ВозвратныеОтходы")]; // ТаблицаЗначений
		Таблица.Колонки.Добавить("Назначение", Новый ОписаниеТипов("СправочникСсылка.Назначения"));
		Таблица.Колонки.Добавить("ЭтапПотребитель", ОТЭтап);
		Таблица.Колонки.Добавить("Получатель", ОТПолучатель);
		Таблица.Колонки.Добавить("Распределено", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		Таблица.Колонки.Добавить("КодЭтапаПолучателя", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
		Таблица.Колонки.Добавить("СписатьНаРасходы", Новый ОписаниеТипов("Булево"));
		Таблица.Колонки.Добавить("СтатьяРасходов", ОТСтатьяРасходов);
		Таблица.Колонки.Добавить("АналитикаРасходов", Метаданные.ПланыВидовХарактеристик.СтатьиРасходов.Тип);
		Таблица.Колонки.Добавить("АналитикаАктивовПассивов",
			Метаданные.ПланыВидовХарактеристик.СтатьиАктивовПассивов.Тип);
		
	КонецЦикла;
	
	
	// Материалы
	Таблица = ДанныеСпецификации.МатериалыИУслуги; // ТаблицаЗначений
	Таблица.Колонки.Добавить("ДатаОтгрузки", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	
КонецПроцедуры

Процедура ПроверитьКорректностьСпецификаций(Спецификации, ОписаниеОшибки)
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ЭтапыПроизводства.Владелец КАК Спецификация,
		|	ЭтапыПроизводства.Владелец.Представление КАК СпецификацияПредставление
		|ИЗ
		|	Справочник.ЭтапыПроизводства КАК ЭтапыПроизводства
		|ГДЕ
		|	ЭтапыПроизводства.Владелец В(&Спецификации)
		|	И ЭтапыПроизводства.ПометкаУдаления = ЛОЖЬ
		|	И ЭтапыПроизводства.НомерСледующегоЭтапа = 0
		|	И ЭтапыПроизводства.Владелец.ТипПроизводственногоПроцесса <> ЗНАЧЕНИЕ(Перечисление.ТипыПроизводственныхПроцессов.Разборка)
		|
		|СГРУППИРОВАТЬ ПО
		|	ЭтапыПроизводства.Владелец,
		|	ЭтапыПроизводства.Владелец.Представление
		|
		|ИМЕЮЩИЕ
		|	КОЛИЧЕСТВО(ЭтапыПроизводства.Ссылка) > 1");
	
	Запрос.УстановитьПараметр("Спецификации", Спецификации);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		
		ОписаниеОшибки.ЕстьОшибка = Истина;
		ОписаниеОшибки.ОшибкаСсылка = Выборка.Спецификация;
		ОписаниеОшибки.ОшибкаТекст = СтрШаблон(
				НСтр("ru='Спецификация ""%1"" содержит несколько выпускающих этапов';uk='Специфікація ""%1"" містить кілька випускних етапів'"),
				Выборка.СпецификацияПредставление);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура РассчитатьКоличествоНаПартиюВыпуска(ПараметрыРазузлования, ПартияВыпуска, ДанныеСпецификации, ДанныеПоНоменклатуре)
	
	Справочники.РесурсныеСпецификации.РассчитатьКоличествоНаПартиюВыпуска(
		ПартияВыпуска,
		ДанныеСпецификации,
		ДанныеПоНоменклатуре);
	
	// Пересчет ТЧ в которых количество номенклатуры округляется
	Если ПараметрыРазузлования.РазделятьНаОптимальныеПартии
		И ПартияВыпуска.Расшифровка <> Неопределено
		И ПартияВыпуска.Расшифровка.Количество() > 1 Тогда
		
		ДанныеСпецификацииКопия = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ДанныеСпецификации);
		
		Таблицы = СтрРазделить("ВыходныеИзделия,ВозвратныеОтходы,ВходящиеИзделия,МатериалыИУслуги", ",");
		Для каждого Таблица Из Таблицы Цикл
			ДанныеСпецификации[Таблица].ЗаполнитьЗначения(0, "Количество,КоличествоУпаковок");
		КонецЦикла;
		
		Для каждого ПартияВыпускаРасшифровка Из ПартияВыпуска.Расшифровка Цикл
			
			Справочники.РесурсныеСпецификации.РассчитатьКоличествоНаПартиюВыпуска(
				ПартияВыпускаРасшифровка,
				ДанныеСпецификацииКопия,
				ДанныеПоНоменклатуре);
			
			Для каждого Таблица Из Таблицы Цикл
				Для Индекс = 0 По ДанныеСпецификации[Таблица].Количество()-1 Цикл
					ДанныеСпецификации[Таблица][Индекс].Количество = ДанныеСпецификации[Таблица][Индекс].Количество
						+ ДанныеСпецификацииКопия[Таблица][Индекс].Количество;
					ДанныеСпецификации[Таблица][Индекс].КоличествоУпаковок = ДанныеСпецификации[Таблица][Индекс].КоличествоУпаковок
						+ ДанныеСпецификацииКопия[Таблица][Индекс].КоличествоУпаковок;
				КонецЦикла;
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

Функция СтрокиИдентичны(Строка1, Строка2, ИменаКолонок)
	
	Для каждого Колонка Из СтрРазделить(ИменаКолонок, ",") Цикл
		Если Строка1[Колонка] <> Строка2[Колонка] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#Область Конструкторы

// Возвращаемое значение:
// 	ТаблицаЗначений:
// * Строка - СтрокаТаблицыЗначений -
// * СтрокаРСИмяВладельца - Строка -
// * Связь - СтрокаТаблицыЗначений из см. НовыйСвязиПотребностей
// * СвязьИдентификатор - Число -
// * СвязьЭтап - СправочникСсылка.ЭтапыПроизводства -
// * Родитель - Булево -
Функция НовыйСвязиПотребностей()
	
	Результат = Новый ТаблицаЗначений;
	
	// Строка таблицы данных спецификации - источник/приемник связи
	Результат.Колонки.Добавить("СтрокаРС", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	
	// Имя табличной части, которой принадлежит строка
	Результат.Колонки.Добавить("СтрокаРСИмяВладельца", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки));
	
	// Строка таблицы связей, противоположная данной строке
	// Пример: если данная строка - это выход, то поле ссылается на строку-вход
	// Так же связи являются перекрестными - в примере выше строка-вход в содержит ссылку на данную строку
	Результат.Колонки.Добавить("Связь", Новый ОписаниеТипов("СтрокаТаблицыЗначений"));
	
	// Идентификатор связанной потребности
	Результат.Колонки.Добавить("СвязьИдентификатор", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	// Этап связанной потребности - приемник/источник связи
	Результат.Колонки.Добавить("СвязьЭтап", Новый ОписаниеТипов("СправочникСсылка.ЭтапыПроизводства"));
	
	// Если Истина то связь ссылается на родительскую потребность
	Результат.Колонки.Добавить("Родитель", Новый ОписаниеТипов("Булево"));
	
	Возврат Результат;
	
КонецФункции

Функция НовыйОбеспечениеПотребности()
	
	Результат = Новый ТаблицаЗначений;
	
	// Индекс строки тч МатериалыИУслуги к которой относятся данные обеспечения
	Результат.Колонки.Добавить("СтрокаИндекс", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	// Данные обеспечения
	Результат.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла));
	
	// При обеспечении из остатков на складе
	Результат.Колонки.Добавить("ДатаОтгрузки", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	Результат.Колонки.Добавить("ВариантОбеспечения", Новый ОписаниеТипов("ПеречислениеСсылка.ВариантыОбеспечения"));
	
	
	Возврат Результат;
	
КонецФункции

// Возвращаемое значение:
// 	ТаблицаЗначений - Описание:
// * Номенклатура - СправочникСсылка.Номенклатура -
// * Характеристика - СправочникСсылка.ХарактеристикиНоменклатуры -
// * Склад - СправочникСсылка.Склады -
// * Подразделение - СправочникСсылка.СтруктураПредприятия -
// * Назначение - СправочникСсылка.Назначения -
// * ТипНоменклатуры - ПеречислениеСсылка.ТипыНоменклатуры -
// * ВариантОбеспечения - ПеречислениеСсылка.ВариантыОбеспечения -
// * ДатаОтгрузки - Дата -
// * ДатаОтгрузкиРабот - Дата -
// * Количество - Число -
Функция НовыйРезервыПолуфабрикатов()
	
	Результат = Новый ТаблицаЗначений;
	
	Результат.Колонки.Добавить("Номенклатура", Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	Результат.Колонки.Добавить("Характеристика", Новый ОписаниеТипов("СправочникСсылка.ХарактеристикиНоменклатуры"));
	Результат.Колонки.Добавить("Склад", Новый ОписаниеТипов("СправочникСсылка.Склады"));
	Результат.Колонки.Добавить("Подразделение", Новый ОписаниеТипов("СправочникСсылка.СтруктураПредприятия"));
	Результат.Колонки.Добавить("Назначение", Новый ОписаниеТипов("СправочникСсылка.Назначения"));
	Результат.Колонки.Добавить("ТипНоменклатуры", Новый ОписаниеТипов("ПеречислениеСсылка.ТипыНоменклатуры"));
	Результат.Колонки.Добавить("ВариантОбеспечения", Новый ОписаниеТипов("ПеречислениеСсылка.ВариантыОбеспечения"));
	Результат.Колонки.Добавить("ДатаОтгрузки", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	Результат.Колонки.Добавить("ДатаОтгрузкиРабот", Новый ОписаниеТипов("Дата",,, Новый КвалификаторыДаты));
	Результат.Колонки.Добавить("Количество", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 3)));
	
	Возврат Результат;
	
КонецФункции

// Возвращаемое значение:
// 	ТаблицаЗначений:
// * Идентификатор - Число
Функция НовыйОчередьПодбораПолуфабрикатов(ЗаменятьПФНаАналоги)
	
	Результат = Новый ТаблицаЗначений;
	
	Для каждого Колонка Из СтрРазделить(ОбеспечениеСервер.ПутиКДаннымПоУмолчанию(), ",") Цикл
		Результат.Колонки.Добавить(СокрЛП(Колонка));
	КонецЦикла;
		
	
	Возврат Результат;
	
КонецФункции


#КонецОбласти


#КонецОбласти
