////////////////////////////////////////////////////////////////////////////////
// Модуль содержит общие процедуры и функции для форм регламентированной
// отчетности.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

#Если НЕ ВебКлиент Тогда
	
// Генерирует полное имя временного файла во временном каталоге.
// В случае если передан путь каталога, используется переданное значение.
// В случае если передано имя файла, используется переданное имя (вычленяется в общем случае короткое имя без пути).
// В случае передачи некорректных значений имен каталога и/или имени файла - заменяются на сгенерированные.
//
// Имеет смысл использовать в случае когда требуется временный файл во временном каталоге с определенным коротким именем.
// Например при формировании архива ZIP.
// В случаях когда короткое имя файла значения не имеет, нужно использовать ИмяФайла = ПолучитьИмяВременногоФайла().
// В этом случае формируемое имя будет короче на длину имени временного каталога, что иногда имеет значение
// в силу ограничений на максимальную длину полного пути файла.
//
// Параметры:
//		КаталогВремФайлов  - Строка или пустое значение любого типа или неопределено.
//							Возвращается имя каталога для результата.
// 		ИмяФайла		   - Строка или пустое значение любого типа или неопределено.
//							Возвращается короткое имя файла для результата.
//		УдалятьЕслиУжеЕсть - Булево. Необязательный. По умолчанию Истина. 
//							Признак необходимости удаления существующего в каталоге КаталогВремФайлов
//							файла с именем ИмяФайла. Если Ложь, генерируется новое ИмяФайла.
//
// Возвращаемое значение:
// 		Строка - полное имя, включая каталог, временного файла во временном каталоге.
//
Функция ПолучитьПолноеИмяВременногоФайла(КаталогВремФайлов, ИмяФайла, УдалятьЕслиУжеЕсть = Истина) Экспорт

	РазделительПути = ПолучитьРазделительПути();
	
	Если НЕ ЗначениеЗаполнено(КаталогВремФайлов) Тогда
	    КаталогВремФайлов = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	КаталогВремФайлов = СокрЛП(КаталогВремФайлов);
	
	Если Прав(КаталогВремФайлов, 1) = РазделительПути Тогда
		// Уберем разделитель в конце, если передали с ним.
	    КаталогВремФайлов = Лев(КаталогВремФайлов, СтрДлина(КаталогВремФайлов) - 1);
	КонецЕсли;
	
	Попытка
		КаталогВременныхФайлов = Новый Файл(КаталогВремФайлов);
		Если НЕ КаталогВременныхФайлов.Существует() Тогда
			СоздатьКаталог(КаталогВремФайлов);
		ИначеЕсли КаталогВременныхФайлов.ЭтоФайл() Тогда
			// Ситуация возможна только для заполненного переданного имени каталога.
			// Заменим в этом случае на новый временный каталог.
			КаталогВремФайлов = ПолучитьИмяВременногоФайла();
			СоздатьКаталог(КаталогВремФайлов);
		КонецЕсли;
	Исключение
		// Передано некорректное имя каталога.
		КаталогВремФайлов = ПолучитьИмяВременногоФайла();
		СоздатьКаталог(КаталогВремФайлов);
	КонецПопытки;
	
	Если НЕ ЗначениеЗаполнено(ИмяФайла) Тогда
		// Генерируем новое имя временного файла.
		ИмяФайла = ПолучитьИмяВременногоФайла("tmp");
	КонецЕсли;
	
	ИмяФайла = СокрЛП(ИмяФайла);
	
	// И вырезаем из полного имени каталог, оставляя только короткое имя.
	Если СтрНайти(ИмяФайла, РазделительПути) > 0 Тогда
		
		ПозицияКрайнегоРазделителя = СтрНайти(ИмяФайла, РазделительПути, НаправлениеПоиска.СКонца, , 1);
		Если ПозицияКрайнегоРазделителя < СтрДлина(ИмяФайла) Тогда
		    ИмяФайла = Сред(ИмяФайла, ПозицияКрайнегоРазделителя + 1);
		Иначе
			// Разделитель в конце - передано неверное имя.
		    ИмяФайла = ПолучитьИмяВременногоФайла("tmp");
			ПозицияКрайнегоРазделителя = СтрНайти(ИмяФайла, РазделительПути, НаправлениеПоиска.СКонца, , 1);
			ИмяФайла = Сред(ИмяФайла, ПозицияКрайнегоРазделителя + 1);
		КонецЕсли;
			    	
	КонецЕсли;

	ПолноеИмяВременногоФайла = КаталогВремФайлов + РазделительПути + ИмяФайла;
	
	НужноСменитьИмяФайла = Ложь;
	
	Попытка
	    ВременныйФайл = Новый Файл(ПолноеИмяВременногоФайла);
		Если ВременныйФайл.Существует() Тогда
			// Проверить иначе на корректность, кроме как 
			// спровоцировать исключение способа не вижу.
			
			Если УдалятьЕслиУжеЕсть Тогда              			
				УдалитьФайлы(ПолноеИмяВременногоФайла);
			Иначе
				// Такой файл уже есть - нужно сменить имя.
				НужноСменитьИмяФайла = Истина;
			КонецЕсли;
			
		КонецЕсли;
	Исключение
	    // Передано некорректное имя файла, поскольку корректность каталога уже проверялась.
		// Генерируем новое имя временного файла.
		НужноСменитьИмяФайла = Истина;
	КонецПопытки;
	
	Если НужноСменитьИмяФайла Тогда
	
		ИмяФайла = "";
		
		// Гарантируем что новое имя будет сгенерировано и так же будет полностью проверено.
		Возврат ПолучитьПолноеИмяВременногоФайла(КаталогВремФайлов, ИмяФайла, УдалятьЕслиУжеЕсть);
	Иначе
		Возврат ПолноеИмяВременногоФайла;
	КонецЕсли;
	
КонецФункции

#КонецЕсли

// Функция возвращает значение текущего показателя.
//
// Параметры:
//   Форма - ФормаКлиентскогоПриложения - управляемая форма регл. отчета.
//   ИмяРаздела - Строка - имя раздела регл. отчета.
//   ИмяОбласти - Строка - имя области.
//
// Возвращаемое значение:
//   Строка - значение текущего показателя.
//
Функция ВернутьЗначениеПараметраСЛиста(Форма, ИмяРаздела, ИмяОбласти) Экспорт

	ТекОбласть = Форма.ТабличныйДокумент;

	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		Результат = ТекОбласть.Области[ИмяОбласти].Значение;
	#Иначе
		Результат = ТекОбласть.Области[ИмяОбласти].Текст;
	#КонецЕсли

	Возврат Результат;

КонецФункции

// Возвращает свойства раздела.
//
Функция ПолучитьСвойствоРаздела(Форма, Знач ИмяСтраницы, Знач ИмяСвойства, ВозвращаемоеЗначение = Неопределено) Экспорт

	Результат = Неопределено;

	Если ТипЗнч(Форма.мСвойстваРазделовДекларации) <> Тип("ДанныеФормыДерево") Тогда
		Возврат Результат;
	КонецЕсли;
    	
	ИмяСтраницыП = ИмяСтраницы;
	
	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
		Если ИмяСтраницыП = СтрокаУровня1.ИмяСтраницы Тогда
			
			Если СвойствоОпределено(СтрокаУровня1, ИмяСвойства) Тогда
				
				Результат = СтрокаУровня1[ИмяСвойства];
				
			Иначе
				
				Результат = ВозвращаемоеЗначение;
				
			КонецЕсли;

			Прервать;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Возвращает признак определения свойства.
//
Функция СвойствоОпределено(Объект, ИмяСвойства) Экспорт
	
	ГУИД = Новый УникальныйИдентификатор;
	ВремСтрукт = Новый Структура(ИмяСвойства, ГУИД);
	ЗаполнитьЗначенияСвойств(ВремСтрукт, Объект);
	Возврат (ВремСтрукт[ИмяСвойства] <> ГУИД);
	
КонецФункции

// Сохраняет данные многостраничного раздела текущей страницы.
//
Процедура СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницы, ОчищатьРазделЕслиЕстьМногострочность) Экспорт
	Перем ТаблицаСтраницРаздела;

	ИмяТекТабличногоПоля = "ТабличныйДокумент";
	ТекТабличноеПоле     = Форма[ИмяТекТабличногоПоля];
    	
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницы, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];

	// Возьмем активную страницу
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.НайтиСтроки(Новый Структура("АктивнаяСтраница", Истина));

	// Если нет активной страницы - то выход
	Если СтрТаблицаСтраницы.Количество() = 0 Тогда
		
		Если ОчищатьРазделЕслиЕстьМногострочность Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(ИмяТекущейСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницы);
			#КонецЕсли
		КонецЕсли;
		
		Возврат;
		
	Иначе
		СтрТаблицаСтраницы = СтрТаблицаСтраницы[0];
	КонецЕсли;
    
	// Сохраним данные текущей страницы.
	// В каждой декларации функция СобратьДанныеТекущегоТаблПоля - разные !
	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		СтруктураДанныхТекущейТаблицы = Форма.СобратьДанныеТекущегоТаблПоляНаКлиенте(ИмяТекТабличногоПоля);
	#Иначе
		СтруктураДанныхТекущейТаблицы = Форма.СобратьДанныеТекущегоТаблПоляНаСервере(ИмяТекТабличногоПоля);
	#КонецЕсли
	
	КолМногострочныхЧастей = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "МногострочностьВРазделе").Количество();
		
	// Определяет, как работать с многострочностью в документе, либо как с ТаблЗначений или со структурой

	СохранятьМногострКакТЗ = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницы, "СохранятьМногострКакТЗ");

	// Если лист является многострочным и многостраничным, то необходимо добавить в поле данные доп. строк
	// в этой декларации не используется, т.к. многострочность одна на листе
	Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Определим ИмяГруппы дополнительных строк, по необходимой страницы
		// Если на листе больше одной многострочной части, то алгорит сбора будет другим

		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			СтруктураДанныхДопСтрокРаздела = Форма.СформироватьСтруктуруДанныхДопСтрокСтраницыКлиент(ИмяТекущейСтраницы);
		#Иначе
			СтруктураДанныхДопСтрокРаздела = Форма.СформироватьСтруктуруДанныхДопСтрокСтраницы(Форма, ИмяТекущейСтраницы);
		#КонецЕсли
			
		ТаблицаДопСтрокРаздела = СтруктураДанныхДопСтрокРаздела;

	ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

		ВРазделеДекларацииЕстьМногострочность = Истина;
		// Блок для разделов, где хранится только одна многострочная часть
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаКлиенте(ИмяТекущейСтраницы);
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппыДопСтрок);
		#Иначе
			ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаСервере(ИмяТекущейСтраницы);
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппыДопСтрок);
		#КонецЕсли

		// Получим таблицу значений, содержащую данные дополнительных строк.
		ПромТаблицаДопСтрокРаздела = Неопределено;
		Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
		ПромТаблицаДопСтрокРаздела = Форма[ПромТаблицаДопСтрокРаздела];
											
		ТаблицаДопСтрокРаздела = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
		КопироватьДанныеФормы(ПромТаблицаДопСтрокРаздела, ТаблицаДопСтрокРаздела);
		                        		
	ИначеЕсли КолМногострочныхЧастей = 0 Тогда

		ВРазделеДекларацииЕстьМногострочность = Ложь;

	КонецЕсли;

	// Сохраним данные
	СтрТаблицаСтраницы.Данные.Очистить();
	СтрТаблицаСтраницы.Данные.Добавить(СтруктураДанныхТекущейТаблицы);
		
	Если ВРазделеДекларацииЕстьМногострочность Тогда
        		
		Если ОчищатьРазделЕслиЕстьМногострочность Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(ИмяТекущейСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(ИмяТекущейСтраницы);
			#КонецЕсли
		КонецЕсли;
        		
		// Запишем данные доп. строк
						
		Если (СтрТаблицаСтраницы.ДанныеДопСтрок.Количество() > 0) 
		   И (СтрТаблицаСтраницы.ДанныеДопСтрок[0].Представление = "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела") Тогда
			
			СтрТаблицаСтраницы.ДанныеДопСтрок[0].Значение = ТаблицаДопСтрокРаздела;
			
		Иначе
			
		   СтрТаблицаСтраницы.ДанныеДопСтрок.Добавить(ТаблицаДопСтрокРаздела, "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела");
			
		КонецЕсли;
		
	КонецЕсли;

	// Попытаемся определить представление, только по текущей странице (по активной), последний параметр Истина
	ОпределитьПредставлениеДопСтраниц(Форма, ИмяТекущейСтраницы, Истина);

КонецПроцедуры

// Проверяет, является ли переданное значение числом.
//
Функция ЯвляетсяЧислом(Значение) Экспорт

	Если ТипЗнч(Значение) = Тип("Число") Тогда

		Возврат Истина

	Иначе

		Если ТипЗнч(Значение) = Тип("Строка") Тогда
			Если Значение = "" Тогда
				Возврат Ложь;
			КонецЕсли;
		КонецЕсли;

		Попытка
			Р = Число(Значение);
		Исключение
			Возврат Ложь;
		КонецПопытки;
			Возврат Истина;

	КонецЕсли;

КонецФункции

// Обновляет структуру многострочного раздела.
//
Процедура ОбновитьСтруктуруМногострочногоРаздела(Форма, ИмяГруппы) Экспорт
	Перем СтруктураГруппы;
    	
	Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
	
	СтруктураГруппы = Форма[СтруктураГруппы];
	
	ТекТабличноеПолеИмя = "ТабличныйДокумент";
	
	ТекТабличноеПоле = Форма[ТекТабличноеПолеИмя];
	
	КолонкиГруппы = Форма.СтруктураРеквизитовФормы.КолонкиМногострочныхРазделов[ИмяГруппы];
	
	Для НСтр = 1 По СтруктураГруппы.Количество() Цикл
		ТекСтрокаТаблицы = СтруктураГруппы[НСтр - 1];
		НСтрСтр = Формат(НСтр, "ЧГ=0");
		
		Для Каждого ИмяКолонки Из КолонкиГруппы Цикл
		
		
			Если СтруктураГруппы[0].Свойство(ИмяКолонки) Тогда
				
				ИмяЯчейки     = ИмяКолонки + "_" + НСтрСтр;
				ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяЯчейки];
				
				Если ОбластьЯчейки.СодержитЗначение = Истина Тогда
					ЗначениеЯчейки = ОбластьЯчейки.Значение;
				Иначе
					ЗначениеЯчейки = ОбластьЯчейки.Текст;
				КонецЕсли;
				
				ТекСтрокаТаблицы[ИмяКолонки] = ЗначениеЯчейки;
				
			КонецЕсли;
				
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Очищает табличное поле.
//
Процедура ОчиститьТабличноеПоле(Форма, Знач ВыбТабличноеПолеИмя) Экспорт

	// Проверяем многострочные блоки в разделе.
	НастройкиМнгЧ = ПолучитьСвойствоРаздела(Форма, ВыбТабличноеПолеИмя, "МногострочностьВРазделе");
	ЕстьМногострочныеБлоки = (ТипЗнч(НастройкиМнгЧ) = Тип("ДанныеФормыКоллекция")) И (НастройкиМнгЧ.Количество() > 0);
	Если ЕстьМногострочныеБлоки Тогда
		Для каждого Блок Из НастройкиМнгЧ Цикл
			МногострочныйБлок = Блок.ИдГруппы;
			УдалитьДопСтрокиМногострочнойЧастиРегОтчета(Форма, МногострочныйБлок, Ложь);
		КонецЦикла;
	КонецЕсли;
	
	ВыбТабличноеПоле = Форма.ТабличныйДокумент;

	// Непосредственно очищаем ячейки табличного документа.
	Для Инд = 0 По ВыбТабличноеПоле.Области.Количество() - 1 Цикл
		ТекущаяОбласть = ВыбТабличноеПоле.Области[Инд];

		Если НЕ ТипЗнч(ТекущаяОбласть) = Тип("РисунокТабличногоДокумента") И Не ТекущаяОбласть.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
			Продолжить;
		КонецЕсли;

		Если ТекущаяОбласть.СодержитЗначение <> Истина Тогда
			Продолжить;
		КонецЕсли;

		
		Если Найти(Врег(ТекущаяОбласть.Имя), ВРег("Штампик")) > 0  Тогда
			Продолжить;
		КонецЕсли;
		
		Если ТипЗнч(ТекущаяОбласть) = Тип("РисунокТабличногоДокумента") Тогда
			ТекущаяОбласть.Значение = "";
		Иначе
			ТекущаяОбласть.Очистить();
		КонецЕсли;
		
	КонецЦикла;
	
	ИмяСтраницыПанели = ВыбТабличноеПолеИмя;

	Если ЕстьМногострочныеБлоки Тогда
		Для каждого Блок Из НастройкиМнгЧ Цикл
			МногострочныйБлок = Блок.ИдГруппы;
			
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(МногострочныйБлок);
			#Иначе
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(МногострочныйБлок);
			#КонецЕсли
			
		КонецЦикла;
		
		// Расчет всегда запускаем только в многострочных листах. В не многострочных, запускается при вставки доп. страницы, или интерактивно в коде.
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.РасчетНаКлиенте(ИмяСтраницыПанели);
		#Иначе
			Форма.РасчетНаСервере(ИмяСтраницыПанели);
		#КонецЕсли
				
	КонецЕсли;

КонецПроцедуры

// Удаляет дополнительные строки многострочной части регламентированного отчета.
//
Процедура УдалитьДопСтрокиМногострочнойЧастиРегОтчета(Форма, ИдГруппы, ОбновлятьБлок = Истина) Экспорт
	Перем ТаблицаДопСтрок;
	Перем ИсходноеКоличествоСтрокГруппы;

	Форма.мСтруктураМногострочныхРазделов.Свойство(ИдГруппы, ТаблицаДопСтрок);
	
	ТаблицаДопСтрок = Форма[ТаблицаДопСтрок];
	
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИдГруппы, ИсходноеКоличествоСтрокГруппы);
	ТекущееКоличествоСтрок = ТаблицаДопСтрок.Количество();
	
	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаКлиенте(ИдГруппы);
	#Иначе
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаСервере(ИдГруппы);
	#КонецЕсли
	
	ТекТабличноеПоле = Форма.ТабличныйДокумент;
	
	Если ТекущееКоличествоСтрок > ИсходноеКоличествоСтрокГруппы Тогда

		НастройкиМнгЧ = ПолучитьСвойствоРаздела(Форма, ТекТабличноеПолеИмя, "МногострочностьВРазделе").НайтиСтроки(Новый Структура("ИдГруппы", ИдГруппы))[0];
		МнгЧастьОбластьИмя = НастройкиМнгЧ.Область;
		ВысотаСтроки = НастройкиМнгЧ.ВысотаСтроки;

		МнгЧастьОбласть = ТекТабличноеПоле.Области.Найти(МнгЧастьОбластьИмя);
		Низ = ТекТабличноеПоле.Области.Найти(МнгЧастьОбластьИмя).Низ + 1;
		
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Текст = МнгЧастьОбласть.Текст;
			РегламентированнаяОтчетностьВызовСервера.УдалитьОбластьИзТабличногоДокумента(ТекТабличноеПоле, Низ, Низ + ((ТекущееКоличествоСтрок - ИсходноеКоличествоСтрокГруппы) * ВысотаСтроки) - 1);
			Форма.ТабличныйДокумент = ТекТабличноеПоле;
		#Иначе
			РегламентированнаяОтчетностьВызовСервера.УдалитьОбластьИзТабличногоДокумента(ТекТабличноеПоле, Низ, Низ + ((ТекущееКоличествоСтрок - ИсходноеКоличествоСтрокГруппы) * ВысотаСтроки) - 1);
		#КонецЕсли
				
		ТаблицаДопСтрок.Очистить();
		Для Инд = 1 По ИсходноеКоличествоСтрокГруппы Цикл
			ТаблицаДопСтрок.Добавить();
		КонецЦикла;
		Если ОбновлятьБлок Тогда
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИдГруппы);
			#Иначе
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИдГруппы);
			#КонецЕсли
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Проставляет значения в квадратиках.
// 
Процедура ПроставитьВКвадратыЗначения(Форма, Знач Лист, Знач Показатель, Знач Размерность, Знач Значение, ДополнитьЗначение = Ложь, НольКакНоль = Ложь) Экспорт

	Раздел = Форма["ТабличныйДокумент"];

	ТекЛист = Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела;
	
	ДопРазряд = ""; // дополнительный разряд в счетчике
	ТестОк = Истина;

	Если ТекЛист = Лист Тогда
		Если Раздел.Области.Найти(Показатель + ДопРазряд + "1") = Неопределено Тогда
			ТестОк = Ложь;
		КонецЕсли;
	Иначе
		Если Форма["СтруктураДанных" + Лист].Свойство(Показатель + ДопРазряд + "1") = Ложь Тогда
			ТестОк = Ложь;
		КонецЕсли;	
	КонецЕсли;

	Если НЕ ТестОк Тогда
		Если ДопРазряд = "0" Тогда
			ДопРазряд = "";
		Иначе
			ДопРазряд = "0";
		КонецЕсли;
	КонецЕсли;

	Если ТекЛист = Лист Тогда
		
		Если Раздел.Области.Найти(Показатель + ДопРазряд + "1") = Неопределено Тогда
			Возврат;
		КонецЕсли;
    Иначе
		
		Если Форма["СтруктураДанных" + Лист].Свойство(Показатель + ДопРазряд + "1") = Ложь Тогда
			Возврат;
		КонецЕсли;	
		
	КонецЕсли;	

	СтрокаФорматаЯчейки = СтрЗаменить(Форма.СтруктураРеквизитовФормы.мСтрокаФормата, "; ЧН=-", "");
	// Убираем пробелы между группами разрядов числа
	СтрокаФорматаЯчейки = СтрокаФорматаЯчейки + "; ЧГ=0";

	Если (ДополнитьЗначение) Или ((ЯвляетсяЧислом(Значение)) И (Значение = 0)) Тогда

		Если ((ЯвляетсяЧислом(Значение)) И (Значение = 0)) Тогда

			Если НольКакНоль Тогда
				ЗначениеДопСтрока = ДополнитьСтроку("0", Размерность," ");
			Иначе
				ЗначениеДопСтрока = ДополнитьСтроку("", Размерность," ");
			КонецЕсли;

		Иначе

			ЗначениеДопСтрока = Формат(Значение, СтрокаФорматаЯчейки);
			ЗначениеДопСтрока = ДополнитьСтроку(ЗначениеДопСтрока, Размерность," ");

		КонецЕсли;

	Иначе

		ЗначениеДопСтрока = Значение;

	КонецЕсли; // ДополнитьЗначение

	ДопЗначение = 0;



	Если ТекЛист = Лист Тогда
	
		Для НомЯчейки = 1 По Размерность Цикл

			Раздел.Области[Показатель + ?(СтрДлина(НомЯчейки) = 1, ДопРазряд + НомЯчейки, НомЯчейки)].Значение = Сред(ЗначениеДопСтрока, НомЯчейки, 1);
			
		КонецЦикла;
		
	Иначе	
		
		Для НомЯчейки = 1 По Размерность Цикл

			Форма["СтруктураДанных" + Лист][Показатель + ?(СтрДлина(НомЯчейки) = 1, ДопРазряд + НомЯчейки, НомЯчейки)] = Сред(ЗначениеДопСтрока, НомЯчейки, 1);
			
		КонецЦикла;
		
	КонецЕсли;	
    	
КонецПроцедуры

// Дополняет строку.
//
Функция ДополнитьСтроку(Знач Стр, Длина, Чем=" ", Режим = 0) Экспорт
	
	СимволовДополнить = Длина -  СтрДлина(Стр);
	Добавок = "";
	Для Н=1 По СимволовДополнить Цикл
		Добавок =	Добавок + Чем;
	КонецЦикла;
	Возврат ?(Режим=0, Добавок + Стр, Стр + Добавок);
	
КонецФункции

// Обновляет структуру многостраничных разделов.
//
Процедура ОбновитьСтруктуруМногостраничныхРазделов(Форма, ИмяСтраницы = Неопределено) Экспорт
    	
	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекущейСтраницыПанели = Страница.Ключ;
		ТаблицаТекущейСтраницы   = Форма[Страница.Значение];

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяСтраницы <> ИмяТекущейСтраницыПанели Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		// Для декларации по прибыли, специальные два раздела сохраняются особым образом
		// пришлось внести изменения в общий модуль и процедуру для всех отчетов


		// Обновляя представления сохранения активного листа декларации
		// Параметр Ложь - не позволяет удалять многострочные части, если они есть на листе
		СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Ложь);
		
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает свойство групповых значений.
//
Процедура СвойстваГрупповыхЗначений(Форма, ИмяЯчейки, Операция, ЦветФона = Неопределено, ИмяСтраницы = Неопределено) Экспорт

	Если ИмяСтраницы = Неопределено Тогда
		
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяСтраницыПанели = РегламентированнаяОтчетностьКлиент.ОпределитьСтраницуПанелиПоКодуПоказателяНаКлиенте(Форма, ИмяЯчейки);
		#Иначе
			ИмяСтраницыПанели = РегламентированнаяОтчетностьВызовСервера.ОпределитьСтраницуПанелиПоКодуПоказателяНаСервере(Форма, ИмяЯчейки);
		#КонецЕсли
					
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат;
		КонецЕсли;
	Иначе
		ИмяСтраницыПанели = ИмяСтраницы;
	КонецЕсли;

	ИмяПоляТаблДокумента = "ТабличныйДокумент";

	СмысловаяЧасть = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки);
	Если СмысловаяЧасть = "" Тогда
	// не групповая ячейка
		Возврат;
	КонецЕсли;
	ТекущийСчетчик = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки, Ложь);
	ТекущийСчетчикЦел = Число(ТекущийСчетчик);
	МожноРаботать = Истина;
	Пока МожноРаботать Цикл
		Координата = СмысловаяЧасть + Строка(ТекущийСчетчикЦел);

		Если Форма[ИмяПоляТаблДокумента].Области.Найти(Координата) <> Неопределено Тогда
			Попытка
				Если Операция = "УстановитьЗащиту" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].Защита = Истина;
				КонецЕсли;

				Если Операция = "СнятьЗащиту" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].Защита = Ложь;
				КонецЕсли;

				Если Операция = "ПроставитьЦветРаскраски" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].ЦветФона = ЦветФона;
				КонецЕсли;

				Если Операция = "Очистить" Тогда
					Форма[ИмяПоляТаблДокумента].Области[Координата].Значение = "";
				КонецЕсли;

				ТекущийСчетчикЦел = ТекущийСчетчикЦел + 1; // работаем со следующей ячейкой

			Исключение
				МожноРаботать = Ложь; // далее нет ячеек многоквадратного значения
				Прервать;
			КонецПопытки;

		Иначе
			Прервать;
		КонецЕсли;
	КонецЦикла; // Пока

КонецПроцедуры

// Возвращает смысловую часть имени ячейки.
//
Функция ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки, Определение = Истина) Экспорт

	Для Инд = 1 По СтрДлина(ИмяЯчейки) Цикл
		// последний разделитель
		// не пользуемся тут функцией Найти, т.к. разделителей может быть много в одной ячейки, пример ИНН_1_1
		Если Инд > 4 Тогда
			// считаем, что эта ячейка не многоквадратная и выходим
			Возврат "";
		КонецЕсли;
		
		СимволСтроки = Сред(ИмяЯчейки,СтрДлина(ИмяЯчейки) - Инд + 1 ,1);

		Если СимволСтроки = "_" Тогда 
		// встретился знак "_" считаем его разделителем
			АдресПоследнегоРазделителя = СтрДлина(ИмяЯчейки) - Инд + 1;
			Прервать;
		КонецЕсли;

		Если НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(СимволСтроки) Тогда
			// встретилась буква разделить
			АдресПоследнегоРазделителя = СтрДлина(ИмяЯчейки) - Инд + 1;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	СмысловаяЧасть = Сред(ИмяЯчейки, 1, АдресПоследнегоРазделителя); // возвращаем ВМЕСТЕ с разделителем
	// Получаем текущий счетчик
	ТекущийСчетчик = Сред(ИмяЯчейки, АдресПоследнегоРазделителя + 1, СтрДлина(ИмяЯчейки) - АдресПоследнегоРазделителя);

	Если Определение Тогда
		Возврат СмысловаяЧасть;
	Иначе
		Возврат ТекущийСчетчик;
	КонецЕсли;

КонецФункции

Процедура ПоказатьСтраницуМногостраничногоРаздела(Форма, Шаг, ИмяТекущейСтраницыПанели, ПоказатьПоИндексу = Ложь) Экспорт
	Перем ТаблицаСтраницРаздела;
	Перем ТаблицаВариантыЗаполнения;
	Перем СтруктураДанныхДопСтрокРаздела;
    	
	ИмяТекТабличногоПоля = "ТабличныйДокумент";
		
	Если Не Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат;
	КонецЕсли;

	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
	
	СтрТаблицаСтраницы = ТаблицаСтраницРаздела.НайтиСтроки(Новый Структура("АктивнаяСтраница", Истина));

	Если СтрТаблицаСтраницы.Количество() = 0 Тогда
		Возврат;
	Иначе
		СтрТаблицаСтраницы = СтрТаблицаСтраницы[0];
	КонецЕсли;

	НомерТекущейСтраницы = ТаблицаСтраницРаздела.Индекс(СтрТаблицаСтраницы);
    	
	Если Не ПоказатьПоИндексу Тогда
		НомерСледующейСтраницы = НомерТекущейСтраницы + Шаг;
	Иначе
		НомерСледующейСтраницы = Шаг;
	КонецЕсли;

	Если ((НомерСледующейСтраницы + 1) > ТаблицаСтраницРаздела.Количество()) ИЛИ (НомерСледующейСтраницы < 0) Тогда
		Возврат;
	КонецЕсли;
	    	
	// Сохраним данные активной страницы, с присвоением Представления страницы и с очистной многострочных частей (Истина)
	СохранитьДанныеМногостраничногоРазделаВактивнойСтранице(Форма, ИмяТекущейСтраницыПанели, Истина);
	
	СтрТаблицаСтраницы.АктивнаяСтраница = Ложь;
	
	СтрСледующаяСтраница = ТаблицаСтраницРаздела[НомерСледующейСтраницы];

	СтрСледующаяСтраница.АктивнаяСтраница = Истина;

	#Если НаКлиенте Тогда
		ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, ИмяТекущейСтраницыПанели);
	#Иначе
		ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, ИмяТекущейСтраницыПанели);
	#КонецЕсли
	
	КолМногострочныхЧастей = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе").Количество();
	
	Если КолМногострочныхЧастей > 0 Тогда

		НовДанныеДопСтрокРаздела = СтрСледующаяСтраница.ДанныеДопСтрок;
		
		Если (ТипЗнч(НовДанныеДопСтрокРаздела) = Тип("СписокЗначений"))
			И (НовДанныеДопСтрокРаздела.Количество() > 0)
			И (НовДанныеДопСтрокРаздела[0].Представление = "ДанныеФормыКоллекцияТаблицаДопСтрокРаздела") Тогда
			
			НовДанныеДопСтрокРаздела = НовДанныеДопСтрокРаздела[0].Значение;
			
		КонецЕсли;
		
		// Способ хранения многострочных частей
		СохранятьМногострКакТЗ = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "СохранятьМногострКакТЗ");

	Иначе

		НовТаблицаДопСтрокРаздела = Неопределено; // Многострочности нет
		ИмяГруппыДопСтрок = Неопределено; // Имя группы строк неопределено

	КонецЕсли;

	Если НовДанныеДопСтрокРаздела <> Неопределено Тогда

		// В случае, если многострочных частей больше 1, то хранится структура, иначе, таблица значений с данными
		Если (КолМногострочныхЧастей > 0) И (НЕ СохранятьМногострКакТЗ) Тогда
			Для Каждого ГруппаСтрок Из НовДанныеДопСтрокРаздела Цикл
				ИмяГруппыДопСтрок = ГруппаСтрок.Ключ;
				ДанныеГруппыСтрок = ГруппаСтрок.Значение;
								
				ПромТаблицаГруппыСтрок = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
				КопироватьДанныеФормы(ДанныеГруппыСтрок, ПромТаблицаГруппыСтрок);

				// Заменяем таблицу значений с данными текущей страницы.
				//Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
				КопироватьДанныеФормы(ПромТаблицаГруппыСтрок, Форма[ИмяГруппыДопСтрок]);
				
				// Выводим в табличный документ данные группы дополнительных строк и обновляем структуру многострочного раздела.
				#Если НаКлиенте Тогда
					Форма.ВывестиРазделВТабличныйДокументНаКлиенте(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
					Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппыДопСтрок);
				#Иначе
					Форма.ВывестиРазделВТабличныйДокументНаСервере(ИмяГруппыДопСтрок, ПромТаблицаГруппыСтрок);
					Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппыДопСтрок);
				#КонецЕсли
				
			КонецЦикла;

		ИначеЕсли (КолМногострочныхЧастей > 0) И (СохранятьМногострКакТЗ) Тогда

			#Если НаКлиенте Тогда
				ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаКлиенте(ИмяТекущейСтраницыПанели);
			#Иначе
				ИмяГруппыДопСтрок = Форма.ОпределитьИдМногострочногоРазделаПоАктивнойСтраницеНаСервере(ИмяТекущейСтраницыПанели);
			#КонецЕсли
			
			ПромТаблицаДопСтрокРаздела = Форма["Хранилище" + ИмяГруппыДопСтрок].Добавить().Таблица;
						
			КопироватьДанныеФормы(НовДанныеДопСтрокРаздела, ПромТаблицаДопСтрокРаздела);
			
			// Заменяем таблицу значений с данными текущей страницы.
			//Форма.мСтруктураМногострочныхРазделов.Вставить(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
			КопироватьДанныеФормы(ПромТаблицаДопСтрокРаздела, Форма[ИмяГруппыДопСтрок]);
			
			// Выводим в табличный документ данные группы дополнительных строк и обновляем структуру многострочного раздела
			#Если НаКлиенте Тогда
				Форма.ВывестиРазделВТабличныйДокументНаКлиенте(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппыДопСтрок);
			#Иначе
				Форма.ВывестиРазделВТабличныйДокументНаСервере(ИмяГруппыДопСтрок, ПромТаблицаДопСтрокРаздела);
				Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппыДопСтрок);
			#КонецЕсли
			
		КонецЕсли;
		
	КонецЕсли;

	// отображаем данные следующей страницы
	СтруктураДанныхСледующаяСтраница = СтрСледующаяСтраница.Данные[0].Значение;

	ТекТабличноеПоле = Форма[ИмяТекТабличногоПоля];
	
	Для Каждого Элемент Из СтруктураДанныхСледующаяСтраница Цикл
		ИмяПоказателя      = Элемент.Ключ;
		ЗначениеПоказателя = Элемент.Значение;


			Попытка
				ТекТабличноеПоле.Области[ИмяПоказателя].Значение = ЗначениеПоказателя;
			Исключение
			КонецПопытки;

			Если Не ТаблицаВариантыЗаполнения = Неопределено Тогда
				
				// обновляем примечания к ячейкам табличного документа
				//НайденнаяСтрока = ТаблицаВариантыЗаполнения.НайтиСтроки(Новый Структура("КодПоказателя", ИмяПоказателя));
				
				НайденнаяСтрока = Неопределено;
				
				Для Каждого Элемент Из ТаблицаВариантыЗаполнения Цикл
					
					Если Элемент.КодПоказателя = ИмяПоказателя Тогда
						НайденнаяСтрока = Элемент;
						Прервать;
					КонецЕсли;
					
				КонецЦикла;
				
				Если НЕ НайденнаяСтрока = Неопределено Тогда
					ТекущийКомментарий = ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст;
					НовыйКомментарий   = НайденнаяСтрока.Комментарий;

					// примечание к ячейке устанавливаем тогда, когда изменился текст комментария
					Если Не (ПустаяСтрока(ТекущийКомментарий) И ПустаяСтрока(НовыйКомментарий)) Тогда
						ТекТабличноеПоле.Области[ИмяПоказателя].Примечание.Текст = НовыйКомментарий;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Выводит раздел в табличный документ.
//
Процедура ВывестиРазделВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы) Экспорт
	Перем ИсходноеКоличествоСтрокГруппы;

	// определим исходное колво строк многострочного раздела,
	// соответствующее бумажной форме отчета
	Форма.мСтруктураИсхКолвоСтрокРазделов.Свойство(ИмяГруппы, ИсходноеКоличествоСтрокГруппы);

	// реальное кол-во строк (колво заполненных строк)
	ТекущееКоличествоСтрокГруппы = СтруктураГруппы.Количество();
	
	#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаКлиенте(ИмяГруппы);
	#Иначе
		ТекТабличноеПолеИмя = Форма.ОпределитьТабличноеПолеПоИдМногострочногоРазделаНаСервере(ИмяГруппы);
	#КонецЕсли
	
	ТекТабличноеПоле = Форма["ТабличныйДокумент"];
				
	ПерерисоватьСтроки = (НЕ ТекущееКоличествоСтрокГруппы > ИсходноеКоличествоСтрокГруппы);

	Раздел = Форма["ТабличныйДокумент"];
		
	// При восстановлении сохраненных данных отчета сравниваем исходное кол-во
	// отображаемых в форме строк многострочного раздела с реальным количеством
	// созданных строк в сохраненном отчете.
	Если ТекущееКоличествоСтрокГруппы > ИсходноеКоличествоСтрокГруппы Тогда

		НастройкиМнгЧ = ПолучитьСвойствоРаздела(Форма, ТекТабличноеПолеИмя, "МногострочностьВРазделе");
				
		РегламентированнаяОтчетностьВызовСервера.ВывестиРазделВТабличныйДокументНаСервере(НастройкиМнгЧ, ИмяГруппы, Раздел, СтруктураГруппы, Форма.мСтруктураКолвоКолонокРазделов);
		
		Форма["ТабличныйДокумент"] = Раздел;
		ТекТабличноеПоле           = Форма["ТабличныйДокумент"];

	КонецЕсли;

	// выводим значения строк
	Для Каждого СтрокаТаблицы Из СтруктураГруппы Цикл
		НомерСтрокиВТаблице      = СтруктураГруппы.Индекс(СтрокаТаблицы);
		НомерСтрокиВФормеТаблицы = НомерСтрокиВТаблице + 1;
		НомерСтрокиВФормеТаблицыСтр = Формат(НомерСтрокиВФормеТаблицы, "ЧГ=0");
						
		Для НомерГрафы = 1 По Форма.мСтруктураКолвоКолонокРазделов[ИмяГруппы] Цикл
			
			КолонкаТаблицыИмя = ИмяГруппы + Формат(НомерГрафы, "ЧЦ=2; ЧВН=");
			
			Если СтруктураГруппы[0].Свойство(КолонкаТаблицыИмя) Тогда
				
				ЗначениеЯчейки           = СтрокаТаблицы[КолонкаТаблицыИмя];
				ИмяЯчейки                = КолонкаТаблицыИмя + "_" + НомерСтрокиВФормеТаблицыСтр;
				
				ОбластьЯчейкиТаблицы          = ТекТабличноеПоле.Области[ИмяЯчейки];
				
				Если ОбластьЯчейкиТаблицы.СодержитЗначение = Истина Тогда
					ОбластьЯчейкиТаблицы.Значение = ЗначениеЯчейки;
				Иначе
					ОбластьЯчейкиТаблицы.Текст = ЗначениеЯчейки;
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЦикла;

	КонецЦикла;
	
КонецПроцедуры

// Проверяет, входит ли показатель в многострочную часть.
//
Функция ПоказательВходитВМногострочнуюЧасть(Форма, ИмяПоказателя) Экспорт
    	
	Если НЕ СвойствоОпределено(Форма, "мСтруктураМногострочныхРазделов") Тогда
		Возврат 0;
	КонецЕсли;



	
	ПозицияXXXX = Найти(ИмяПоказателя, "XXXX");
	Если ПозицияXXXX = 0 Тогда
		Возврат 0;
	КонецЕсли;
	ИмяГруппы = Лев(ИмяПоказателя, ПозицияXXXX - 1);

	СтруктураГруппы = Неопределено;

	Если НЕ Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы) Тогда
		Возврат 0;
	Иначе
		СтруктураГруппы = Форма[СтруктураГруппы];
		Возврат СтруктураГруппы.Количество();
	КонецЕсли;

КонецФункции

// Возвращает таблицу отчетов, действующих в выбранном отчетном периоде.
//
Функция ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма, ДляВыбораПриСозданииОтчета = Истина) Экспорт

	#Если НаКлиенте Тогда
		Форма.РезультирующаяТаблица.Очистить();
	#Иначе
		// Объявим таблицу результата.
		РезультирующаяТаблица = Форма.мТаблицаФормОтчета.Выгрузить();
		РезультирующаяТаблица.Очистить();
	#КонецЕсли
	
	// Осуществим перебор по таблице содеражащей формы отчетов и периоды действий.
	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = ПустоеЗначениеТипа(Тип("Дата")), '20291231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы 
		   ИЛИ ДляВыбораПриСозданииОтчета
		   Тогда

			// Перебираемая запись из таблицы форм удовлетворяет текущим параметрам
			// учитывая конец периода отчета.
			#Если НаКлиенте Тогда
				НоваяФорма = Форма.РезультирующаяТаблица.Добавить();
			#Иначе
				НоваяФорма = РезультирующаяТаблица.Добавить();
			#КонецЕсли
			НоваяФорма.ФормаОтчета        = ЭлФорма.ФормаОтчета;
			НоваяФорма.ОписаниеОтчета     = ЭлФорма.ОписаниеОтчета;
			НоваяФорма.ДатаНачалоДействия = ЭлФорма.ДатаНачалоДействия;
			НоваяФорма.ДатаКонецДействия  = ЭлФорма.ДатаКонецДействия;

		КонецЕсли;

	КонецЦикла;

	#Если НаКлиенте Тогда
		Возврат Форма.РезультирующаяТаблица;
	#Иначе
		Возврат РезультирующаяТаблица;
	#КонецЕсли
	
КонецФункции

// Обновляет структуру многострочных разделов.
//
Процедура ОбновитьСтруктуруМногострочныхРазделов(Форма) Экспорт
	// Заполняет таблицу значений многострочного раздела
	// указанными в соответствующих ячейках значениями

	// Заполнение выполняется синхронно для всех многострочных разделов
	Для Каждого ЭлементСтруктуры Из Форма.мСтруктураМногострочныхРазделов Цикл
		ИмяГруппы = ЭлементСтруктуры.Ключ;
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаКлиенте(ИмяГруппы);
		#Иначе
			Форма.ОбновитьСтруктуруМногострочногоРазделаНаСервере(ИмяГруппы);
		#КонецЕсли
	КонецЦикла;
	
КонецПроцедуры

// Возвращает количество листов в разделе.
//
Функция КолвоЛистоВРазделе(Форма, ИмяСтраницыПанели) Экспорт

	ФлагИскл = 0;
	КолЛистовВОдномерномЛисте = 1;

	ТекТаблПоле = Форма["ПолеТабличногоДокумента" + ИмяСтраницыПанели];

	Пока ФлагИскл = 0 Цикл

		Если КолЛистовВОдномерномЛисте = 1 Тогда
			КолЛистовВОдномерномЛистеСтр = "";
		Иначе
			КолЛистовВОдномерномЛистеСтр = Формат(Число(КолЛистовВОдномерномЛисте)) + "_";
		КонецЕсли;

		Если ТекТаблПоле.Области.Найти("НомСтр" + КолЛистовВОдномерномЛистеСтр + "1") <> Неопределено Тогда

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте + 1;

		Иначе

			КолЛистовВОдномерномЛисте = КолЛистовВОдномерномЛисте - 1;
			ФлагИскл = 1;

		КонецЕсли;

	КонецЦикла;// пока искл = 0

	Возврат КолЛистовВОдномерномЛисте;

КонецФункции

// Устанавливает цвет фона ячейки.
//
Процедура УстановитьЦветФонаЯчейки(Форма, ИмяЯчейки = Неопределено, ВариантЗаполнения = Неопределено, ИмяТекущейСтраницыПанели = "") Экспорт
	Перем ЦветФона;
	Перем Комментарий;

	// Не нужно разукрашивать табличные поля, если открывается без открытия формы (например печать или просмотр)
	Если Форма.СтруктураРеквизитовФормы.мБезОткрытияФормы Или Форма.СтруктураРеквизитовФормы.мРежимПечати Тогда
		Возврат;
	КонецЕсли;

	Если Не ИмяЯчейки = Неопределено Тогда
		// устанавливаем цвет фона конкретной ячейки
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяСтраницыПанели = РегламентированнаяОтчетностьКлиент.ОпределитьСтраницуПанелиПоКодуПоказателяНаКлиенте(Форма, ИмяЯчейки);
		#Иначе
			ИмяСтраницыПанели = РегламентированнаяОтчетностьВызовСервера.ОпределитьСтраницуПанелиПоКодуПоказателяНаСервере(Форма, ИмяЯчейки);
		#КонецЕсли
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат;
		КонецЕсли;

		ИмяПоляТаблДокумента = "ТабличныйДокумент";

		Ключ = "_" + ВариантЗаполнения;
		Форма.мСтруктураЦветовРаскраски.Свойство(Ключ, ЦветФона);

		// КодПоказателяПоСтруктуре
		ЗначениеВКвадратах = ОбластьЯвляетсяЯчейкойСоставногоПоля(Форма, ИмяЯчейки);

		Если ВариантЗаполнения = 4 Тогда

			Если ЗначениеВКвадратах Тогда
				// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
				СвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"УстановитьЗащиту");
			Иначе
				Форма[ИмяПоляТаблДокумента].Области[ИмяЯчейки].Защита = Истина;
			КонецЕсли;

		Иначе

			Если ЗначениеВКвадратах Тогда
				// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
				СвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"СнятьЗащиту");
			Иначе
				Форма[ИмяПоляТаблДокумента].Области[ИмяЯчейки].Защита = Ложь;
			КонецЕсли;
			
		КонецЕсли;

		// установим цвет ячейки
		Если ЗначениеВКвадратах Тогда
			СвойстваГрупповыхЗначений(Форма, ИмяЯчейки,"ПроставитьЦветРаскраски", ЦветФона);
		Иначе
			Форма[ИмяПоляТаблДокумента].Области[ИмяЯчейки].ЦветФона = ЦветФона;
		КонецЕсли;

	Иначе
		// устанавливаем цвет фона всех автозаполняемых ячеек активной страницы

		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, ИмяТекущейСтраницыПанели);
		#Иначе
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, ИмяТекущейСтраницыПанели);
		#КонецЕсли
		
		Если ТаблицаВариантыЗаполнения = Неопределено Тогда
			Возврат;
		КонецЕсли;

		Для Каждого Строка Из ТаблицаВариантыЗаполнения Цикл
			ИмяПоказателя            =  Строка.КодПоказателя;
			ВариантЗаполнения        =  Строка.ВариантЗаполнения;
			Комментарий              =  Строка.Комментарий;
			КодПоказателяПоСтруктуре =  Строка.КодПоказателяПоСтруктуре;

			КолвоСтрокВМногострочнойЧасти = ПоказательВходитВМногострочнуюЧасть(Форма, ИмяПоказателя);

			Если КолвоСтрокВМногострочнойЧасти > 0 Тогда
				Многострочность = Истина;
				БазоваяЧасть = ИмяПоказателя;
				ОписанияБлоков = ПолучитьСвойствоРаздела(Форма, ИмяТекущейСтраницыПанели, "МногострочностьВРазделе");

				Если ТипЗнч(ОписанияБлоков) = Тип("Число") Тогда
					ВБлокеВсеПоказателиЗаполняются = Истина;
				ИначеЕсли ТипЗнч(ОписанияБлоков) = Тип("ДанныеФормыКоллекция") Тогда
					ИмяГруппы = Сред(ИмяПоказателя, 1, 11);
					ВБлокеВсеПоказателиЗаполняются = НЕ ОписанияБлоков.НайтиСтроки(Новый Структура("ИдГруппы", ИмяГруппы))[0].НезаполняемыеПоказателиЕсть;
				КонецЕсли;

			Иначе
				Многострочность = Ложь;
				ВБлокеВсеПоказателиЗаполняются = Истина;
				КолвоСтрокВМногострочнойЧасти = 1;
			КонецЕсли;

			Для Инд = 1 По КолвоСтрокВМногострочнойЧасти Цикл

				Если Многострочность Тогда
					ИмяПоказателя = БазоваяЧасть + "_" + Формат(Инд, "ЧГ=0");
					// Декларация по НДС. В многострочном блоке встречаются строки, которые не должны быть закрашены в стандартный зеленый цвет.
					
				КонецЕсли;

				Если НЕ ВБлокеВсеПоказателиЗаполняются Тогда
					
					#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
						ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаКлиенте(ИмяПоказателя);
					#Иначе
						ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаСервере(ИмяПоказателя);
					#КонецЕсли
					
					Если ЭтотПоказательНеЗаполняется Тогда
						Продолжить;
					КонецЕсли;
					
				КонецЕсли;

				ТекОбластьЯчеек = Форма.ТабличныйДокумент.Области[ИмяПоказателя];
				Если (Не ПустаяСтрока(Комментарий)) ИЛИ (Не ПустаяСтрока(ТекОбластьЯчеек.Примечание.Текст)) Тогда
					ТекОбластьЯчеек.Примечание.Текст = Комментарий;
				КонецЕсли;

				Ключ = "_" + ВариантЗаполнения;
				Форма.мСтруктураЦветовРаскраски.Свойство(Ключ, ЦветФона);

				ЗначениеВКвадратах = ?(ПустаяСтрока(КодПоказателяПоСтруктуре), Ложь, Истина);

				Если ВариантЗаполнения = 4 Тогда

					Если ЗначениеВКвадратах Тогда
						// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
						СвойстваГрупповыхЗначений(Форма, ИмяПоказателя, "УстановитьЗащиту");
					Иначе
						Форма.ТабличныйДокумент.Области[ИмяПоказателя].Защита = Истина;
					КонецЕсли;

				Иначе

					Если ЗначениеВКвадратах Тогда
						// если ЗНАЧЕНИЕ КВАДРАТИЧНОЕ
						СвойстваГрупповыхЗначений(Форма, ИмяПоказателя,"СнятьЗащиту");
					Иначе
						Форма.ТабличныйДокумент.Области[ИмяПоказателя].Защита = Ложь;
					КонецЕсли;
				КонецЕсли;

				Если ЗначениеВКвадратах Тогда
					СвойстваГрупповыхЗначений(Форма, ИмяПоказателя,"ПроставитьЦветРаскраски", ЦветФона);
				Иначе
					Форма.ТабличныйДокумент.Области[ИмяПоказателя].ЦветФона = ЦветФона;
				КонецЕсли;
			КонецЦикла;

		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Проверяет, является ли ячейка составным полем.
//
Функция ОбластьЯвляетсяЯчейкойСоставногоПоля(Форма, ИмяЯчейки, БыстраяПроверка = Истина) Экспорт

		СмысловаяЧасть = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки);
		Если СмысловаяЧасть = "" Тогда
			// не квадратичная ячейка
			Возврат Ложь;
		КонецЕсли;

		Если БыстраяПроверка Тогда
			Возврат Истина;
		КонецЕсли;

		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ИмяСтраницыПанели = РегламентированнаяОтчетностьКлиент.ОпределитьСтраницуПанелиПоКодуПоказателяНаКлиенте(Форма, ИмяЯчейки);
		#Иначе
			ИмяСтраницыПанели = РегламентированнаяОтчетностьВызовСервера.ОпределитьСтраницуПанелиПоКодуПоказателяНаСервере(Форма, ИмяЯчейки);
		#КонецЕсли
		
		Если ИмяСтраницыПанели = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;

		ИмяПоляТаблДокумента = "ПолеТабличногоДокумента" + ИмяСтраницыПанели;

		// Получаем текущий счетчик
		ТекущийСчетчик = ПолучитьСмысловуюЧастьИмениЯчейки(ИмяЯчейки,Ложь);
		Если СтрДлина(ТекущийСчетчик) >= 2 Тогда

			Если Сред(ТекущийСчетчик, 1, 1) = "0" Тогда
				ПризнакСчетчикаСнулемВпереди = Истина;
			Иначе
				ПризнакСчетчикаСнулемВпереди = Ложь;
			КонецЕсли;
		Иначе
			ПризнакСчетчикаСнулемВпереди = Ложь; // перед счетчиком нет нуля
		КонецЕсли;

		Если ЯвляетсяЧислом(ТекущийСчетчик) Тогда
			ТекущийСчетчикЦел = ТекущийСчетчик;
		Иначе
			Возврат Ложь;
		КонецЕсли;

		Координата = СмысловаяЧасть + ?(ПризнакСчетчикаСнулемВпереди = Истина,"0" + Строка(ТекущийСчетчикЦел + 1),ТекущийСчетчикЦел + 1);

		Если Форма[ИмяПоляТаблДокумента].Области.Найти(Координата) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;

		// значение получено
		Возврат Истина;

КонецФункции

Процедура ПрорисоватьПодменюПечать(Форма) Экспорт
	
	Форма.Элементы.ПечататьСразу.Доступность = Истина;
	Форма.Элементы.ПоказатьБланк.Доступность = Истина;
	
	Форма.Элементы.ПечататьСразу.Видимость = Истина;
	Форма.Элементы.ПоказатьБланк.Видимость = Истина;
		
КонецПроцедуры


// Устанавливает формат вывода.
//
Процедура УстановитьФорматВывода(Форма, НаимРаздела) Экспорт
	Перем СтруктураГруппы;
	Перем РазмерностьПрописьюТекст;

	ЕдиницаИзмерения = Форма.СтруктураРеквизитовФормы.ЕдиницаИзмерения;
	ТочностьЕдиницыИзмерения = Форма.СтруктураРеквизитовФормы.ТочностьЕдиницыИзмерения;
	Если ЕдиницаИзмерения = Форма.ПорядкиОкругленияОтчетности.ПеречислениеПорядкиОкругленияОтчетностиОкр1 Тогда
		Форма.СтруктураРеквизитовФормы.мДелитель = 1;
		РазмерностьПрописьюТекст = "в гривнях";
		Форма.СтруктураРеквизитовФормы.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 0";

	ИначеЕсли ЕдиницаИзмерения = Форма.ПорядкиОкругленияОтчетности.ПеречислениеПорядкиОкругленияОтчетностиОкр1000 Тогда
		Форма.СтруктураРеквизитовФормы.мДелитель = 1000;
		РазмерностьПрописьюТекст = "в тис. гривень";
		Форма.СтруктураРеквизитовФормы.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 3";
		
	ИначеЕсли ЕдиницаИзмерения = Форма.ПорядкиОкругленияОтчетности.ПеречислениеПорядкиОкругленияОтчетностиОкр1000000 Тогда
		Форма.СтруктураРеквизитовФормы.мДелитель = 1000000;
		РазмерностьПрописьюТекст = "в млн. гривень";
		Форма.СтруктураРеквизитовФормы.мСтрокаФормата = "ЧЦ = 17; ЧДЦ = " + ТочностьЕдиницыИзмерения + "; ЧРД=,; ЧН=-; ЧС = 6";
		
	КонецЕсли;

	Для Каждого СтрПоказатели Из Форма.мТаблицаСоставПоказателей Цикл

		Если НЕ НаимРаздела = СтрПоказатели.ИмяПоляТаблДокумента Тогда
			Продолжить;
		КонецЕсли;
		
		КодПоказателя        = СокрП(СтрПоказатели.КодПоказателяПоСоставу);
		ПризнМногострочность = СокрП(СтрПоказатели.ПризнМногострочности);
		КодПоказателяПоСтруктуре = СокрП(СтрПоказатели.КодПоказателяПоСтруктуре);
		КодПоказателяПоФорме = СокрП(СтрПоказатели.КодПоказателяПоФорме);
        		
		Если КодПоказателя = "===" Тогда
			Прервать;
		КонецЕсли;

		Если (Лев(КодПоказателя, 2) = "//") ИЛИ (КодПоказателя = "###") Тогда
			Продолжить;
		КонецЕсли;

		КодПоказателяВФорме = СокрП(СтрПоказатели.КодПоказателяПоФорме);

		ИмяПоказателя = КодПоказателя;
		Если Не ПустаяСтрока(КодПоказателяВФорме) Тогда
			ИмяПоказателя = КодПоказателяВФорме;
		КонецЕсли;

		ТипДанныхПоказателя = СокрП(СтрПоказатели.ТипДанныхПоказателя);
        		
		Если (ТипДанныхПоказателя = "Е") И (ПустаяСтрока(КодПоказателяПоСтруктуре)) Тогда

			ТекТабличноеПоле = Форма.ТабличныйДокумент;

			Если ПризнМногострочность <> "/" Тогда
				ФорматируемаяОбласть = ТекТабличноеПоле.Области[ИмяПоказателя];
				// Получим установленный в ячейки признак допустимого знака.
				ДопустимыйЗнакПоказателя = ФорматируемаяОбласть.ТипЗначения.КвалификаторыЧисла.ДопустимыйЗнак;

				ЧислоЕЗнак = Форма.СтруктураРеквизитовФормы.мОписаниеТиповЧислоЕ;
				Если ДопустимыйЗнакПоказателя = ДопустимыйЗнак.Неотрицательный Тогда
					// Создадим числовой тип на основе мОписаниеТиповЧислоЕ, с учетом знака отрицательности.
					Массив = Новый Массив;
					Массив.Добавить(Тип("Число"));
					КвалификаторЧисла = Новый КвалификаторыЧисла(ЧислоЕЗнак.КвалификаторыЧисла.Разрядность,ЧислоЕЗнак.КвалификаторыЧисла.РазрядностьДробнойЧасти, ДопустимыйЗнакПоказателя);
					ЧислоЕЗнак = Новый ОписаниеТипов(Массив, КвалификаторЧисла);
				КонецЕсли;
				ФорматируемаяОбласть.ТипЗначения = ЧислоЕЗнак;
				ФорматируемаяОбласть.Формат = Форма.СтруктураРеквизитовФормы.мСтрокаФормата;
			Иначе
				// определяем кол-во строк многострочного раздела
				// и применяем процедуру форматирования к данной графе
				// по всем строкам
				ИмяГруппы = Лев(ИмяПоказателя, 11);
				Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
				СтруктураГруппы = Форма[СтруктураГруппы];
				ОписанияБлоков = ПолучитьСвойствоРаздела(Форма, НаимРаздела, "МногострочностьВРазделе");
				ОписанияБлоковТип = ТипЗнч(ОписанияБлоков);
				Если ОписанияБлоковТип = Тип("Число") Тогда
					ВБлокеВсеПоказателиЗаполняются = Истина;
				ИначеЕсли ОписанияБлоковТип = Тип("ДанныеФормыКоллекция") Тогда
					#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
						ВБлокеВсеПоказателиЗаполняются = НЕ ОписанияБлоков.НайтиСтроки(Новый Структура("ИдГруппы", ИмяГруппы))[0].НезаполняемыеПоказателиЕсть;
					#Иначе
						ВБлокеВсеПоказателиЗаполняются = НЕ ДанныеФормыВЗначение(ОписанияБлоков, Тип("ТаблицаЗначений")).Найти(ИмяГруппы, "ИдГруппы").НезаполняемыеПоказателиЕсть;
					#КонецЕсли
				КонецЕсли;

				Для НСтр = 1 По СтруктураГруппы.Количество() Цикл
					Если НЕ ВБлокеВсеПоказателиЗаполняются Тогда
						
						#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
							ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаКлиенте(ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0"));
						#Иначе
							ЭтотПоказательНеЗаполняется = Форма.ЭтотПоказательНеЗаполняетсяНаСервере(ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0"));
						#КонецЕсли
						
						Если ЭтотПоказательНеЗаполняется Тогда
							Продолжить;
						КонецЕсли;
						
					КонецЕсли;

					ФорматируемаяОбласть = ТекТабличноеПоле.Области[ИмяПоказателя + "_" + Формат(НСтр, "ЧГ=0")];
					// Получим установленный в ячейки признак допустимого знака.
					ДопустимыйЗнакПоказателя = ФорматируемаяОбласть.ТипЗначения.КвалификаторыЧисла.ДопустимыйЗнак;

					ЧислоЕЗнак = Форма.СтруктураРеквизитовФормы.мОписаниеТиповЧислоЕ;
					Если ДопустимыйЗнакПоказателя = ДопустимыйЗнак.Неотрицательный Тогда
						// Создадим числовой тип на основе мОписаниеТиповЧислоЕ, с учетом знака отрицательности.
						Массив = Новый Массив;
						Массив.Добавить(Тип("Число"));
						КвалификаторЧисла = Новый КвалификаторыЧисла(ЧислоЕЗнак.КвалификаторыЧисла.Разрядность,ЧислоЕЗнак.КвалификаторыЧисла.РазрядностьДробнойЧасти, ДопустимыйЗнакПоказателя);
						ЧислоЕЗнак = Новый ОписаниеТипов(Массив, КвалификаторЧисла);
					КонецЕсли;

					ФорматируемаяОбласть.ТипЗначения = ЧислоЕЗнак;
					ФорматируемаяОбласть.Формат = Форма.СтруктураРеквизитовФормы.мСтрокаФормата;

				КонецЦикла;
			КонецЕсли;
		КонецЕсли;
    
	КонецЦикла;

КонецПроцедуры

// Возвращает представление регламентированного отчета.
//
Функция ПредставлениеДокументаРеглОтч(Док) Экспорт
	
	Если ТипЗнч(Док) = Тип("ДокументСсылка.РегламентированныйОтчет") Тогда
		Представление = "" + Док.НаименованиеОтчета + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	ИначеЕсли ТипЗнч(Док) = Тип("ДанныеФормыЭлементКоллекции") Тогда
		Представление = "" + Док.Отчет + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	ИначеЕсли ТипЗнч(Док) = Тип("Структура") И Док.Свойство("НаименованиеОтчета") Тогда
		Представление = "" + Док.НаименованиеОтчета + " за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	Иначе
		Представление = """ за " + ПредставлениеПериода(НачалоДня(Док.ДатаНачала), КонецДня(Док.ДатаОкончания), "ФП=Истина");
	КонецЕсли;
			
	Возврат Представление;
	
КонецФункции

// Сохраняет значение в многостраничном блоке.
//
Процедура СохранитьЗначениеВМногостраничномБлоке(Форма, Знач ИмяГруппы, Знач НомерСтрокиНаФорме, Знач ИмяКолонки, Знач ЗначениеПоказателя) Экспорт
	Перем СтруктураГруппы;
	
	Форма.мСтруктураМногострочныхРазделов.Свойство(ИмяГруппы, СтруктураГруппы);
	
	СтруктураГруппы = Форма[СтруктураГруппы];
	
	СтруктураГруппы[Число(НомерСтрокиНаФорме) - 1][ИмяКолонки] = ЗначениеПоказателя;

КонецПроцедуры

// Процедура вызывается после вставки дополнительной страницы.
//
Процедура ПослеВставкиДополнительнойСтраницы(Форма, ИмяВставляемойСтраницы, ПерейтиНаВставленныйЛист = Истина) Экспорт
	
	ТекущийЭлемент = Форма.РазделыОтчета.НайтиПоИдентификатору(Форма.Элементы.РазделыОтчета.ТекущаяСтрока);
	
	Родитель = ТекущийЭлемент.ПолучитьРодителя();

	Если НЕ Родитель = Неопределено Тогда
		ТекущийЭлемент = Родитель;
	КонецЕсли;
    	
	НомерДобавляемойСтраницы = ТекущийЭлемент.ПолучитьЭлементы().Количество() + 1;
    	
	ДобавляемаяСтраница = ТекущийЭлемент.ПолучитьЭлементы().Добавить();
	ДобавляемаяСтраница.КолонкаРазделыОтчета              = НСтр("ru='Стр. ';uk='Стор. '") + НомерДобавляемойСтраницы;
	ДобавляемаяСтраница.КолонкаРазделыОтчетаСокрНаим      = ТекущийЭлемент.КолонкаРазделыОтчетаСокрНаим;
	ДобавляемаяСтраница.КолонкаНомерСтраницыРазделаОтчета = НомерДобавляемойСтраницы;
	ДобавляемаяСтраница.ИндексКартинки                    = 1;
	ДобавляемаяСтраница.РазделМногостраничный             = ТекущийЭлемент.РазделМногостраничный;
	ДобавляемаяСтраница.РазделМногострочный               = ТекущийЭлемент.РазделМногострочный;
	
	Если ПерейтиНаВставленныйЛист Тогда
		Форма.Элементы.РазделыОтчета.ТекущаяСтрока = ДобавляемаяСтраница.ПолучитьИдентификатор();
	КонецЕсли;

КонецПроцедуры

// Очищает показатели отчета, заполняемые из ИБ.
//
Процедура ОчиститьПоказателиОтчетаЗаполняемыеИзИБ(Форма, НазванияМногостраничныхРазделовДляУдаления = "") Экспорт

	Если НЕ ПустаяСтрока(НазванияМногостраничныхРазделовДляУдаления) Тогда
		НазванияМнгостраничныхРазделов = Новый Структура(НазванияМногостраничныхРазделовДляУдаления);
	Иначе
		НазванияМнгостраничныхРазделов = Новый Структура;
	КонецЕсли;

	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
		НазваниеСтраницы           = СтрокаУровня1.ИмяСтраницы;
		МногостраничностьВРазделе  = СтрокаУровня1.МногостраничностьВРазделе;
		РазделАвтозаполняется = СтрокаУровня1.РазделЯвляетсяАвтозаполняемым;

		Если НазваниеСтраницы = "Титульный"
		 ИЛИ НЕ НазваниеСтраницы = НазванияМногостраничныхРазделовДляУдаления Тогда
			Продолжить;
		КонецЕсли;

		мРазделИмя = "ТабличныйДокумент";
		мРаздел    = Форма[мРазделИмя];
		Если НазванияМнгостраничныхРазделов.Свойство(НазваниеСтраницы) Тогда
			// Очистим текущий лист.
			#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
				Форма.ОчиститьТабличноеПолеНаКлиенте(НазваниеСтраницы);
			#Иначе
				Форма.ОчиститьТабличноеПолеНаСервере(НазваниеСтраницы);
			#КонецЕсли
							
			ТаблицаСтраницРаздела = Неопределено;
			Форма.мСтруктураМногостраничныхРазделов.Свойство(НазваниеСтраницы, ТаблицаСтраницРаздела);
			
			ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
			
			ИндексСтраницы = 0;
			Пока Не (ИндексСтраницы > (ТаблицаСтраницРаздела.Количество()-1)) Цикл
				СтрокаТаблицы = ТаблицаСтраницРаздела[ИндексСтраницы];
				Если НЕ СтрокаТаблицы.АктивнаяСтраница Тогда
					// удаляем дополнительную страницу
					ТаблицаСтраницРаздела.Удалить(СтрокаТаблицы);
					Продолжить;
				КонецЕсли;
				ИндексСтраницы = ИндексСтраницы + 1;
			КонецЦикла;
									
			// Варианты заполнения установим в один массив. Все варианты возьмем из Эталона.
			// Цвет ячеек перерисуется в показе статика многостраничного раздела, ниже.
			ОчиститьВариантыЗаполнения(Форма, НазваниеСтраницы, Ложь);
			
			Продолжить;

		КонецЕсли;
		
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ВариантыАвтозаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, НазваниеСтраницы);
		#Иначе
			ВариантыАвтозаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, НазваниеСтраницы);
		#КонецЕсли

		Если ВариантыАвтозаполнения <> Неопределено Тогда

			Если ВариантыАвтозаполнения[0].Свойство("КодПоказателяПоСтруктуре") Тогда
				ПоказательПоСтруктуре = Истина;
			Иначе
				ПоказательПоСтруктуре = Ложь;
			КонецЕсли;

			// Переберем все показатели, которые могут заполняться из ИБ или автозаполняемые.
			Для каждого Пок Из ВариантыАвтозаполнения Цикл

				Если ПоказательПоСтруктуре Тогда
					Если НЕ ПустаяСтрока(Пок.КодПоказателяПоСтруктуре) Тогда
						// Для показателей квадратичных, очистка произойдет через Расчет()
						Продолжить;
					КонецЕсли;
				КонецЕсли;

				КодПоказателя = Пок.КодПоказателя;
				Если (Пок.ВариантЗаполнения = 3) Тогда // Или (Пок.ВариантЗаполнения = 4) Тогда
					// Если показатель в многострочной части, вернем кол-во строк блока.
					Колво = ПоказательВходитВМногострочнуюЧасть(Форма, КодПоказателя);
					Если Колво = 0 Тогда
						мРаздел.Области[КодПоказателя].Очистить();
					Иначе
						Для Инд = 1 По Колво Цикл
							мРаздел.Области[КодПоказателя + "_" + Формат(Инд, "ЧГ=0")].Очистить();
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;

	КонецЦикла;
	
КонецПроцедуры

// Очищает варианты заполнения.
//
Процедура ОчиститьВариантыЗаполнения(Форма, Знач Раздел = Неопределено, УстановитьЦветВРазделе = Истина) Экспорт
//Процедура ОчиститьВариантыЗаполнения(Форма, Знач Раздел = Неопределено, УстановитьЦветВРазделе = Истина, Знач ИмяСекции = "") Экспорт

	Перем МассивВариантовЗаполненияСтраниц;

	// Данная процедура используется только в новых декларациях, где установлены показатели Е как 14.2
	// Через процеудру УстановитьФормат

	мОписаниеТиповЧислоЕ = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(14, 2));
	ИзмененияЕсть = Ложь;
	Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
		// Считываем название раздела и его свойство в системе автозаполнения
		НазваниеСтраницы = СтрокаУровня1.ИмяСтраницы;
		Если Раздел <> Неопределено Тогда
			Если Раздел <> НазваниеСтраницы Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;

		Если Форма.мСтруктураВариантыЗаполнения.Свойство(НазваниеСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
			
			МассивВариантовЗаполненияСтраниц = Форма["ТаблицаВариантыЗаполнения" + НазваниеСтраницы];
			
			// Получим ЭТАЛОННЫЙ макет вариантов показателей.
			#Если НаКлиенте Тогда
				ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, НазваниеСтраницы, Истина, мОписаниеТиповЧислоЕ);
			#Иначе
				ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, НазваниеСтраницы, Истина, мОписаниеТиповЧислоЕ);
			#КонецЕсли

			// Сюда попадают Титульные, ФизЛица и др.
			Если ТаблицаВариантыЗаполнения <> Неопределено Тогда
				
				МассивВариантовЗаполненияСтраниц.Очистить();
				
				// Вставим в массив эталонный вариант.
				ТаблВариантов = МассивВариантовЗаполненияСтраниц.Добавить();
				
				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					КопироватьДанныеФормы(ТаблицаВариантыЗаполнения, ТаблВариантов);
				#Иначе
					ТаблВариантов.ТаблицаВариантовЗаполнения.Загрузить(ТаблицаВариантыЗаполнения);
				#КонецЕсли
				
				Форма.мСтруктураВариантыЗаполнения.Вставить(НазваниеСтраницы, НазваниеСтраницы);
				
				ИзмененияЕсть = Истина;

			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

	Если (ИзмененияЕсть) И (Форма.СтруктураРеквизитовФормы.ФлажокОтклАвтоРасчет) Тогда
		
		ИзменитьТаблицуВариантовЗаполнения(Форма, НЕ Форма.СтруктураРеквизитовФормы.ФлажокОтклАвтоРасчет);
		
	КонецЕсли;

	Если (ИзмененияЕсть) И (НЕ Форма.СтруктураРеквизитовФормы.ФлажокОтклАвтоРасчет) Тогда
		// Обеспечим простановку цветов ячеек.
		// Автоматически при переходах по вкладкам разделов устанавливаются цвета только
		// Для многостраничных разделов. Поэтому, если раздел не многостраничны и автозаполняется
		// тогда прорисовываем цвета, а также, если многостраничный, автозаполняемый и текущий лист,
		// также перерисуем.
		Для Каждого СтрокаУровня1 Из Форма.мСвойстваРазделовДекларации.ПолучитьЭлементы() Цикл
			ИмяСтраницы = СтрокаУровня1.ИмяСтраницы;

			// Возможно, нужный раздел передали через параметр. Тогда установим цвета только
			// в нужном разделе.
			Если Раздел <> Неопределено Тогда
				Если Раздел <> ИмяСтраницы Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;

			Автозаполняется = ПолучитьСвойствоРаздела(Форма, ИмяСтраницы, "РазделЯвляетсяАвтозаполняемым", Ложь);
			//Многостраничность = РегламентированнаяОтчетностьКлиентСервер.ПолучитьСвойствоРаздела(Форма, ИмяСтраницы, "МногостраничностьВРазделе", Ложь);

			// Перерисовка по цвету происходить должна и для многостр. и для обычного раздела.
			// Т.к. меняются варианты заполнения. Процедура запускается при очистки отчета в целом
			// и перед автозаполнением для многостраничных разделов заполняемых из ИБ (крайние случаи: имущество, прибыль).
			// 
			// В механизме очистки отчета в целом, предусмотре вызов роОчиститьВариантыЗаполнения, поэтому
			// при очистки из отчета, всей декларации необходимо перекрасить ячейки, т.к. варианты при очистка декларации
			// всегда становятся эталонными, а значит, перекрашиваем ячейки в соответствующий цвет.

			Если Автозаполняется И УстановитьЦветВРазделе И ИмяСтраницы = Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела Тогда
				
				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,ИмяСтраницы);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,ИмяСтраницы);
				#КонецЕсли
									
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Изменяет таблицу вариантов заполнения.
//
Процедура ИзменитьТаблицуВариантовЗаполнения(Форма, ПолныйРучнойВвод = Ложь) Экспорт

	Перем МассивВариантовЗаполненияСтраниц;
	
	мДеревоСтраницОтчета = Форма.мДеревоСтраницОтчета;
	ПереборЗнач = мДеревоСтраницОтчета.ПолучитьЭлементы().Количество();

	Пока ПереборЗнач > 0 Цикл
		
		ИмяСтраницы = мДеревоСтраницОтчета.ПолучитьЭлементы()[ПереборЗнач-1].ИмяСтраницы;
		ПереборЗнач = ПереборЗнач-1;
		
		Попытка
			МногостраничностьЕсть = ?(Форма.мСтруктураМногостраничныхРазделов = Неопределено, Ложь, Истина);
		Исключение
			МногостраничностьЕсть = Ложь;
		КонецПопытки;
		
		Если МногостраничностьЕсть Тогда
			КолСтрВРазделе = ПолучитьКоличествоСтраницРаздела(Форма, ИмяСтраницы);
		Иначе
			КолСтрВРазделе = 1;
		КонецЕсли;
				
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьКлиент.ПолучитьТаблицуВариантовЗаполненияНаКлиенте(Форма, ИмяСтраницы);
		#Иначе
			ТаблицаВариантыЗаполнения = РегламентированнаяОтчетностьВызовСервера.ПолучитьТаблицуВариантовЗаполненияНаСервере(Форма, ИмяСтраницы);
		#КонецЕсли

		Если ТаблицаВариантыЗаполнения = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ПолныйРучнойВвод Тогда
				
			Если КолСтрВРазделе = 1 Тогда

				Для Каждого Строка Из ТаблицаВариантыЗаполнения Цикл
					Если Строка.ВариантЗаполнения = 4 Тогда
						Строка.ВариантЗаполнения = 0;
					КонецЕсли;
				КонецЦикла;
				
				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#КонецЕсли	
					
			КонецЕсли;
			
			Если КолСтрВРазделе >= 2 Тогда

				Если Не Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
					Продолжить;
				КонецЕсли;

				МассивВариантовЗаполненияСтраниц = Форма["ТаблицаВариантыЗаполнения" + ИмяСтраницы];
				
				Для Инд = 0 По МассивВариантовЗаполненияСтраниц.Количество() - 1 Цикл
					Для Каждого Строка Из МассивВариантовЗаполненияСтраниц[Инд].ТаблицаВариантовЗаполнения Цикл
						Если Строка.ВариантЗаполнения = 4 Тогда
							Строка.ВариантЗаполнения = 0;
						КонецЕсли;
					КонецЦикла;
				КонецЦикла;
				
				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#КонецЕсли
									
			КонецЕсли;

		ИначеЕсли ПолныйРучнойВвод Тогда

			Если КолСтрВРазделе = 1 Тогда
				Для Каждого Стр Из ТаблицаВариантыЗаполнения Цикл
					Если Стр.ВариантЗаполнения = 0 Тогда
						Стр.ВариантЗаполнения = 4
					КонецЕсли;
				КонецЦикла;

				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#КонецЕсли
				
			КонецЕсли;

			Если КолСтрВРазделе >= 2 Тогда
				
				Если Не Форма.мСтруктураВариантыЗаполнения.Свойство(ИмяСтраницы, МассивВариантовЗаполненияСтраниц) Тогда
					Продолжить;
				КонецЕсли;

				МассивВариантовЗаполненияСтраниц = Форма["ТаблицаВариантыЗаполнения" + ИмяСтраницы];
				
				Для Инд = 0 По МассивВариантовЗаполненияСтраниц.Количество() - 1 Цикл
					
					Для Каждого Строка Из МассивВариантовЗаполненияСтраниц[Инд].ТаблицаВариантовЗаполнения Цикл
						Если Строка.ВариантЗаполнения = 0 Тогда
							Строка.ВариантЗаполнения = 4;
						КонецЕсли;
					КонецЦикла;

				КонецЦикла;

				#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
					Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#Иначе
					Форма.УстановитьЦветФонаЯчейкиНаСервере(,,Форма.СтруктураРеквизитовФормы.НаимТекущегоРаздела);
				#КонецЕсли
				
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Устанавливает номера листов.
//
Процедура ПроставлениеНомеровЛистов(Форма, ПризнакНумеруемыхФорм = Истина, СписокПечатаемыхЛистов) Экспорт
	
	Если ПризнакНумеруемыхФорм Тогда
		НомерЛиста = 1;
		Для Каждого Эл Из Форма.СтруктураРеквизитовФормы.мПечатныеФормы Цикл
			НомерЛиста = НомерЛиста + 1;
		КонецЦикла;
		Если Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Количество() <> 0 Тогда
			ТаблДок = Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Получить(0).Значение;
			ЦифрВОбщемКоличествеЛистов = 0;
			Для ОбратныйИндекс = 1 По 9 Цикл
				Индекс = 10 - ОбратныйИндекс;
				Если ТаблДок.Области.Найти("СоставленаНа" + Индекс) <> Неопределено Тогда
					ЦифрВОбщемКоличествеЛистов = Индекс;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			ВсегоЛистов = Формат(НомерЛиста - 1, "ЧЦ=" + ЦифрВОбщемКоличествеЛистов + "; ЧН=0; ЧВН=; ЧГ=");
			Для Инд = 1 По ЦифрВОбщемКоличествеЛистов Цикл
				ТекИнд = ЦифрВОбщемКоличествеЛистов - Инд + 1;
				Попытка
					ТаблДок.Области["СоставленаНа" + ТекИнд].Значение = Сред(ВсегоЛистов, ТекИнд, 1);
				Исключение
				КонецПопытки;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	НомераЛистов = Новый СписокЗначений;
		
	НомерЛиста = 1;
	
	Для Каждого Эл Из Форма.СтруктураРеквизитовФормы.мПечатныеФормы Цикл
				
		НомЛиста = НомераЛистов.НайтиПоЗначению(Эл.Представление);
		Если НомЛиста = Неопределено Тогда
			НомЛиста = НомераЛистов.Добавить(Эл.Представление, "1");
			НЛиста = 1;
		Иначе
			НЛиста = Число(НомЛиста.Представление) + 1;
			НомЛиста.Представление = Строка(Число(НомЛиста.Представление) + 1);
		КонецЕсли;
		
		Значение = Новый Массив;
		Значение.Добавить(ПоместитьВоВременноеХранилище(Эл.Значение, Форма.УникальныйИдентификатор));
		Значение.Добавить(Форма.УникальныйИдентификатор);
		Значение.Добавить(Форма.Заголовок);
		
		СписокПечатаемыхЛистов.Добавить(Значение, Эл.Представление + НСтр("ru='. Лист №';uk='. Аркуш №'") + НЛиста);
				
		НомерЛиста = НомерЛиста + 1;
		
	КонецЦикла;
	
	Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Очистить();
	
КонецПроцедуры

// Формирует структуру параметров файла выгрузки.
// 
Функция СформироватьСтруктуруПараметровФайлаВыгрузки(ФайлВыгрузки) Экспорт

	ПоказателиВыгрузки = Новый Соответствие;
	ОбъектЧтениеXML = Новый ЧтениеXML;
	Попытка
		ОбъектЧтениеXML.ОткрытьФайл(ФайлВыгрузки);
		ОбъектЧтениеXML.ИгнорироватьПробелы = Ложь;
		Пока ОбъектЧтениеXML.Прочитать() Цикл
			Если Строка(ОбъектЧтениеXML.ТипУзла) = "Начало элемента" И ОбъектЧтениеXML.Имя <> "СодПерСвед" Тогда
				Пока ОбъектЧтениеXML.ПрочитатьАтрибут() Цикл
					ПоказателиВыгрузки.Вставить(ОбъектЧтениеXML.Имя, ОбъектЧтениеXML.Значение);
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		ОбъектЧтениеXML.Закрыть();
		ПоказателиВыгрузки.Вставить("ЭтоXML", Истина);
	Исключение
		Текст = Новый ЧтениеТекста;
		Текст.Открыть(ФайлВыгрузки, "cp866");
		ТекСтр = Текст.ПрочитатьСтроку();
		Пока ТекСтр <> Неопределено Цикл
			ТекСтр = СокрЛП(ТекСтр);
			ВхождениеДвоеточия = СтрНайти(ТекСтр, ":");
			Если ВхождениеДвоеточия <> 0 Тогда
				ПоказателиВыгрузки.Вставить(СокрЛП(Лев(ТекСтр, ВхождениеДвоеточия - 1)), СокрЛП(Сред(ТекСтр, ВхождениеДвоеточия + 1)));
			КонецЕсли;
			ТекСтр = Текст.ПрочитатьСтроку();
		КонецЦикла;
		Текст.Закрыть();
		ПоказателиВыгрузки.Вставить("ЭтоXML", Ложь);
	КонецПопытки;
	Возврат ПоказателиВыгрузки;

КонецФункции

// Преобразовывает строку в массив.
// 
Функция РазобратьСтрокуВМассивПоРазделителю(Знач Стр, СтрРазделитель = ".") Экспорт
	
	Результат = Новый Массив;
	
	ВхождениеРазделителя = СтрНайти(Стр, СтрРазделитель);
	Пока ВхождениеРазделителя <> 0 Цикл
		ЧастьДоРазделителя = СокрЛП(Лев(Стр, ВхождениеРазделителя - 1));
		Результат.Добавить(ЧастьДоРазделителя);
		Стр = СокрЛП(Сред(Стр, ВхождениеРазделителя + 1));
		ВхождениеРазделителя = СтрНайти(Стр, СтрРазделитель);
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(Стр) Тогда
		Результат.Добавить(СокрЛП(Стр));
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает значение реквизита.
//
Функция ПолучитьРеквизит(Реквизит1, Реквизит2) Экспорт
	Если Реквизит1 <> Неопределено И НЕ ПустаяСтрока(Реквизит1) Тогда
		Возврат Реквизит1;
	ИначеЕсли Реквизит2 <> Неопределено И НЕ Пустаястрока(Реквизит2) Тогда
		Возврат Реквизит2;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
КонецФункции

// Проверяет тип на пустое значение.
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции

// Возвращает текст сообщения об ошибке.
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = СтрНайти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = СтрНайти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1))
					   + Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
						 
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);

КонецФункции

// Выводит сообщение об ошибке.
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ, Заголовок = "", Знач Статус = Неопределено, ВызыватьИсключение = Истина) Экспорт
    	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если Сервер Тогда
		ЗаписьЖурналаРегистрации(НСтр("ru='Контрольная запись. Регламентированная отчетность';uk='Контрольний запис. Регламентована звітність'"), УровеньЖурналаРегистрации.Ошибка, , , Заголовок + Символы.ПС + ТекстСообщения);
	
	#ИначеЕсли ВнешнееСоединение Тогда
		
		Если ВызыватьИсключение Тогда
			Если ЗначениеЗаполнено(Заголовок) Тогда
				ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
				Заголовок = "";
			КонецЕсли;
			
			ВызватьИсключение (ТекстСообщения);
		КонецЕсли;
		
	#Иначе
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			
			Сообщение = Новый СообщениеПользователю;

			Сообщение.Текст = Заголовок;

			Сообщение.Сообщить();
						
			Заголовок = "";
			
		КонецЕсли;
		
		Сообщение = Новый СообщениеПользователю;

		Сообщение.Текст = ТекстСообщения;

		Сообщение.Сообщить();
		
	#КонецЕсли
	
КонецПроцедуры

// Процедура вызывается после очистки регламентированного отчета.
//
Процедура ПослеОчисткиРегламентированногоОтчета(Форма, ИмяСтраницы, ЗапускатьОтдельнуюОбработкуПослеОчисткиЛиста) Экспорт
	
	Форма.Модифицированность = Истина;
	
	Если НЕ Форма.Элементы.Найти("ТабличныйДокумент") = Неопределено
	   И ТипЗнч(Форма.ТабличныйДокумент) = Тип("ТабличныйДокумент") Тогда
		ОтрисоватьЗначкиУдаленияСтрок(Форма);
	КонецЕсли;
	
	// Если есть экспортная процедура ОперацииВыполняемыеПриУдаленииЭкземпляраМногостраничногоРаздела
	// определяющая действия после удаления экземплярности, тогда вызовем ее.
	// Например, в этой процеудуре может быть перерасчет каких-то листов,
	// перепроставление сквозных номеров и т.д. Пример: декларация по НДС 2007Кв1.
	Если ЗапускатьОтдельнуюОбработкуПослеОчисткиЛиста Тогда
		// Иммеет смысл только для многостраничного раздела.
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.СпециальныеОперацииПослеОчисткиЛистаНаКлиенте(ИмяСтраницы);
		#Иначе
			Форма.СпециальныеОперацииПослеОчисткиЛистаНаСервере(ИмяСтраницы);
		#КонецЕсли
	Иначе
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.РасчетНаКлиенте(ИмяСтраницы);
		#Иначе
			Форма.РасчетНаСервере(ИмяСтраницы);
		#КонецЕсли
	КонецЕсли;
	
	Если ПолучитьСвойствоРаздела(Форма, ИмяСтраницы, "РазделЯвляетсяАвтозаполняемым") Тогда
		#Если НаКлиенте И НЕ ТолстыйКлиентУправляемоеПриложение Тогда
			Форма.УстановитьЦветФонаЯчейкиНаКлиенте(,, ИмяСтраницы);
		#Иначе
			Форма.УстановитьЦветФонаЯчейкиНаСервере(,, ИмяСтраницы);
		#КонецЕсли
	КонецЕсли;
	
КонецПроцедуры

// Возвращает найденный элемент дерева.
//
Функция НайтиЭлементВДанныхФормыДерево(ЭлементыДанныхФормыДерево, ИмяКолонки, ИскомоеЗначение) Экспорт
	
	Для Ном = 0 По ЭлементыДанныхФормыДерево.Количество() - 1 Цикл
		
		ЭлементДерева = ЭлементыДанныхФормыДерево.Получить(Ном);
		
		Если ЭлементДерева[ИмяКолонки] = ИскомоеЗначение Тогда
			Возврат ЭлементДерева;
		КонецЕсли;
		
		Если ЭлементДерева.ПолучитьЭлементы().Количество() > 0 Тогда
			
			РезультатПоиска = НайтиЭлементВДанныхФормыДерево(ЭлементДерева.ПолучитьЭлементы(), ИмяКолонки, ИскомоеЗначение);
			
			Если НЕ РезультатПоиска = Неопределено Тогда
				Возврат РезультатПоиска;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

// Возвращает количество форм соответствующих выбранному периоду.
//
Функция КоличествоФормСоответствующихВыбранномуПериоду(Форма) Экспорт

	ИтоговоеКоличество = 0;

	Для Каждого ЭлФорма Из Форма.мТаблицаФормОтчета Цикл

		ДатаНачалаДействияФормы = ЭлФорма.ДатаНачалоДействия;
		ДатаКонцаДействияФормы  = КонецДня(?(ЭлФорма.ДатаКонецДействия = РегламентированнаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(Тип("Дата")), '20991231', ЭлФорма.ДатаКонецДействия));

		Если Форма.мДатаКонцаПериодаОтчета <= ДатаКонцаДействияФормы
		   И Форма.мДатаКонцаПериодаОтчета >= ДатаНачалаДействияФормы Тогда

			ИтоговоеКоличество = ИтоговоеКоличество + 1;

		КонецЕсли;

	КонецЦикла;

	Возврат ИтоговоеКоличество;

КонецФункции

// Выбирает форму регламентированного отчета по умолчанию.
//
Процедура ВыборФормыРегламентированногоОтчетаПоУмолчанию(Форма) Экспорт
	ТаблицаФормОтчета = РегламентированнаяОтчетностьКлиентСервер.ПолучитьТаблицуОтчетовДействующихВВыбранныйПериод(Форма, Ложь);
	Для Каждого Стр Из ТаблицаФормОтчета Цикл
		Если Стр.ДатаКонецДействия = РегламентированнаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(Тип("Дата")) Тогда
			Стр.ДатаКонецДействия = '20291231';
		КонецЕсли;
	КонецЦикла;

	ТаблицаФормОтчета.Сортировать("ДатаКонецДействия Убыв");

	Для Каждого Строка Из ТаблицаФормОтчета Цикл
		Если (Строка.ДатаНачалоДействия > КонецДня(Форма.мДатаКонцаПериодаОтчета)) ИЛИ
			((Строка.ДатаКонецДействия > '00010101000000') И (Строка.ДатаКонецДействия < НачалоДня(Форма.мДатаКонцаПериодаОтчета))) Тогда

			Продолжить;
		КонецЕсли;
		
		ТестСтруктура = Новый Структура("ПрямойМетод");
		ЗаполнитьЗначенияСвойств(ТестСтруктура, Форма);
		
		Если НЕ ТестСтруктура.ПрямойМетод = Неопределено Тогда
			
			Если  	  Найти(ВРЕГ(Строка.ФормаОтчета), ВРЕГ("НеПрямойМетод")) > 0 И Форма.ПрямойМетод = Ложь Тогда
				
				Форма.мВыбраннаяФорма 		= Строка.ФормаОтчета;
				Форма.ОписаниеНормативДок 	= Строка.ОписаниеОтчета;
				
			ИначеЕсли  Найти(ВРЕГ(Строка.ФормаОтчета), ВРЕГ("НеПрямойМетод")) = 0 И Форма.ПрямойМетод = Истина Тогда
				
				Форма.мВыбраннаяФорма 		= Строка.ФормаОтчета;
				Форма.ОписаниеНормативДок 	= Строка.ОписаниеОтчета;
				
			Иначе
				
				Продолжить;
				
			КонецЕсли;
			
		ИначеЕсли Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") И Найти(Строка.ФормаОтчета, "Мес") > 0 Тогда
			Форма.мВыбраннаяФорма     = Строка.ФормаОтчета;
			Форма.ОписаниеНормативДок = Строка.ОписаниеОтчета;
		ИначеЕсли Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") И Найти(Строка.ФормаОтчета, "Кв") > 0 Тогда
			Форма.мВыбраннаяФорма     = Строка.ФормаОтчета;
			Форма.ОписаниеНормативДок = Строка.ОписаниеОтчета;
		ИначеЕсли (    Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Месяц")
				   ИЛИ Форма.мПериодичность =  ПредопределенноеЗначение("Перечисление.Периодичность.Квартал"))
			    И
			      (    Найти(Строка.ФормаОтчета, "Кв") > 0
				   ИЛИ Найти(Строка.ФормаОтчета, "Мес") > 0) Тогда	
			Продолжить;	   
		Иначе
			Форма.мВыбраннаяФорма 	  = Строка.ФормаОтчета;
			Форма.ОписаниеНормативДок = Строка.ОписаниеОтчета;
		КонецЕсли;	

		Возврат;
		
	КонецЦикла;

	// Если не удалось найти форму, соответствующую выбранному периоду,
	// то по умолчанию выдаем текущую (действующую) форму.
	Если Форма.мВыбраннаяФорма = Неопределено Тогда
		Если ТаблицаФормОтчета.Количество() >= 1 Тогда
			Форма.мВыбраннаяФорма = ТаблицаФормОтчета[0].ФормаОтчета;
			Форма.ОписаниеНормативДок = ТаблицаФормОтчета[0].ОписаниеОтчета;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры



// Возвращает представление нуля из строки формата.
//
Функция ПолучитьПредставлениеНуляИзСтрокиФормата(Знач СтрокаФормата) Экспорт 
	
	Если ПустаяСтрока(СтрокаФормата) Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаФорматаТекст = СтрЗаменить(СтрокаФормата, ";", Символы.ПС);
	Для НомерСтроки = 1 По СтрЧислоСтрок(СтрокаФорматаТекст) Цикл
		ПодстрокаФормата = СтрПолучитьСтроку(СтрокаФорматаТекст, НомерСтроки);
		Если СтрНайти(ПодстрокаФормата, "ЧН=") > 0 Тогда
			Возврат СокрЛП(ПодстрокаФормата);
		КонецЕсли;
	КонецЦикла;
	
	Возврат "";
	
КонецФункции

// Заменяет представление нуля в строке формата.
//
Функция ЗаменитьПредставлениеНуляВСтрокеФормата(Знач СтрокаФормата, ПредставлениеНуля) Экспорт 
	
	НоваяСтрокаФормата = "";
	
	РазделительПодстрок = ";";
	СтрокаФорматаТекст = СтрЗаменить(СтрокаФормата, РазделительПодстрок, Символы.ПС);
	Для НомерСтроки = 1 По СтрЧислоСтрок(СтрокаФорматаТекст) Цикл
		ПодстрокаФормата = СокрЛП(СтрПолучитьСтроку(СтрокаФорматаТекст, НомерСтроки));
		Если ПустаяСтрока(ПодстрокаФормата) Тогда
			Продолжить;
		КонецЕсли;
		Если СтрНайти(ПодстрокаФормата, "ЧН=") > 0 Тогда
			ПодстрокаФормата = ПредставлениеНуля;
		КонецЕсли;
		НоваяСтрокаФормата = НоваяСтрокаФормата + ?(ПустаяСтрока(НоваяСтрокаФормата), "", РазделительПодстрок) + ПодстрокаФормата;
	КонецЦикла;
	
	Если ПустаяСтрока(НоваяСтрокаФормата) Тогда
		Возврат ПредставлениеНуля;
	КонецЕсли;

	Возврат НоваяСтрокаФормата;
	
КонецФункции

Функция ПолучитьУникальныйИдентификаторДокумента(ДокументСсылка) Экспорт
	Возврат СтрЗаменить(Строка(ДокументСсылка.УникальныйИдентификатор()), "-", "");
КонецФункции

// Собирает данные текущего табличного поля.
//
Функция СобратьДанныеТекущегоТаблПоля(Форма, ИмяТабличногоПоля) Экспорт 

	ТабличноеПоле = Форма[ИмяТабличногоПоля];

	СтруктураДанныхПоля = Новый Структура;

	Для Инд = 0 По ТабличноеПоле.Области.Количество() - 1 Цикл
		ТекущаяОбласть = ТабличноеПоле.Области[Инд];

		Если Не ТекущаяОбласть.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ(ТекущаяОбласть.СодержитЗначение) Тогда
			Продолжить;
		КонецЕсли;

		ИмяПоказателя      = ТекущаяОбласть.Имя;
		ЗначениеПоказателя = ТекущаяОбласть.Значение;

		СтруктураДанныхПоля.Вставить(ИмяПоказателя, ЗначениеПоказателя);
		
		// Сохраним формат отображения нуля для восстановления представления
		// в поле табличного документа и контроля выгрузки показателя в формате XML
		Если ТипЗнч(ЗначениеПоказателя) = Тип("Число") И ЗначениеПоказателя = 0 Тогда
			ФорматПредставленияНуля = ПолучитьПредставлениеНуляИзСтрокиФормата(ТекущаяОбласть.Формат);
			Если ЗначениеЗаполнено(ФорматПредставленияНуля) Тогда
				СтруктураДанныхПоля.Вставить("ЧН" + ИмяПоказателя, ФорматПредставленияНуля);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	СтруктураДанныхПоля.Вставить("ОргАдрес", Форма.СтруктураРеквизитовФормы.мАдресвФорматеДляВыгрузки);

	Возврат СтруктураДанныхПоля;

КонецФункции

// Заполняет показатели отчета.
//
Процедура ЗаполнитьПоказателиОтчета(Форма, ПоказателиОтчета) Экспорт 
	Префикс = "ПолеТабличногоДокумента";
	
	Для Каждого Группа Из Форма.Элементы.Страницы.ПодчиненныеЭлементы Цикл
		Для Каждого ЭлементГруппы Из Группа.ПодчиненныеЭлементы Цикл 
			Если СтрЧислоВхождений(ЭлементГруппы.Имя, Префикс) = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			ПоказателиОтчета.Вставить(ЭлементГруппы.Имя, СобратьДанныеТекущегоТаблПоля(Форма, ЭлементГруппы.Имя));
			
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

// Возвращает имя раздела текущей области.
//
Функция РазделТекущейОбласти(Форма, ТекущаяОбласть, ДлИмениОбласти = 13) Экспорт

	Если ТекущаяОбласть = Неопределено Тогда
		Возврат Неопределено; // отсутствует активная область табличного документа
	КонецЕсли;

	ИмяТекущейОбласти   = ТекущаяОбласть.Имя;
	ИмяАктивногоРаздела = Лев(ИмяТекущейОбласти, ДлИмениОбласти);
	
	Для Каждого ЭлементСтруктуры Из Форма.мСтруктураМногострочныхРазделов Цикл
		ИмяГруппы = ЭлементСтруктуры.Ключ;
		СтруктураГруппы = Форма[ЭлементСтруктуры.Значение];

		Если СтруктураГруппы[0].Свойство(ИмяАктивногоРаздела) Тогда
			Возврат ИмяГруппы;
		КонецЕсли;
	КонецЦикла;

	Возврат Неопределено;

КонецФункции

// Возвращает части даты, для формирования полей "День","Месяц","Год" в реготчетах.
//
Функция ПолучитьЧастиДатыДляПодписи(Дата, Язык="uk_UA") Экспорт
	
	Результат = Новый Структура("День,Месяц,МесяцЦифрой,Год,ПоследняяЦифраГода,ДвеПоследниеЦифрыГода");
	
	Результат.День = Формат(День(Дата),"ЧГ=0");
	
	ДатаСтрокой = Формат(Дата,"ДЛФ = 'ДД';Л = uk_UA");
	ПозицияПервогоПробела = Найти(ДатаСтрокой," ");
	ПозицияВторогоПробела = Найти(Сред(ДатаСтрокой,ПозицияПервогоПробела+1)," ");
	Результат.Месяц = Сред(ДатаСтрокой,ПозицияПервогоПробела+1,ПозицияВторогоПробела-1);
	Результат.МесяцЦифрой = Формат(Дата, "ДФ=ММ");
	Результат.Год = Формат(Год(Дата),"ЧГ=0");
	
	Результат.ПоследняяЦифраГода = Сред(Результат.Год,4,1);
	Результат.ДвеПоследниеЦифрыГода = Сред(Результат.Год,3,2);
	
	Возврат Результат;
	
КонецФункции

// Добавляет необходимое количество дополнительных строк.
//
Процедура ДобавитьНеобходимоеКоличествоДопСтрок(Форма, ТекТабличноеПоле, ТекТабличноеПолеИмя, ИсходноеКоличествоСтрокГруппы, ТекущееКоличествоСтрокГруппы, ИмяГруппы, СтруктураГруппы) Экспорт
	
	ИмяОбласти = Форма.СтруктураРеквизитовФормы.мСоответствияМнгЧ[ИмяГруппы];
	
	МногострочнаяЧастьВерх = ТекТабличноеПоле.Области[ИмяОбласти].Верх;
	МногострочнаяЧастьНиз = МногострочнаяЧастьВерх + ИсходноеКоличествоСтрокГруппы - 1;
	
	ОбластьДопСтроки = ТекТабличноеПоле.ПолучитьОбласть("R" + Формат(МногострочнаяЧастьНиз, "ЧГ="));
	
	ТекТабличноеПоле.ВставитьОбласть(ОбластьДопСтроки.Область(), ТекТабличноеПоле.Область(МногострочнаяЧастьВерх + ИсходноеКоличествоСтрокГруппы, , МногострочнаяЧастьВерх + ТекущееКоличествоСтрокГруппы - 1), ТипСмещенияТабличногоДокумента.ПоВертикали);
	
	Для НомСтроки = ИсходноеКоличествоСтрокГруппы По ТекущееКоличествоСтрокГруппы Цикл
		
		НомНовойСтроки = ТекущееКоличествоСтрокГруппы - НомСтроки + ИсходноеКоличествоСтрокГруппы;
		
		Для Каждого Область Из ОбластьДопСтроки.Области Цикл
			
			ОбластьТаблДок = ТекТабличноеПоле.Область(МногострочнаяЧастьВерх + НомНовойСтроки - 1, Область.Лево, МногострочнаяЧастьВерх + НомНовойСтроки - 1, Область.Право);
			
			Если ОбластьТаблДок.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник Тогда
				
				Если ОбластьТаблДок.СодержитЗначение Тогда
					ОбластьТаблДок.Очистить();
				КонецЕсли;
				
				ОбластьТаблДок.Имя = Лев(Область.Имя, НайтиПоследнееВхождение(Область.Имя, "_")) + Формат(НомНовойСтроки, "ЧГ=");
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	ТекТабличноеПоле.Область(ИмяОбласти).Имя = "";
	
	ТекТабличноеПоле.Область(МногострочнаяЧастьВерх, , МногострочнаяЧастьВерх).Имя = ИмяОбласти;
	
КонецПроцедуры

// Отрисовывает пиктограммы удаления строк.
//
Процедура ОтрисоватьЗначкиУдаленияСтрок(Форма, ДлинаИмениОбластейСДопСтроками = 26) Экспорт 
	
	ТабДок = Форма.ТабличныйДокумент;
	
	МассивОбластейСДопСтроками = Новый Массив;
	
	Для Каждого ОбластьТД Из ТабДок.Области Цикл
		Если СтрЧислоВхождений(ОбластьТД.Имя, "УдалитьСтроку") > 0 Тогда
			Если СтрЧислоВхождений(ОбластьТД.Имя, "_2") > 0 Тогда
				МассивОбластейСДопСтроками.Добавить(Лев(ОбластьТД.Имя, ДлинаИмениОбластейСДопСтроками));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ОбластьТД Из ТабДок.Области Цикл
		Если СтрЧислоВхождений(ОбластьТД.Имя, "УдалитьСтроку") > 0 Тогда
			Если МассивОбластейСДопСтроками.Найти(Лев(ОбластьТД.Имя, ДлинаИмениОбластейСДопСтроками)) = Неопределено Тогда
				ОбластьТД.Гиперссылка = Ложь;
				ОбластьТД.Текст = "";
			Иначе
				ОбластьТД.Гиперссылка = Истина;
				ОбластьТД.Текст = "х";
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Возвращает найденный уникальный идентификатор элемента дерева.
//
Функция НайтиИДВДереве(Дерево, UID, UID_Пустой) Экспорт 
	Для Каждого Элемент Из Дерево Цикл 
		Если Элемент.UID = UID Тогда
			Возврат Элемент.ПолучитьИдентификатор();
		КонецЕсли;
	
		НайденныйИД = НайтиИДВДереве(Элемент.ПолучитьЭлементы(), UID, UID_Пустой);
		Если НайденныйИД <> Неопределено Тогда
			Возврат НайденныйИД;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
КонецФункции

#Область ПроцедурыИФункцииРаботыСОтчетамиСтатистики

// Выводит сообщение пользователю.
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач ИдентификаторНазначения  = "") Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Если НЕ ПустаяСтрока(ИдентификаторНазначения) Тогда
		Сообщение.ИдентификаторНазначения  = ИдентификаторНазначения;
	КонецЕсли;
	Сообщение.Сообщить();

КонецПроцедуры

Функция ОкруглитьЧислоПоФормату(Владелец, ИсходноеЧисло) Экспорт
	
	Перем Делитель, Разрядность;
	
	Если ТипЗнч(Владелец) = Тип("Структура")
		И Владелец.Свойство("Разрядность", Разрядность) И Владелец.Свойство("Класс", Делитель) Тогда
		
		Возврат Окр(ИсходноеЧисло / Делитель, Разрядность) * Делитель;
		
	ИначеЕсли Владелец.СоответствиеЕдиницыИзмеренияДелителю.Свойство(
		"Окр" + СтрЗаменить(Владелец.СтруктураРеквизитовФормы.ЕдиницаИзмерения, " ", ""), Делитель) Тогда
		
		Возврат Окр(ИсходноеЧисло / Делитель, Владелец.СтруктураРеквизитовФормы.ТочностьЕдиницыИзмерения) * Делитель;
		
	КонецЕсли;
	
КонецФункции

// Округляет число по формату делителя.
//
Функция ОкруглитьЧислоПоФорматуДелителя(Форма, ИсходноеЧисло) Экспорт 
	
	ОкругленноеЧисло = Окр(ИсходноеЧисло / Форма.СтруктураРеквизитовФормы.мДелитель, Форма.СтруктураРеквизитовФормы.ТочностьЕдиницыИзмерения) * Форма.СтруктураРеквизитовФормы.мДелитель;
	Возврат ОкругленноеЧисло;
	
КонецФункции

// Возвращает свойства показателей.
//
Функция НайтиСвойстваПоказателя(Форма, КодПоказателя) Экспорт 
	
	СвойстваПоказателей = Форма.СвойстваПоказателей;
	СвойстваПоказателя = СвойстваПоказателей.НайтиСтроки(Новый Структура("Показатель", КодПоказателя));
		
	Если СвойстваПоказателя.Количество() = 0 Тогда
		
		СвойстваПоказателя = Неопределено;
		
		Для Каждого Стр Из СвойстваПоказателей Цикл
			Если Лев(КодПоказателя, СтрДлина(Стр.Показатель)) = Стр.Показатель Тогда
				СвойстваПоказателя = Стр;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		
		СвойстваПоказателя = СвойстваПоказателя[0];
		
	КонецЕсли;
		
	Возврат СвойстваПоказателя;
	
КонецФункции

#КонецОбласти

// Сравнивает краткие версии отчетов.
//
Функция СравнитьКраткиеВерсииОтчетов(Версия1, Версия2) Экспорт
	
	// раскладываем версию 1 и преобразуем составляющие к числам
	ЧастиВерсии1 = РегламентированнаяОтчетностьКлиентСервер.РазобратьСтрокуВМассивПоРазделителю(Версия1, ".");
	ЧислоСоставляющихВерсии1 = ЧастиВерсии1.Количество();
	Для Инд = 0 По ЧислоСоставляющихВерсии1 - 1 Цикл
		ЧастьВерсии1 = ЧастиВерсии1[Инд];
		Если НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастьВерсии1) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ЧастиВерсии1[Инд] = Число(ЧастьВерсии1);
	КонецЦикла;
	
	// раскладываем версию 2 и преобразуем составляющие к числам
	ЧастиВерсии2 = РегламентированнаяОтчетностьКлиентСервер.РазобратьСтрокуВМассивПоРазделителю(Версия2, ".");
	ЧислоСоставляющихВерсии2 = ЧастиВерсии1.Количество();
	Для Инд = 0 По ЧислоСоставляющихВерсии2 - 1 Цикл
		ЧастьВерсии2 = ЧастиВерсии2[Инд];
		Если НЕ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЧастьВерсии2) Тогда
			Возврат Неопределено;
		КонецЕсли;
		ЧастиВерсии2[Инд] = Число(ЧастьВерсии2);
	КонецЦикла;
	
	// дополняем массив составляющих нулями, уравнивая число составляющих первой и второй версий
	Если ЧислоСоставляющихВерсии1 > ЧислоСоставляющихВерсии2 Тогда
		Для Инд = ЧислоСоставляющихВерсии2 + 1 По ЧислоСоставляющихВерсии1 Цикл
			ЧастиВерсии2.Добавить(0);
		КонецЦикла;
	ИначеЕсли ЧислоСоставляющихВерсии2 > ЧислоСоставляющихВерсии1 Тогда
		Для Инд = ЧислоСоставляющихВерсии1 + 1 По ЧислоСоставляющихВерсии2 Цикл
			ЧастиВерсии1.Добавить(0);
		КонецЦикла;
	КонецЕсли;
	
	// сравниваем по каждому составляющему
	Для Инд = 0 По ЧислоСоставляющихВерсии1 - 1 Цикл
		ЧастьВерсии1 = ЧастиВерсии1[Инд];
		ЧастьВерсии2 = ЧастиВерсии2[Инд];
		Если ЧастьВерсии1 > ЧастьВерсии2 Тогда
			Возврат -1;
		ИначеЕсли ЧастьВерсии1 < ЧастьВерсии2 Тогда
			Возврат 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции

// Процедура выделяет в табличном документе области с незаполненными показателями
// и снимает выделение областей с заполненными показателями. Предназначена для
// областей, содержащих значения показателей, ввод которых осуществляется вручную.
//
// Параметры:
//   ТаблДок                     - ТабличныйДокумент - табличный документ;
//   ПараметрыВыделяемыхОбластей - Массив - массив структур с ключами:
//     "ИмяОбласти"                               - Строка - имя области табл. документа;
//     "ГраницаСверхуАвто"       (необязательный) - Линия - линия верхней границы (по умолчанию);
//     "ГраницаСнизуАвто"        (необязательный) - Линия - линия нижней границы (по умолчанию);
//     "ГраницаСлеваАвто"        (необязательный) - Линия - линия левой границы (по умолчанию);
//     "ГраницаСправаАвто"       (необязательный) - Линия - линия правой границы (по умолчанию);
//     "ЦветАвто"                (необязательный) - Цвет  - цвет рамки (по умолчанию);
//     "ГраницаСверхуВыделенная" (необязательный) - Линия - линия выделенной верхней границы;
//     "ГраницаСнизуВыделенная"  (необязательный) - Линия - линия выделенной нижней границы;
//     "ГраницаСлеваВыделенная"  (необязательный) - Линия - линия выделенной левой границы;
//     "ГраницаСправаВыделенная" (необязательный) - Линия - линия выделенной правой границы;
//     "ЦветВыделения"           (необязательный) - Цвет  - цвет выделенной рамки;
//
Процедура ИзменитьРамкиОбластейТабличногоДокумента(ТаблДок, ПараметрыВыделяемыхОбластей) Экспорт
	
	ПараметрыИзменения = Новый Структура;
	
	Для каждого ПараметрыОбласти Из ПараметрыВыделяемыхОбластей Цикл
		
		ИмяОбл = ПараметрыОбласти.ИмяОбласти;
		
		Если Лев(ИмяОбл, 2) = "П0"
			И СтрДлина(ИмяОбл) > 14
			И Сред(ИмяОбл, 14, 1) = "_" Тогда
			
			ИмяБезПостфикса = Лев(ИмяОбл, 13);
			
			Инд = 1;
			Постфикс = "_1";
			Обл = ТаблДок.Области.Найти(ИмяБезПостфикса + Постфикс);
			
			Пока Обл <> Неопределено Цикл
				
				ПараметрыОбласти.Вставить("Область", Обл);
				
				ИзменитьРамкуОбластиТабличногоДокумента(ПараметрыОбласти);
				
				Инд = Инд + 1;
				Постфикс = "_" + Формат(Инд, "ЧГ=");
				Обл = ТаблДок.Области.Найти(ИмяБезПостфикса + Постфикс);
				
			КонецЦикла;
			
		Иначе
			
			Обл = ТаблДок.Области.Найти(ИмяОбл);
			
			Если Обл <> Неопределено Тогда
				
				ПараметрыОбласти.Вставить("Область", Обл);
				
				ИзменитьРамкуОбластиТабличногоДокумента(ПараметрыОбласти);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура выделяет в табличном документе область с заполненным показателем
// и снимает выделение области с заполненным показателем. Предназначена для
// области, содержащей значение показателя, ввод которого осуществляется вручную.
//
// Параметр:
//   ПараметрыИзменения - Структура - ключи:
//     "Область" - ОбластьЯчеекТабличногоДокумента - область, выделение которой изменяется;
//     "ГраницаСверхуАвто"       (необязательный) - Линия - линия верхней границы (по умолчанию);
//     "ГраницаСнизуАвто"        (необязательный) - Линия - линия нижней границы (по умолчанию);
//     "ГраницаСлеваАвто"        (необязательный) - Линия - линия левой границы (по умолчанию);
//     "ГраницаСправаАвто"       (необязательный) - Линия - линия правой границы (по умолчанию);
//     "ЦветАвто"                (необязательный) - Цвет  - цвет рамки (по умолчанию);
//     "ГраницаСверхуВыделенная" (необязательный) - Линия - линия выделенной верхней границы;
//     "ГраницаСнизуВыделенная"  (необязательный) - Линия - линия выделенной нижней границы;
//     "ГраницаСлеваВыделенная"  (необязательный) - Линия - линия выделенной левой границы;
//     "ГраницаСправаВыделенная" (необязательный) - Линия - линия выделенной правой границы;
//     "ЦветВыделения"           (необязательный) - Цвет  - цвет выделенной рамки;
//
Процедура ИзменитьРамкуОбластиТабличногоДокумента(ПараметрыИзменения) Экспорт
	
	Обл = ПараметрыИзменения.Область;
	
	Если НЕ ЗначениеЗаполнено(Обл.Значение)
		И (Обл.ЦветФона = Новый Цвет(255, 255, 192) ИЛИ Обл.ЦветФона = Новый Цвет(230, 240, 220)) Тогда
		
		ТочечнаяЛиния = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Точечная);
		
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСверхуВыделенная") Тогда
			ПараметрыИзменения.Вставить("ГраницаСверхуВыделенная", ТочечнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСнизуВыделенная") Тогда
			ПараметрыИзменения.Вставить("ГраницаСнизуВыделенная", ТочечнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСлеваВыделенная") Тогда
			ПараметрыИзменения.Вставить("ГраницаСлеваВыделенная", ТочечнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСправаВыделенная") Тогда
			ПараметрыИзменения.Вставить("ГраницаСправаВыделенная", ТочечнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ЦветВыделения") Тогда
			ПараметрыИзменения.Вставить("ЦветВыделения", Новый Цвет(255, 0, 0));
		КонецЕсли;
		
		Обл.ГраницаСверху = ПараметрыИзменения.ГраницаСверхуВыделенная;
		Обл.ГраницаСнизу  = ПараметрыИзменения.ГраницаСнизуВыделенная;
		Обл.ГраницаСлева  = ПараметрыИзменения.ГраницаСлеваВыделенная;
		Обл.ГраницаСправа = ПараметрыИзменения.ГраницаСправаВыделенная;
		Обл.ЦветРамки = ПараметрыИзменения.ЦветВыделения;
		
	Иначе
		
		СплошнаяЛиния = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная);
		
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСверхуАвто") Тогда
			ПараметрыИзменения.Вставить("ГраницаСверхуАвто", СплошнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСнизуАвто") Тогда
			ПараметрыИзменения.Вставить("ГраницаСнизуАвто", СплошнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСлеваАвто") Тогда
			ПараметрыИзменения.Вставить("ГраницаСлеваАвто", СплошнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ГраницаСправаАвто") Тогда
			ПараметрыИзменения.Вставить("ГраницаСправаАвто", СплошнаяЛиния);
		КонецЕсли;
		Если НЕ ПараметрыИзменения.Свойство("ЦветАвто") Тогда
			ПараметрыИзменения.Вставить("ЦветАвто", Новый Цвет(0, 0, 0));
		КонецЕсли;
		
		Обл.ГраницаСверху = ПараметрыИзменения.ГраницаСверхуАвто;
		Обл.ГраницаСнизу  = ПараметрыИзменения.ГраницаСнизуАвто;
		Обл.ГраницаСлева  = ПараметрыИзменения.ГраницаСлеваАвто;
		Обл.ГраницаСправа = ПараметрыИзменения.ГраницаСправаАвто;
		Обл.ЦветРамки = ПараметрыИзменения.ЦветАвто;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция МногострочнаяЧастьТекущейОбласти(СтруктураРеквизитовФормы, Знач ИмяОбласти) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ИмяОбласти) Тогда
		Возврат Неопределено;
	Иначе
		НомПозПодчеркивания = СтруктураРеквизитовФормы.ДлинаИмениГрафы + 1;
		Если НЕ (СтрДлина(ИмяОбласти) > НомПозПодчеркивания
			И Сред(ИмяОбласти, НомПозПодчеркивания, 1) = "_") Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	ИмяОбласти = СтрЗаменить(ИмяОбласти, "ДобавитьСтрокуЗначок", "");
	ИмяОбласти = СтрЗаменить(ИмяОбласти, "ДобавитьСтроку", "");
	ИмяОбласти = СтрЗаменить(ИмяОбласти, "УдалитьСтроку", "");
	
	ИмяГруппы = Лев(ИмяОбласти, СтруктураРеквизитовФормы.ДлинаИмениГруппы);
	
	Для каждого ЭлемСтруктуры Из СтруктураРеквизитовФормы.СтруктураМногострочныхЧастей Цикл
		Если ЭлемСтруктуры.Ключ = ИмяГруппы Тогда
			Возврат ИмяГруппы;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

Функция ИндексПоказателя(Знач ИмяОбласти) Экспорт
	
	МассивСтрок = СтрРазделить(ИмяОбласти, "_");
	
	КолСтрок = МассивСтрок.Количество();
	
	Если КолСтрок = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексСтрока = МассивСтрок[КолСтрок - 1];
	Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ИндексСтрока) Тогда
		Возврат Число(ИндексСтрока);
	КонецЕсли;
	
КонецФункции

Функция СтрокаСКоординатамиПоказателя(Знач Координаты) Экспорт
	
	СтрокаСКоординатами = "";
	
	Если ТипЗнч(Координаты) = Тип("Массив") Тогда
		Для каждого КоординатаЧисло Из Координаты Цикл
			Если ТипЗнч(КоординатаЧисло) <> Тип("Число") Тогда
				Возврат Неопределено;
			КонецЕсли;
			СтрокаСКоординатами = СтрокаСКоординатами + "_" + Формат(КоординатаЧисло, "ЧГ=");
		КонецЦикла;
	ИначеЕсли ТипЗнч(Координаты) = Тип("Строка") Тогда
		МассивСтрок = СтрРазделить(Координаты, "_");
		КолСтрок = МассивСтрок.Количество();
		Если КолСтрок = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		МассивСтрок.Удалить(КолСтрок - 1);
		МассивСтрок.Удалить(0);
		Для каждого КоординатаСтрока Из МассивСтрок Цикл
			Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(КоординатаСтрока) Тогда
				СтрокаСКоординатами = СтрокаСКоординатами + "_" + Формат(КоординатаСтрока, "ЧГ=");
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЦикла;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СтрокаСКоординатами;
	
КонецФункции

Функция СтрокаСИндексомПоказателя(Знач Индекс) Экспорт
	
	Если ТипЗнч(Индекс) <> Тип("Число") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат "_" + Формат(Индекс, "ЧГ=");
	
КонецФункции

Функция УдалосьПроставитьНомерСтраницы(ТаблДок,Знач НомерЛиста)
	
	ОбластиСНомерамиЛистов = Новый СписокЗначений;
	Для Каждого Обл Из ТаблДок.Значение.Области Цикл
		Если (НЕ ТипЗнч(Обл) = Тип("РисунокТабличногоДокумента") И Обл.ТипОбласти <> ТипОбластиЯчеекТабличногоДокумента.Прямоугольник) ИЛИ Обл.СодержитЗначение <> Истина Тогда
			Продолжить;
		КонецЕсли;
		КрайнийПравыйСимвол = Прав(Обл.Имя, 1);
		Если Лев(ВРЕГ(Обл.Имя), 6) = "НОМСТР" И (КодСимвола(КрайнийПравыйСимвол) >= КодСимвола("0") И КодСимвола(КрайнийПравыйСимвол) <= КодСимвола("9"))Тогда
			ОбластиСНомерамиЛистов.Добавить(Обл, Обл.Имя);
		КонецЕсли;
		ОбластиСНомерамиЛистов.СортироватьПоПредставлению(НаправлениеСортировки.Убыв);
	КонецЦикла;
	
	Цифры = Новый Массив;
	Для Инд = 1 По 9 Цикл
		Цифра = Формат(НомерЛиста % 10, "ЧЦ=1; ЧН=0; ЧГ=");
		НомерЛиста = Цел(НомерЛиста / 10);
		Если ПустаяСтрока(Цифра) Тогда
			Прервать;
		Иначе
			Цифры.Добавить(Цифра);
		КонецЕсли;
	КонецЦикла;
	
	Для Инд = 0 По ОбластиСНомерамиЛистов.Количество() - 1 Цикл
		ОбластиСНомерамиЛистов.Получить(Инд).Значение.Значение = Формат(?(Цифры.Количество() > Инд, Цифры[Инд], 0), "ЧЦ=1; ЧН=0; ЧГ=");
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Процедура УдалитьСлужебныеСимоволыИзПечатнойФормы(СписокПечатаемыхЛистов)
	
	ПустаяЛиния = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии);
	Для Каждого Лист Из СписокПечатаемыхЛистов Цикл 
		ТабДок = ПолучитьИзВременногоХранилища(Лист.Значение[0]);
		Для Каждого Обл Из ТабДок.Области Цикл 
			Если СтрНайти(Обл.Имя, "УдалитьСтроку") = 1 И Не Обл.СодержитЗначение Тогда 
				Обл.Текст = "";
			КонецЕсли;
			Если СтрНайти(Обл.Имя, "ДобавитьСтроку") = 1 И Не Обл.СодержитЗначение Тогда 
				Обл.Текст = "";
				УстановитьГраницуОбласти(Обл, ПустаяЛиния);
				Попытка
					Если Обл.Верх = Обл.Низ И Обл.Лево = Обл.Право Тогда 
						УстановитьГраницуОбласти(ТабДок.Область(Обл.Верх, Обл.Лево+1,Обл.Верх, Обл.Лево+1), ПустаяЛиния);
					КонецЕсли;
				Исключение
				КонецПопытки;
		КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьГраницуОбласти(Обл, Граница)
	
	Обл.ГраницаСлева = Граница;
	Обл.ГраницаСправа = Граница;
	Обл.ГраницаСверху = Граница;
	Обл.ГраницаСнизу = Граница;
	
КонецПроцедуры

Функция ПолучитьКоличествоСтраницРаздела(Форма, ИмяТекущейСтраницыПанели)
	
	Перем ТаблицаСтраницРаздела;
		
	Если НЕ Форма.мСтруктураМногостраничныхРазделов.Свойство(ИмяТекущейСтраницыПанели, ТаблицаСтраницРаздела) Тогда
		Возврат 1;
	КонецЕсли;

	ТаблицаСтраницРаздела = Форма[ТаблицаСтраницРаздела];
	
	КоличествоСтраниц = Макс(ТаблицаСтраницРаздела.Количество(), 1);
	
	Возврат КоличествоСтраниц;
	
КонецФункции

Процедура ОпределитьПредставлениеДопСтраниц(Форма, ИмяСтраницы = Неопределено, ТолькоУАктивнойСтраницы = Неопределено)
	Перем ТаблицаСтраницРаздела;
	Перем ТекущееПредставлениеСтраницы;

	ТолькоАктивная = ?(ТолькоУАктивнойСтраницы = Неопределено, Ложь, ТолькоУАктивнойСтраницы);
	
	Для Каждого Страница Из Форма.мСтруктураМногостраничныхРазделов Цикл
		ИмяТекСтраницы        = Страница.Ключ;
		ТаблицаСтраницРаздела = Форма[Страница.Значение];

		Если ИмяСтраницы <> Неопределено Тогда
			Если ИмяТекСтраницы <> ИмяСтраницы Тогда
				Продолжить; // Пропускаем не нужные страницы
			КонецЕсли;
		КонецЕсли;

		// Если есть хоть одна страница - определим ее представление
		Если ТаблицаСтраницРаздела.Количество() > 0 Тогда

			НомерСтраницы = 0;

			Для Каждого СтрокаТаблицы Из ТаблицаСтраницРаздела Цикл

				НомерСтраницы = НомерСтраницы + 1;

				СохрПредставлениеСтраницы = СтрокаТаблицы.Представление;

				// Если колонки нет, тогда автоматическое представление включено по умолчанию.
				Если ТаблицаСтраницРаздела[0].Свойство("АвтоматическоеПредставление") Тогда
					АвтоматическоеПредставление = СтрокаТаблицы.АвтоматическоеПредставление;
				Иначе
					АвтоматическоеПредставление = Истина;
				КонецЕсли;

				Если НЕ АвтоматическоеПредставление Тогда
					Продолжить;
				КонецЕсли;

				// Определяем представление дополнительной страницы
				СтруктураДанныхСтраницы = СтрокаТаблицы.Данные[0].Значение;

				ИмяПредставления = ПолучитьСвойствоРаздела(Форма, ИмяТекСтраницы, "ИмяПредставления");

				Если НЕ ЗначениеЗаполнено(ИмяПредставления) Тогда
					ТекущееПредставлениеСтраницы = Неопределено;
				Иначе
					СтруктураДанныхСтраницы.Свойство(ИмяПредставления, ТекущееПредставлениеСтраницы);
				КонецЕсли;

				Если (НЕ ТолькоАктивная) Или ((ТолькоАктивная) И (СтрокаТаблицы.АктивнаяСтраница))Тогда

					ТекущееПредставлениеСтраницы = ?(НЕ ЗначениеЗаполнено(ТекущееПредставлениеСтраницы), 
													НСтр("ru='Лист №';uk='Аркуш №'") + Строка(НомерСтраницы), 
													ТекущееПредставлениеСтраницы + НСтр("ru='. Лист №';uk='. Аркуш №'") + Строка(НомерСтраницы));
					Если Не ПустаяСтрока(ТекущееПредставлениеСтраницы) Тогда
						СтрокаТаблицы.Представление = ТекущееПредставлениеСтраницы;
					Иначе
						СтрокаТаблицы.Представление = НСтр("ru='Новая страница';uk='Нова сторінка'");
					КонецЕсли;

				КонецЕсли;

			КонецЦикла;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

Процедура УстановитьИндекс(ИндексЧисло, ИндексСтрока, ЗначениеПоУмолчанию = 1) Экспорт
	
	ИндексЧисло = ЗначениеПоУмолчанию;
	ИндексСтрока = Формат(ИндексЧисло, "ЧГ=");
	
КонецПроцедуры

Процедура УвеличитьИндекс(ИндексЧисло, ИндексСтрока, Шаг = 1) Экспорт
	
	ИндексЧисло = ИндексЧисло + Шаг;
	ИндексСтрока = Формат(ИндексЧисло, "ЧГ=");
	
КонецПроцедуры

Функция ИмяОтчета(ЭтаФормаИмя) Экспорт 
	Форма_Имя = СтрЗаменить(ЭтаФормаИмя, "Внешний", "");
	Возврат Сред(Лев(Форма_Имя, СтрНайти(Форма_Имя, ".Форма.") - 1), 7);
КонецФункции

Функция ИмяФормыОтчета(ЭтаФормаИмя) Экспорт 
	Возврат Сред(ЭтаФормаИмя, СтрНайти(ЭтаФормаИмя, ".Форма.") + 7);
КонецФункции


Функция ПолучитьКодЯзыкаИнтерфейса() Экспорт
	
	Возврат РегламентированнаяОтчетностьВызовСервера.ПолучитьКодЯзыкаИнтерфейса();
		
КонецФункции

Функция ПолучитьНомерНаПечать(НомерОбъекта, УдалитьПрефиксИнформационнойБазы = Ложь, УдалитьПользовательскийПрефикс = Ложь) Экспорт
	
	Возврат РегламентированнаяОтчетностьВызовСервера.ПолучитьНомерНаПечать(НомерОбъекта, УдалитьПрефиксИнформационнойБазы, УдалитьПользовательскийПрефикс);
		
КонецФункции

Функция НайтиПоследнееВхождение(ГдеИскать, ЧтоИскать) Экспорт
	
	ДлинаСтроки = СтрДлина(ГдеИскать);
	ДлинаИскомого = СтрДлина(ЧтоИскать);
	
	Результат = 0;
	Если ДлинаИскомого = 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Для ж = 0 По ДлинаСтроки - ДлинаИскомого Цикл
		
		Позиция = ДлинаСтроки - ДлинаИскомого + 1 - ж;
		Если Сред(ГдеИскать, Позиция, ДлинаИскомого) = ЧтоИскать Тогда
			Результат = Позиция;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции
#КонецОбласти
