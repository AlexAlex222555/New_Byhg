////////////////////////////////////////////////////////////////////////////////
// ЭлектронноеВзаимодействиеСлужебный: общий механизм обмена электронными документами.
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

#Область КомандыЭДО

// Размещает команды ЭДО на форме.
//
// Параметры:
//   Форма                            - ФормаКлиентскогоПриложения - форма, в которой необходимо разместить подменю ЭДО.
//   МестоРазмещенияКомандПоУмолчанию - ЭлементФормы - группа, в которую необходимо разместить подменю ЭДО,
//                                                     по умолчанию размещается в командную панель формы.
//   МодульПодсистемы - Строка - название модуля, в котором расположен обработчик команды;
//   НаправлениеЭД - ПеречислениеСсылка.НаправленияЭД - направление документа информационной базы;
//   ТолькоВМенюЕще - Булево - Если Истина, то команда будет размещена только в меню Еще.
//
Процедура РазместитьНаФормеКомандыЭДО(Форма, МестоРазмещенияКомандПоУмолчанию, МодульПодсистемы, НаправлениеЭД = Неопределено, ТолькоВМенюЕще = Ложь) Экспорт
	
	ИмяФормы = Форма.ИмяФормы;
	
	КомандыЭДО = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.КомандыЭДОФормы(ИмяФормы, МодульПодсистемы, НаправлениеЭД, ТолькоВМенюЕще).Скопировать();
	ОпределитьВидимостьКомандЭДОПоФункциональнымОпциям(КомандыЭДО, Форма);
	
	Если МестоРазмещенияКомандПоУмолчанию <> Неопределено Тогда
		Для Каждого КомандаЭДО Из КомандыЭДО Цикл
			Если ПустаяСтрока(КомандаЭДО.МестоРазмещения) Тогда
				КомандаЭДО.МестоРазмещения = МестоРазмещенияКомандПоУмолчанию.Имя;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	КомандыЭДО.Колонки.Добавить("ИмяКомандыНаФорме", Новый ОписаниеТипов("Строка"));
	
	ТаблицаКоманд = КомандыЭДО.Скопировать(,"МестоРазмещения");
	ТаблицаКоманд.Свернуть("МестоРазмещения");
	МестаРазмещения = ТаблицаКоманд.ВыгрузитьКолонку("МестоРазмещения");
	
	Если МестоРазмещенияКомандПоУмолчанию = Неопределено Тогда
		МестоРазмещенияКоманд = Форма.КоманднаяПанель;
		ПодменюЭДО = Форма.Элементы.Добавить(МестоРазмещенияКоманд.Имя + "КомандыЭДО", Тип("ГруппаФормы"), МестоРазмещенияКоманд);
		ПодменюЭДО.Вид = ВидГруппыФормы.Подменю;
		ПодменюЭДО.Заголовок = НСтр("ru='ЭДО';uk='ЕДО'");
		МестоРазмещенияКомандПоУмолчанию = ПодменюЭДО;
	КонецЕсли;
	
	Если МодульПодсистемы = "ОбменСКонтрагентами" Тогда
		КартинкаОповещений = БиблиотекаКартинок["ЭмблемаСервиса1СЭДО"];
		МодульОбменСКонтрагентами = ОбщегоНазначения.ОбщийМодуль("ОбменСКонтрагентамиСлужебныйВызовСервера");
		Если МодульОбменСКонтрагентами.ЕстьСобытияЭДО() Тогда
			КартинкаОповещений = БиблиотекаКартинок["ВосклицательныйЗнакКрасный"];
		КонецЕсли;
		МестоРазмещенияКомандПоУмолчанию.Картинка = КартинкаОповещений;
	КонецЕсли;
	
	Для Каждого МестоРазмещения Из МестаРазмещения Цикл
		НайденныеКоманды = КомандыЭДО.НайтиСтроки(Новый Структура("МестоРазмещения,СкрытаФункциональнымиОпциями,Отключена", МестоРазмещения, Ложь, Ложь));
		ЭлементФормыДляРазмещения = Форма.Элементы.Найти(МестоРазмещения);
		Если ЭлементФормыДляРазмещения = Неопределено Тогда
			ЭлементФормыДляРазмещения = МестоРазмещенияКомандПоУмолчанию;
		КонецЕсли;
		
		Если НайденныеКоманды.Количество() > 0 Тогда
			ДобавитьКомандыЭДО(Форма, НайденныеКоманды, ЭлементФормыДляРазмещения);
		КонецЕсли;
	КонецЦикла;
	
	АдресКомандЭДОВоВременномХранилище = "АдресКомандЭДОВоВременномХранилище";
	КомандаФормы = Форма.Команды.Найти(АдресКомандЭДОВоВременномХранилище);
	Если КомандаФормы = Неопределено Тогда
		КомандаФормы = Форма.Команды.Добавить(АдресКомандЭДОВоВременномХранилище);
		КомандаФормы.Действие = ПоместитьВоВременноеХранилище(КомандыЭДО, Форма.УникальныйИдентификатор);
	Иначе
		ОбщийСписокКомандЭДОФормы = ПолучитьИзВременногоХранилища(КомандаФормы.Действие);
		Для Каждого КомандаЭДО Из КомандыЭДО Цикл
			ЗаполнитьЗначенияСвойств(ОбщийСписокКомандЭДОФормы.Добавить(), КомандаЭДО);
		КонецЦикла;
		КомандаФормы.Действие = ПоместитьВоВременноеХранилище(ОбщийСписокКомандЭДОФормы, Форма.УникальныйИдентификатор);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает список команд ЭДО для указанной формы.
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения, Строка - форма или полное имя формы, для которой необходимо получить список команд ЭДО;
//  МодульПодсистемы - Строка - модуль, в котором размещены обработчики команд;
//  НаправлениеЭД - ПеречислениеСсылка.НаправленияЭД - направление документа, для которого выполняется команда;
//  ТолькоВМенюЕще - Булево - если Истина, то команда будет размещена только в меню Еще.
//
// Возвращаемое значение:
//  ТаблицаЗначений - описание см. в СоздатьКоллекциюКомандЭДО().
//
Функция КомандыЭДОФормы(Форма, МодульПодсистемы, НаправлениеЭД, ТолькоВМенюЕще) Экспорт
	
	Если ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
		ИмяФормы = Форма.ИмяФормы;
	Иначе
		ИмяФормы = Форма;
	КонецЕсли;
	
	КомандыЭДО = СоздатьКоллекциюКомандЭДО();
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяФормы);
	Если ОбъектМетаданных <> Неопределено 
		И Не Метаданные.ОбщиеФормы.Содержит(ОбъектМетаданных) Тогда
		ОбъектМетаданных = ОбъектМетаданных.Родитель();
	КонецЕсли;
	
	ДобавляемыеКомандыЭДО = СоздатьКоллекциюКомандЭДО();
	МодульФормирования = ОбщегоНазначения.ОбщийМодуль(МодульПодсистемы);
	МодульФормирования.СформироватьКомандыЭДО(ОбъектМетаданных.ПолноеИмя(), ДобавляемыеКомандыЭДО, НаправлениеЭД, ТолькоВМенюЕще);
	
	Для Каждого КомандаЭДО Из ДобавляемыеКомандыЭДО Цикл
		Если КомандыЭДО.Найти(КомандаЭДО.Идентификатор, "Идентификатор") = Неопределено Тогда
			ЗаполнитьЗначенияСвойств(КомандыЭДО.Добавить(), КомандаЭДО);	
		КонецЕсли;
	КонецЦикла;
	
	КомандыЭДО.Сортировать("Порядок Возр, Представление Возр");
	
	ЧастиИмени = СтрРазделить(ИмяФормы, ".");
	КраткоеИмяФормы = ЧастиИмени[ЧастиИмени.Количество()-1];
	
	// фильтр по именам форм
	Для НомерСтроки = -КомандыЭДО.Количество() + 1 По 0 Цикл
		КомандаЭДО = КомандыЭДО[-НомерСтроки];
		СписокФорм = СтрРазделить(КомандаЭДО.СписокФорм, ",", Ложь);
		Если СписокФорм.Количество() > 0 И СписокФорм.Найти(КраткоеИмяФормы) = Неопределено Тогда
			КомандыЭДО.Удалить(КомандаЭДО);
		КонецЕсли;
	КонецЦикла;
	
	ОпределитьВидимостьКомандЭДОПоФункциональнымОпциям(КомандыЭДО, Форма);
	
	Возврат КомандыЭДО;
	
КонецФункции

#КонецОбласти

#Область Организации

// Возвращает организацию по умолчанию.
// 
// Возвращаемое значение:
//  Неопределено - не удалось определить организацию.
//  ОпределяемыеТипы.Организация - организация для автоматической подстановки.
//
Функция ОрганизацияПоУмолчанию() Экспорт
	
	Если Не Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(Тип("Строка")) Тогда
		ПолноеИмя = Метаданные.НайтиПоТипу(Метаданные.ОпределяемыеТипы.Организация.Тип.Типы()[0]).ПолноеИмя();
		ИмяСправочникаОрганизации = "Справочники." + СтрРазделить(ПолноеИмя, ".")[1];
		МодульОрганизации = ОбщегоНазначения.ОбщийМодуль(ИмяСправочникаОрганизации);
		ОрганизацияПоУмолчанию = МодульОрганизации.ОрганизацияПоУмолчанию();
	Иначе
		ОрганизацияПоУмолчанию = Неопределено;
	КонецЕсли;
	
	Возврат ОрганизацияПоУмолчанию;
	
КонецФункции

// Получает сокращенное наименование организации.
//
// Параметры:
//  Организация - СправочникСсылка.Организации - ссылка на организацию.
//
// Возвращаемое значение:
//  Строка - сокращенное наименование организации.
//
Функция СокращенноеНаименованиеОрганизации(Организация) Экспорт
	
	РеквизитНаименованиеОрганизации = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ИмяНаличиеОбъектаРеквизитаВПрикладномРешении(
		"СокращенноеНаименованиеОрганизации");
	Если НЕ ЗначениеЗаполнено(РеквизитНаименованиеОрганизации) Тогда
		РеквизитНаименованиеОрганизации = "Наименование";
	КонецЕсли;
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, РеквизитНаименованиеОрганизации);
	
КонецФункции

// Возвращает признак использования нескольких организаций.
//
// Возвращаемое значение:
//  Булево - Истина, если используется несколько организаций, иначе Ложь.
//
Функция ИспользуетсяНесколькоОрганизаций() Экспорт
	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийБЭД");
	
КонецФункции

#КонецОбласти

#Область События

// Данная процедура используется для стандартизации всех записей событий подсистемы ЭлектронноеВзаимодействие
// в журнал регистрации. В результате в журнал добавляется группировка записей с иерархией.
//  Электронное взаимодействие:
//    |_ Общая подсистема
//    |_ Обмен с банками
//    |_ Обмен с контрагентами
//    |_ Обмен с сайтами
//    |_ Регламентные задания
//    |_ Бизнес-сеть
// Параметры:
//   ОписаниеСобытия - Строка - описание содержания события, которое требуется записать в журнал регистрации.
//   КодСобытия - Строка - код события, используется для стандартизации иерархии событий.
//   УровеньВажности - УровеньЖурналаРегистрации - уровень журнала регистрации (Ошибка, Информация, и т.д.).
//   ОбъектМетаданных - ОбъектМетаданных - объект метаданных, к которому относится событие.
//   ДанныеСсылка - Произвольный - данные, с которыми связано событие. Рекомендуется указывать ссылки на объекты данных
//                  (элементы справочников, документы, к которым относится событие).
//   РежимТранзакции - РежимТранзакцииЗаписиЖурналаРегистрации - указывает отношение записи к текущей транзакции.
//
Процедура ВыполнитьЗаписьСобытияПоЭДВЖурналРегистрации(ОписаниеСобытия, КодСобытия, УровеньВажности = Неопределено,
	ОбъектМетаданных = Неопределено, ДанныеСсылка = Неопределено, РежимТранзакции = Неопределено) Экспорт
	
	Если КодСобытия = "ЭлектронноеВзаимодействие" Тогда
		Подсистема = НСтр("ru='Общая подсистема';uk='Загальна підсистема'",ОбщегоНазначения.КодОсновногоЯзыка());
	Иначе
		Подсистема = НСтр("ru='Общая подсистема';uk='Загальна підсистема'",ОбщегоНазначения.КодОсновногоЯзыка());
	КонецЕсли;
	
	УровеньВажностиСобытия = ?(ТипЗнч(УровеньВажности) = Тип("УровеньЖурналаРегистрации"),
		УровеньВажности, УровеньЖурналаРегистрации.Ошибка);
		
	ИмяСобытия = СтрЗаменить(НСтр("ru='Электронное взаимодействие.%1';uk='Електронне взаємодія.%1'",ОбщегоНазначения.КодОсновногоЯзыка()),
		"%1", Подсистема);
	
	ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньВажностиСобытия, ОбъектМетаданных, ДанныеСсылка, ОписаниеСобытия,
		РежимТранзакции);
	
КонецПроцедуры

// Выводит сообщение пользователю о нехватки прав доступа.
Процедура СообщитьПользователюОНарушенииПравДоступа() Экспорт
	
	ТекстСообщения = ТекстСообщенияОНарушенииПравДоступа();
	ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	
КонецПроцедуры

Функция ТекстСообщенияОНарушенииПравДоступа() Экспорт
	
	ТекстСообщения = НСтр("ru='Нарушение прав доступа.';uk='Порушення прав доступу.'");
	ЭлектронноеВзаимодействиеПереопределяемый.ПодготовитьТекстСообщенияОНарушенииПравДоступа(ТекстСообщения);
	Возврат ТекстСообщения;
	
КонецФункции

#КонецОбласти

#Область МетодыHTTP

// Функция формирует прокси по настройкам прокси и протоколу.
//
// Параметры:
//  Протокол - Строка - протокол для которого устанавливаются параметры прокси сервера, например http, https, ftp.
//
// Возвращаемое значение:
//  ИнтернетПрокси - описание параметров прокси-серверов.
// 
Функция СформироватьПрокси(Протокол) Экспорт
	
	// НастройкаПроксиСервера - Соответствие:
	//  ИспользоватьПрокси - использовать ли прокси-сервер;
	//  НеИспользоватьПроксиДляЛокальныхАдресов - использовать ли прокси-сервер для локальных адресов;
	//  ИспользоватьСистемныеНастройки - использовать ли системные настройки прокси-сервера;
	//  Сервер       - адрес прокси-сервера;
	//  Порт         - порт прокси-сервера;
	//  Пользователь - имя пользователя для авторизации на прокси-сервере;
	//  Пароль       - пароль пользователя.
	НастройкаПроксиСервера = ПолучениеФайловИзИнтернета.НастройкиПроксиНаСервере();
	Если НастройкаПроксиСервера <> Неопределено Тогда
		ИспользоватьПрокси = НастройкаПроксиСервера.Получить("ИспользоватьПрокси");
		ИспользоватьСистемныеНастройки = НастройкаПроксиСервера.Получить("ИспользоватьСистемныеНастройки");
		Если ИспользоватьПрокси Тогда
			Если ИспользоватьСистемныеНастройки Тогда
				// Системные настройки прокси-сервера.
				Прокси = Новый ИнтернетПрокси(Истина);
			Иначе
				// Ручные настройки прокси-сервера.
				Прокси = Новый ИнтернетПрокси;
				Прокси.Установить(Протокол, НастройкаПроксиСервера["Сервер"], НастройкаПроксиСервера["Порт"],
					НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"]);
				Прокси.НеИспользоватьПроксиДляЛокальныхАдресов = НастройкаПроксиСервера["НеИспользоватьПроксиДляЛокальныхАдресов"];
			КонецЕсли;
		Иначе
			// Не использовать прокси-сервер.
			Прокси = Новый ИнтернетПрокси(Ложь);
		КонецЕсли;
	Иначе
		Прокси = Неопределено;
	КонецЕсли;
	
	Возврат Прокси;
	
КонецФункции

// Определяет параметры HTTP соединения по URL адресу.
//
// Параметры:
//  АдресСайта - Строка - URL сайта;
//  ЗащищенноеСоединение - Булево - возвращает Истина, если требуется шифрование;
//  Адрес - Строка - адрес сайта без протокола;
//  Протокол - Строка - название протокола.
//
Процедура ОпределитьПараметрыСайта(Знач АдресСайта, ЗащищенноеСоединение, Адрес, Протокол) Экспорт
	
	АдресСайта = СокрЛП(АдресСайта);
	
	АдресСайта = СтрЗаменить(АдресСайта, "\", "/");
	АдресСайта = СтрЗаменить(АдресСайта, " ", "");
	
	Если НРег(Лев(АдресСайта, 7)) = "http://" Тогда
		Протокол = "http";
		Адрес = Сред(АдресСайта,8);
		ЗащищенноеСоединение = Неопределено;
	ИначеЕсли НРег(Лев(АдресСайта, 8)) = "https://" Тогда
		Протокол =  "https";
		Адрес = Сред(АдресСайта,9);
		
		ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение();
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ФайловыеОперации

// Выгружает электронный документ в файл.
//
// Параметры:
//  ЭД - ЗначениеXDTO, ОбъектXDTO, Неопределено - Записываемое значение.
//  ИмяФайла - Строка - путь к файлу, в который сохраняются данные;
//  УказаниеТипа - НазначениеТипаXML - вариант назначения типа элемента данных XDTO.
//  ТипКодировки - Строка - файл будет записан в соответствующей кодировке.
//
Процедура ВыгрузитьЭДВФайл(ЭД, ИмяФайла, УказаниеТипа = Истина, ТипКодировки = "windows-1251", КонтекстОперации = Неопределено) Экспорт
	
	НоваяЗаписьXML = Новый ЗаписьXML;
	НоваяЗаписьXML.ОткрытьФайл(ИмяФайла, ТипКодировки);
	НоваяЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(НоваяЗаписьXML, ЭД, , , , ?(УказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное));
	НоваяЗаписьXML.Закрыть();
	
КонецПроцедуры

// Возвращает временный рабочий каталог для работы с файлами ЭДО.
// Каталог создается в каталоге временных файлов системы или ином предопределенном каталоге.
//
// Параметры:
//  Подкаталог - Строка - вложенный каталог первого уровня (не используется, оставлено для совместимости).
//  КлючУникальности - Строка - вложенный каталог второго уровня (не используется, оставлено для совместимости).
//
// Возвращаемое значение:
//  Строка - временный каталог.
//
Функция РабочийКаталог(Знач Подкаталог = "", Знач КлючУникальности = "") Экспорт
	
	ИмяКаталога = ПолучитьИмяВременногоФайла() + ПолучитьРазделительПути();
	СоздатьКаталог(ИмяКаталога);
	Возврат ИмяКаталога;
	
КонецФункции

// Определяет возможно ли без ошибки извлечь файлы из архива.
// Проверяется максимальная длина полного имени файла в 255 символов.
// 
// Параметры:
//  АрхивЧтение - ЧтениеZIPФайла - открытий zip архив.
//  КаталогРаспаковки - Строка - папка, в которую будут извлечены данные.
//  ИмяСоздаваемогоФайла - Строка - имя файла, который не может быть извлечен.
//
// Возвращаемое значение:
//  Булево - если возможно то Истина, иначе Ложь.
//
Функция ВозможноИзвлечьФайлы(АрхивЧтение, КаталогРаспаковки, ИмяСоздаваемогоФайла="") Экспорт
	
	ДлинаПутиПапки = СтрДлина(КаталогРаспаковки);
	
	Для Каждого Элемент Из АрхивЧтение.Элементы Цикл
		ИмяФайла = Элемент.ПолноеИмя;
		ДлинаИмениФайла = СтрДлина(ИмяФайла);
		ПолнаяДлина = ДлинаПутиПапки + ДлинаИмениФайла + 1;
		Если ПолнаяДлина > МаксимальнаяДлинаИмениФайла() Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Удаляет временные файлы или каталог.
//
// Параметры:
//  Путь - Строка - полный путь к файлу или каталогу
//  Маска - Строка - маска для выбора удаляемых файлов,
//        - Неопределено - удаляются все файлы и каталог <Путь>.
//
Процедура УдалитьВременныеФайлы(Путь, Маска = Неопределено) Экспорт
	
	Попытка
		УдалитьФайлы(Путь, Маска);
	Исключение
		ВидОперации = НСтр("ru='Удаление временного файла.';uk='Вилучення тимчасового файлу.'");
		ПодробныйТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЭлектронноеВзаимодействиеСлужебныйВызовСервера.ОбработатьОшибку(ВидОперации, ПодробныйТекстОшибки, , "ЭлектронноеВзаимодействие");
	КонецПопытки;
	
КонецПроцедуры

Функция МаксимальнаяДлинаИмениФайла() Экспорт
	
	Возврат 255;
	
КонецФункции

#КонецОбласти

#Область Криптография

// Определяет, где нужно проводить крипто операции.
//
// Возвращаемое значение:
//  Булево - Истина, если криптография настроена на сервере или Ложь - если на клиенте.
//
Функция ВыполнятьКриптооперацииНаСервере() Экспорт
	
	Возврат ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере();
	
КонецФункции

// Создает на сервере менеджер криптографии. Пароль не устанавливается.
//
// Параметры:
//  Отказ - Булево -  признак возникновения ошибки создания менеджера криптографии;
//  ПоказыватьОшибку - Булево - показывать текст ошибки.
//  Программа - Неопределено - возвращает менеджер криптографии первой
//              программы из справочника для которой удалось его создать.
//            - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - программа
//              для которой нужно создать и вернуть менеджер криптографии.
//
// Возвращаемое значение:
//   МенеджерКриптографии  - менеджер криптографии.
//
Функция МенеджерКриптографии(Отказ, ПоказыватьОшибку = Истина, Программа = Неопределено) Экспорт
	
	МенеджерКриптографии = ЭлектроннаяПодпись.МенеджерКриптографии("", ПоказыватьОшибку, , Программа);
	
	Если МенеджерКриптографии = Неопределено Тогда
		Отказ = Истина;
	КонецЕсли;
	
	Возврат МенеджерКриптографии;
	
КонецФункции

// Проверяет действительность подписи, без учета списка отозванных сертификатов.
// В случае ошибки генерирует исключение.
//
// Параметры:
//  МенеджерКриптографии  - МенеджерКриптографии - менеджер криптографии.
//  ДвоичныеДанныеФайла   - ДвоичныеДанные - двоичные данные файла.
//  ДвоичныеДанныеПодписи - ДвоичныеДанные - двоичные данные подписи.
//
Процедура ПроверитьПодпись(МенеджерКриптографии, ДвоичныеДанныеФайла, ДвоичныеДанныеПодписи) Экспорт
	
	МенеджерКриптографии.ПроверитьПодпись(ДвоичныеДанныеФайла, ДвоичныеДанныеПодписи);
	
КонецПроцедуры

// Формирует данные подписи объекта.
//
// Параметры:
//  МенеджерКриптографии  - МенеджерКриптографии - менеджер криптографии;
//  ОбъектДляПодписиСсылка  - ЛюбаяСсылка - ссылка на подписываемый объект;
//  ДвоичныеДанные  - ДвоичныеДанные - двоичные данные подписи;
//  СтруктураПараметровПодписи  - Структура - информация о подписи - выбранный сертификат, пароль, комментарий.
//
// Возвращаемое значение:
//   Структура   - данные для занесения в табличную часть ЭП.
//
Функция СформироватьДанныеПодписи(МенеджерКриптографии, ОбъектДляПодписиСсылка, ДвоичныеДанные, СтруктураПараметровПодписи) Экспорт
	
	МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу = СтруктураПараметровПодписи.ПарольПользователя;
	ДатаПодписи = Дата('00010101');
	
	НоваяПодписьДвоичныеДанные = МенеджерКриптографии.Подписать(ДвоичныеДанные, СтруктураПараметровПодписи.Сертификат);
	
	Отпечаток = Base64Строка(СтруктураПараметровПодписи.Сертификат.Отпечаток);
	КомуВыданСертификат = ЭлектроннаяПодпись.ПредставлениеСубъекта(СтруктураПараметровПодписи.Сертификат);
	ДвоичныеДанныеСертификата = СтруктураПараметровПодписи.Сертификат.Выгрузить();
	
	ДанныеПодписи = Новый Структура;
	ДанныеПодписи.Вставить("ОбъектСсылка",               ОбъектДляПодписиСсылка);
	ДанныеПодписи.Вставить("Отпечаток",                  Отпечаток);
	ДанныеПодписи.Вставить("ДатаПодписи",                ДатаПодписи);
	ДанныеПодписи.Вставить("Комментарий",                СтруктураПараметровПодписи.Комментарий);
	ДанныеПодписи.Вставить("ИмяФайлаПодписи",            "");
	ДанныеПодписи.Вставить("КомуВыданСертификат",        КомуВыданСертификат);
	ДанныеПодписи.Вставить("АдресФайла",                 "");
	ДанныеПодписи.Вставить("Подпись",                    НоваяПодписьДвоичныеДанные);
	ДанныеПодписи.Вставить("Сертификат",                 ДвоичныеДанныеСертификата);
	
	Возврат ДанныеПодписи;
	
КонецФункции

// Позволяет получить свойства субъекта сертификата ЭП.
//
// Параметры:
//  Сертификат ЭП - справочник-ссылка - ссылка на элемент справочника "Сертификаты ЭП".
//
// Возвращаемое значение:
//  Структура свойств субъекта сертификата.
//
Функция СвойстваСубъектаСертификата(СертификатЭП) Экспорт

	ПараметрыСертификата = ЭлектронноеВзаимодействиеСлужебныйВызовСервера.РеквизитыСертификата(СертификатЭП);
	Сертификат = Новый СертификатКриптографии(ПараметрыСертификата.ДвоичныеДанныеСертификата);
	
	Возврат ЭлектроннаяПодпись.СвойстваСубъектаСертификата(Сертификат);
	
КонецФункции

// Находит сертификат по строке отпечатка.
//
// Параметры:
//  Отпечаток  - Строка - base64 кодированный отпечаток сертификата;
//  ТолькоВЛичномХранилище  - Булево - вести поиск только в личном хранилище.
//
// Возвращаемое значение:
//   СертификатКриптографии  - сертификат криптографии.
//
Функция ПолучитьСертификатПоОтпечатку(Отпечаток, ТолькоВЛичномХранилище = Ложь) Экспорт
	
	ДвоичныеДанныеОтпечатка = Base64Значение(Отпечаток);
	
	Отказ = Ложь;
	МенеджерКриптографии = МенеджерКриптографии(Отказ);
	Если Отказ Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ХранилищеСертификатовКриптографии = Неопределено;
	Если ТолькоВЛичномХранилище Тогда
		ХранилищеСертификатовКриптографии = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
			ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты);
	Иначе	
		ХранилищеСертификатовКриптографии = МенеджерКриптографии.ПолучитьХранилищеСертификатов();
	КонецЕсли;
	
	Сертификат = ХранилищеСертификатовКриптографии.НайтиПоОтпечатку(ДвоичныеДанныеОтпечатка);
	
	Возврат Сертификат;
	
КонецФункции

// Обработчик подписки на событие ЗаполнитьВидыЭДДляСертификатаЭП.
//
// Параметры:
//  Источник - СправочникОбъект.СертификатыКлючейЭлектроннойПодписиИШифрования - сертификат криптографии;
//  Отказ - Булево - Признак отказа от записи элемента.
//
Процедура ЗаполнитьВидыЭДДляСертификатаЭППередЗаписью(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;

КонецПроцедуры

Функция ОписаниеПрограммКриптографии() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Программы.ИмяПрограммы КАК ИмяПрограммы,
	|	Программы.ТипПрограммы КАК ТипПрограммы
	|ИЗ
	|	Справочник.ПрограммыЭлектроннойПодписиИШифрования КАК Программы";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	НаборОписаний = Новый Массив;
	
	Пока Выборка.Следующий() Цикл
		
		Описание = ЭлектроннаяПодпись.НовоеОписаниеПрограммы();
		ЗаполнитьЗначенияСвойств(Описание, Выборка);
		НаборОписаний.Добавить(Описание);
		
	КонецЦикла;
	
	Возврат НаборОписаний;
	
КонецФункции

#КонецОбласти

#Область ТабличныйДокумент

// Скрытие областей табличного документа.
//
// Параметры:
//  ТабличныйДокумент - ТабличныйДокумент - табличный документ, где скрываются области.
//  ИменаОбластей - Строка - Имена скрываемых областей через запятую.
//  ТипСмещения - ТипСмещенияТабличногоДокумента - тип смещения удаляемой области.
//
Процедура СкрытьОбластиТабличногоДокумента(ТабличныйДокумент, ИменаОбластей, Знач ТипСмещения = Неопределено) Экспорт
	
	Если ТипСмещения = Неопределено Тогда
		ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали;
	КонецЕсли;
	
	Если ТипЗнч(ИменаОбластей) <> Тип("Массив") Тогда
		Области = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(ИменаОбластей, ",");
	КонецЕсли;
	
	Для каждого ИмяОбласти Из Области Цикл
		
		ЕстьОбластьДД = ТабличныйДокумент.Области.Найти(СокрЛП(ИмяОбласти));
		
		Если ЕстьОбластьДД <> Неопределено Тогда
			ОбластьШапки = ТабличныйДокумент.Области.Найти("Шапка");
			ОбластьТаблицы = ТабличныйДокумент.Область(ИмяОбласти);
			
			Верх = ?(ОбластьТаблицы.Лево = 0 И ОбластьТаблицы.Право = 0 ИЛИ ОбластьШапки = Неопределено,
				ОбластьТаблицы.Верх, ОбластьШапки.Низ + 1);
				
			Если ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали Тогда
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, ОбластьТаблицы.Лево,
					ТабличныйДокумент.ВысотаТаблицы, ОбластьТаблицы.Право);
			ИначеЕсли ТипСмещения = ТипСмещенияТабличногоДокумента.БезСмещения Тогда 
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, ОбластьТаблицы.Лево,
					ОбластьТаблицы.Низ, ОбластьТаблицы.Право);
				Если ИмяОбласти = "ИдентификаторДокумента" Тогда
					ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали;	
				КонецЕсли;
			Иначе
				Низ = ТабличныйДокумент.ВысотаТаблицы;
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, , Низ,);
			КонецЕсли; 
				
			ТабличныйДокумент.УдалитьОбласть(УдаляемаяОбласть, ТипСмещения);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьМакетИдентификатораДокумента() Экспорт
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область РаботаСXDTO

// Возвращает значение свойства XDTO
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект, значение свойства которого нужно получить
//  Путь - Строка - путь к свойству, разделителем является символ ".".
// 
// Возвращаемое значение:
//  Неопределено - данное свойство отсутствует;
//  Строка - значение свойства;
//  ОбъектXDTO - объект XDTO.
//
Функция ЗначениеСвойстваXDTO(ОбъектXDTO, Путь) Экспорт
	
	Если ТипЗнч(ОбъектXDTO) <> Тип("ОбъектXDTO") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСтрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(Путь, ".");
	
	Если ОбъектXDTO.Свойства().Получить(МассивСтрок[0]) = Неопределено Тогда
		Возврат Неопределено
	КонецЕсли;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Значение = ОбъектXDTO[МассивСтрок[0]];
		Если ТипЗнч(Значение) = Тип("ОбъектXDTO") И Значение.Свойства().Количество() = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		Возврат Значение;
	Иначе
		НаборСвойств = ОбъектXDTO.Свойства();
		Свойство = НаборСвойств.Получить(МассивСтрок[0]);
		Если Свойство = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		Если Свойство.ВерхняяГраница = 1 Тогда
			ПодОбъектXDTO = ОбъектXDTO.ПолучитьXDTO(Свойство);
		Иначе
			Список = ОбъектXDTO.ПолучитьСписок(Свойство);
			Если Список.Количество() = 0 Тогда
				Возврат Неопределено;
			Иначе
				ПодОбъектXDTO = Список[0];
			КонецЕсли;
		КонецЕсли;
		МассивСтрок.Удалить(0);
		НоваяСтрока = "";
		Для Каждого Элемент Из МассивСтрок Цикл
			НоваяСтрока = НоваяСтрока + ?(ПустаяСтрока(НоваяСтрока), "", ".") + Элемент;
		КонецЦикла;
		Возврат ЗначениеСвойстваXDTO(ПодОбъектXDTO, НоваяСтрока);
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область Преобразование

// Разделение строки на элементы массива.
//
// Параметры:
//  Строка		 - Строка - строка для разделения.
//  Разделитель	 - Строка - разделитель.
// 
// Возвращаемое значение:
//  Массив - результат разделения.
//
Функция МассивПодстрок(Знач Строка, Разделитель) Экспорт
	
	Результат = Новый Массив;
	Если ПустаяСтрока(Строка) Тогда
		Возврат Результат;
	КонецЕсли;
	
	НачПозицияПервогоЭлемента = СтрНайти(Строка, "{");
	КонПозицияПервогоЭлемента = СтрНайти(Строка, "}");
	Если НачПозицияПервогоЭлемента > 0 И КонПозицияПервогоЭлемента > 0 Тогда
		ПервыйЭлемент = Сред(Строка, НачПозицияПервогоЭлемента, КонПозицияПервогоЭлемента);
		Результат.Добавить(СокрЛП(ПервыйЭлемент));
		Строка = СокрЛП(Сред(Строка,КонПозицияПервогоЭлемента + 2));
	КонецЕсли;
	
	Пока Истина Цикл
		Позиция = СтрНайти(Строка, Разделитель);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Результат.Добавить(СокрЛП(Лев(Строка,Позиция - 1)));
		Строка = СокрЛП(Сред(Строка,Позиция + 1));
	КонецЦикла;
	
	Результат.Добавить(СокрЛП(Строка));
	
	Возврат Результат;
	
КонецФункции 

// Получение строки в формате Base64 по двоичным данным.
//
// Параметры:
//  Данные - ДвоичныеДанные - Данные, которые необходимо преобразовать в формат Base64.
// 
// Возвращаемое значение:
//  Строка - Двоичные данные в формате Base64.
//
Функция Base64СтрокаИзДвоичныхДанных(Знач Данные) Экспорт
	
	Результат = "";
	
	Если ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		Результат = ПолучитьBase64СтрокуИзДвоичныхДанных(Данные);
		Результат = СтрЗаменить(Результат, Символы.ПС, "");
		Результат = СтрЗаменить(Результат, Символы.ВК, "");
		Результат = СтрЗаменить(Результат, " ", "");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Локализация

// Определяет, использует ли конфигурация несколько языков.
// 
// Возвращаемое значение:
//  Булево - Истина, если в конфигурации объявлено несколько языков.
//
Функция КонфигурацияИспользуетНесколькоЯзыков() Экспорт

	Возврат Метаданные.Языки.Количество() > 1;

КонецФункции

#КонецОбласти

#Область РаботаСОбъектами

// Возвращает массив документов, которые могут быть проведены.
//
// Параметры:
//  МассивДокументов - Массив - массив ссылок на документы.
//
// Возвращаемое значение:
//  Массив - массив документов, которые можно проводить.
//
Функция МассивПроводимыхДокументов(МассивДокументов) Экспорт
	
	МассивПроводныхДокументов = Новый Массив;
	МассивТиповНеПроводныхДокументов = Новый Массив;
	Для каждого Элемент Из МассивДокументов Цикл
		ИмяДокумента = Элемент.Метаданные().ПолноеИмя();
		Если Метаданные.Документы.Содержит(Метаданные.НайтиПоПолномуИмени(ИмяДокумента)) Тогда
			
			Если Элемент.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Запретить Тогда
				Если МассивТиповНеПроводныхДокументов.Найти(ТипЗнч(Элемент)) = Неопределено Тогда
					МассивТиповНеПроводныхДокументов.Добавить(ТипЗнч(Элемент));
				КонецЕсли;
			КонецЕсли;
			
			МассивПроводныхДокументов.Добавить(Элемент)
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТипНеПроводногоДокумента Из МассивТиповНеПроводныхДокументов Цикл
		ОбщегоНазначенияКлиентСервер.УдалитьВсеВхожденияТипаИзМассива(МассивПроводныхДокументов, ТипНеПроводногоДокумента);
	КонецЦикла;
	
	Возврат МассивПроводныхДокументов;
	
КонецФункции

// Получает ссылку для объекта ИБ, в том числе нового.
//
// Параметры:
//  Объект	 - Объект - объект ссылочного типа.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка - ссылка на переданный объект.
//
Функция ПолучитьСсылкуОбъектаБезопасно(Объект) Экспорт

	Ссылка = Объект.Ссылка;
	Если Ссылка.Пустая() Тогда
		Ссылка = Объект.ПолучитьСсылкуНового();
		Если Ссылка.Пустая() Тогда
			Ссылка = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка).ПолучитьСсылку();
			Объект.УстановитьСсылкуНового(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ссылка;

КонецФункции 

// Получает переданные реквизиты объекта или ссылки.
//
// Параметры:
//  Объект    - Объект, ЛюбаяСсылка - объект ссылочного типа или любая ссылка.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
// 
// Возвращаемое значение:
//  Структура - структура, в которой ключами являются имена реквизитов, а значениями - их значения.
//
Функция ЗначенияРеквизитовОбъектаИлиСсылки(Объект, Знач Реквизиты) Экспорт
	
	Если ОбщегоНазначения.ЗначениеСсылочногоТипа(Объект) Тогда
		Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Объект, Реквизиты);
	Иначе
		// Передан объект - поэтому нужно составить структуру из реквизитов и прочитать в нее значения из объекта напрямую.
		Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
			Если ПустаяСтрока(Реквизиты) Тогда
				Возврат Новый Структура;
			КонецЕсли;
			Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		КонецЕсли;
		
		Результат = Новый Структура;
		Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
			Результат = Реквизиты;
		ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
			Для Каждого Реквизит Из Реквизиты Цикл
				Результат.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
			КонецЦикла;
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Неверный тип второго параметра Реквизиты: %1';uk='Невірний тип другого параметра Реквізити: %1'"), Строка(ТипЗнч(Реквизиты)));
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(Результат, Объект);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Устанавливает управляемую блокировку по значениям полей.
//
// Параметры:
//  Пространство - Строка - пространство блокировки.
//  Поля - Структура - ключ задает имя поля пространства блокировки, а значение:
//                     1. Источник задан: соответствующее поле источника, содержащее значения для блокировки.
//                     2. Источник не задан: непосредственно значение для блокировки.
//  Источник - РезультатЗапроса, Табличная часть, ТаблицаЗначений  - источник данных.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Неопределено - значение по умолчанию "Исключительный".
//
Процедура УстановитьУправляемуюБлокировку(Знач Пространство, Знач Поля = Неопределено, Знач Источник = Неопределено, Знач Режим = Неопределено) Экспорт
	
	Если Режим = Неопределено Тогда
		Режим = РежимБлокировкиДанных.Исключительный;
	КонецЕсли;
	
	Если Поля = Неопределено Тогда
		Поля = Новый Структура;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(Пространство);
	Если Источник = Неопределено Тогда
		Для каждого КлючЗначение Из Поля Цикл
			ЭлементБлокировки.УстановитьЗначение(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
	Иначе
		ЭлементБлокировки.ИсточникДанных = Источник;
		Для каждого КлючЗначение Из Поля Цикл
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	ЭлементБлокировки.Режим = Режим;
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Устанавливает управляемую блокировку по ссылке на объект.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка, по которой нужно установить блокировку.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Строка - допустимые значения "Разделяемый" и "Исключительный".
//        - Неопределено - значение по умолчанию "Исключительный".
//
//
Процедура УстановитьУправляемуюБлокировкуПоСсылке(Знач Ссылка, Знач Режим = Неопределено) Экспорт
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
	
	Поля = Новый Структура("Ссылка", Ссылка);
	
	УстановитьУправляемуюБлокировку(ПространствоБлокировки, Поля,, Режим);
	
КонецПроцедуры

// Устанавливает управляемую блокировку по набору записей.
// Используются установленные отборы в наборе.
//
// Параметры:
//  Набор - НаборЗаписей - набор, по которому нужно установить блокировку.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Строка - допустимые значения "Разделяемый" и "Исключительный".
//        - Неопределено - значение по умолчанию "Исключительный".
//
//
Процедура УстановитьУправляемуюБлокировкуПоНаборуЗаписей(Знач Набор, Знач Режим = Неопределено) Экспорт
	
	МетаданныеОбъекта = Набор.Метаданные();
	ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
	
	Поля = Новый Структура;
	Для каждого ЭлементОтбора Из Набор.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			Поля.Вставить(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	УстановитьУправляемуюБлокировку(ПространствоБлокировки, Поля,, Режим);
	
КонецПроцедуры

// Получает объект по ссылке для дальнейшего изменения. 
// Устанавливает управляемую и пессимистическую блокировку.
// Возможен вызов исключения, если не удалось установить пессимистическую блокировку.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка, объект которой нужно получить.
//
// Возвращаемое значение:
//  Объект,Неопределено - объект по ссылке. Неопределено, если объект отсутствует.
//
Функция ОбъектПоСсылкеДляИзменения(Знач Ссылка) Экспорт
	
	УстановитьУправляемуюБлокировкуПоСсылке(Ссылка);
	Объект = Ссылка.ПолучитьОбъект();
	
	Возврат Объект;
	
КонецФункции

#КонецОбласти



#Область ОбработкаОшибок

// Добавляет в ошибку в хранилище накопленных ошибок.
//
// Параметры:
//  Ошибки			         - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                      Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  ТекстОшибки				 - Строка - текст фиксируемой ошибки.
//  ПараметрыОбработкиОшибок - Структура - используется для указания указания параметров действий по клику на ошибке,
//                                         формируется функцией ЭлектронноеВзаимодействиеКлиентСервер.НовыеПараметрыОбработкиОшибки.
//  ИндексВставки			 - Число - индекс позиции вставки в массиве ошибок.
//
Процедура ДобавитьОшибку(Ошибки, ТекстОшибки, ПараметрыОбработкиОшибки = Неопределено, ИндексВставки = Неопределено) Экспорт

	Если Ошибки = Неопределено Тогда
		Ошибки = Новый Массив;
	КонецЕсли;
	
	ДанныеОшибки = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки();
	
	Если ПараметрыОбработкиОшибки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(ДанныеОшибки, ПараметрыОбработкиОшибки);
	КонецЕсли;
	
	// Выводим указанный текст ошибки, только если он не был переопределен в параметрах обработки ошибки.
	Если Не ЗначениеЗаполнено(ДанныеОшибки.ТекстОшибки) Тогда
		ДанныеОшибки.Вставить("ТекстОшибки", ТекстОшибки);
	КонецЕсли;
	
	Если ИндексВставки = Неопределено Тогда
		Ошибки.Добавить(ДанныеОшибки);
	Иначе
		Ошибки.Вставить(ИндексВставки, ДанныеОшибки);
	КонецЕсли;

КонецПроцедуры

// Преобразует массив ошибок в строку.
//
// Параметры:
//  Ошибки - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                    Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
// 
// Возвращаемое значение:
//  Строка - единая строка сообщения об ошибке.
//
Функция СоединитьОшибки(Ошибки) Экспорт

	МассивОшибок = Новый Массив;
	
	Если ЗначениеЗаполнено(Ошибки) Тогда
		Для Каждого ОписаниеОшибки Из Ошибки Цикл
			МассивОшибок.Добавить(ОписаниеОшибки.ТекстОшибки);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтрСоединить(МассивОшибок, Символы.ПС);

КонецФункции 

// Возвращает стандартный текст ошибки для незаполненного значения дерева.
// 
// Возвращаемое значение:
//  Строка - текст ошибки.
//
Функция ТекстОшибкиНеЗаполненногоЗначенияДерева() Экспорт
	
	Возврат НСтр("ru='значение не заполнено';uk='значення не заповнено'");

КонецФункции

// Возвращает стандартный текст ошибки для неверно заполненного значения дерева.
// 
// Возвращаемое значение:
//  Строка - текст ошибки.
//
Функция ТекстОшибкиНеверноЗаполненногоЗначенияДерева() Экспорт
	
	Возврат НСтр("ru='значение указано неверно';uk='значення вказано невірно'");

КонецФункции

Функция СформироватьТекстИсключения(Знач ТипИсключения, Знач Параметр) Экспорт
	
	ЧастиТекста = Новый Массив;
	Если ТипИсключения = "НедопустимыеПараметрыМетода" Тогда
		
		ЧастиТекста.Добавить(НСтр("ru='Недопустимые параметры метода';uk='Неприпустимі параметри методу'"));
		ЧастиТекста.Добавить(Параметр);
		
	Иначе
		
		ЧастиТекста.Добавить(НСтр("ru='Неизвестная ошибка';uk='Невідома помилка'"));
		Если ЗначениеЗаполнено(Параметр) Тогда
			ЧастиТекста.Добавить(Параметр);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтрСоединить(ЧастиТекста, Символы.ПС);
	
КонецФункции

// Возвращает текст сообщения пользователю по коду ошибки.
//
// Параметры:
//  КодОшибки - Строка * код ошибки.
//  СтороннееОписаниеОшибки - Строка - описание ошибки переданное другой системой.
//
// Возвращаемое значение:
//  Строка - переопределенное описание ошибки.
//
Функция ПолучитьСообщениеОбОшибке(КодОшибки, СтороннееОписаниеОшибки = "") Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ШаблонСообщения = НСтр("ru='Код ошибки %1. %2';uk='Код помилки %1. %2'");
	
	СообщенияОшибок = Новый Соответствие;
	ИнициализацияСообщенийОшибок(СообщенияОшибок);
	
	СообщениеОбОшибке = СообщенияОшибок.Получить(КодОшибки);
	Если СообщениеОбОшибке = Неопределено ИЛИ НЕ ЗначениеЗаполнено(СообщениеОбОшибке) Тогда
		СообщениеОбОшибке = СтороннееОписаниеОшибки;
	КонецЕсли;
	
	ЭлектронноеВзаимодействиеПереопределяемый.ИзменитьСообщениеОбОшибке(КодОшибки, СообщениеОбОшибке);
	
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, КодОшибки, СообщениеОбОшибке);
	
	Возврат ТекстСообщения;
	
КонецФункции

#КонецОбласти

#Область АвтоматизированноеТестирование
// Выводит область ячеек в табличный документ, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ для вывода.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  Уровень				 - Число - см. ТабличныйДокумент.Вывести.
//  ИмяГруппы			 - Строка - см. ТабличныйДокумент.Вывести.
//  Открыта				 - Булево - см. ТабличныйДокумент.Вывести.
//
Процедура ВывестиОбластьВТабличныйДокумент(ТабличныйДокумент, Знач ОбластьМакета, Знач ПрефиксДляИмен, 
	Знач ИндексПрефикса = "", Уровень = Неопределено, ИмяГруппы = Неопределено, Открыта = Истина) Экспорт

	ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.Вывести(ОбластьМакета, Уровень, ИмяГруппы, Открыта);

КонецПроцедуры

// Присоединяет область ячеек к табличному документу, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ для вывода.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  Уровень				 - Число - см. ТабличныйДокумент.Присоединить.
//  ИмяГруппы			 - Строка - см. ТабличныйДокумент.Присоединить.
//  Открыта				 - Булево - см. ТабличныйДокумент.Присоединить.
//
Процедура ПрисоединитьОбластьКТабличномуДокументу(ТабличныйДокумент, Знач ОбластьМакета, Знач ПрефиксДляИмен, 
	Знач ИндексПрефикса = "", Уровень = Неопределено, ИмяГруппы = Неопределено, Открыта = Истина) Экспорт

	ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.Присоединить(ОбластьМакета, Уровень, ИмяГруппы, Открыта);

КонецПроцедуры

// Производит вставку области ячеек в табличный документ, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ИсходнаяОбласть		 - ТабличныйДокумент - табличный документ для вставки.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  ОбластьПриемник		 - ОбластьЯчеекТабличногоДокумента - см. ТабличныйДокумент.ВставитьОбласть.
//  Сдвиг			     - ТипСмещенияТабличногоДокумента - см. ТабличныйДокумент.ВставитьОбласть.
//  ЗаполнятьПараметры	 - Булево - см. ТабличныйДокумент.ВставитьОбласть.
//
Процедура ВставитьОбластьВТабличныйДокумент(ТабличныйДокумент, Знач ИсходнаяОбласть, Знач ПрефиксДляИмен,
	Знач ИндексПрефикса = "", Знач ОбластьПриемник = Неопределено, Сдвиг = Неопределено, ЗаполнятьПараметры = Истина) Экспорт

	ПрисвоитьИменаЯчейкамТабличногоДокумента(ИсходнаяОбласть, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.ВставитьОбласть(ИсходнаяОбласть.Область(), ОбластьПриемник, Сдвиг, ЗаполнятьПараметры);

КонецПроцедуры

#КонецОбласти

#Область РаботаСДеревомДанных

// Создает пустой объект ДереваРазбора.
//
// Возвращаемое значение:
//   ДеревоЗначений - пустое дерево с колонками.
//
Функция ИнициализироватьДеревоРазбора() Экспорт
	
	ДеревоРазбора = Новый ДеревоЗначений;
	ДеревоРазбора.Колонки.Добавить("ТипОбъекта");
	ДеревоРазбора.Колонки.Добавить("СсылкаНаОбъект");
	ДеревоРазбора.Колонки.Добавить("ОписаниеТипа");
	ДеревоРазбора.Колонки.Добавить("ИндексСтроки");
	ДеревоРазбора.Колонки.Добавить("Реквизит");
	ДеревоРазбора.Колонки.Добавить("ЗначениеРеквизита");
	ДеревоРазбора.Колонки.Добавить("ОписаниеОбъекта");
	ДеревоРазбора.Колонки.Добавить("ВидЭД");
	ДеревоРазбора.Колонки.Добавить("ВерсияФормата");
	ДеревоРазбора.Колонки.Добавить("ИД");
	ДеревоРазбора.Колонки.Добавить("НаправлениеЭД");
	ДеревоРазбора.Колонки.Добавить("ДопДанные");
	
	ДеревоРазбора.Колонки.Добавить("ТипЭлементаВерсииЭД");
	
	Возврат ДеревоРазбора;
	
КонецФункции

// Находит или создает новый тип в дереве разбора.
//
// Параметры:
//    ДеревоРазбора - ДеревоЗначений - исходное дерево значений;
//    ЗначениеТипаОбъекта - Произвольный - искомый тип объекта.
//
// Возвращаемое значение:
//  СтрокаДереваЗначений - найденная или созданная строка.
//
Функция НайтиСоздатьТипОбъектаВДеревеРазбора(ДеревоРазбора, ЗначениеТипаОбъекта) Экспорт
	
	НайденнаяСтрока = ДеревоРазбора.Строки.Найти(ЗначениеТипаОбъекта, "ТипОбъекта");
	Если НайденнаяСтрока = Неопределено Тогда
		НайденнаяСтрока = ДеревоРазбора.Строки.Добавить();
		НайденнаяСтрока.ТипОбъекта = ЗначениеТипаОбъекта;
		НайденнаяСтрока.ИндексСтроки = Строка(ДеревоРазбора.Строки.Индекс(НайденнаяСтрока));
	КонецЕсли;
	
	Возврат НайденнаяСтрока;
	
КонецФункции

// Добавляет реквизит в шапку объекта.
//
// Параметры:
//  СтрокаЭлементов - СтрокаДереваЗначений - текущая строка дерева значений;
//  ИмяРеквизита - Строка - название добавляемого реквизита;
//  ЗначениеРеквизита - Произвольный - значение добавляемого реквизита;
//  СсылкаНаОбъект - Произвольный - ссылка на связанный объект информационной базы.
//
Процедура ДобавитьРеквизитШапкиОбъекта(СтрокаЭлементов, ИмяРеквизита, ЗначениеРеквизита, СсылкаНаОбъект = Неопределено) Экспорт
	
	НовСтрока = СтрокаЭлементов.Строки.Добавить();
	НовСтрока.Реквизит = ИмяРеквизита;
	НовСтрока.ЗначениеРеквизита = ЗначениеРеквизита;
	Если СсылкаНаОбъект <> Неопределено Тогда
		НовСтрока.СсылкаНаОбъект = СсылкаНаОбъект;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет дополнительные реквизиты в табличную часть объекта.
//
// Параметры:
//  СтрокаЭлементов - СтрокаДереваЗначений - строка дерева значений, в которую помещаются дополнительные реквизиты;
//  ИмяТЧ - Строка - название табличной части в дереве значений;
//  СписокРеквизитов - СписокЗначений - список помещаемых реквизитов.
//
Процедура ДобавитьРеквизитыТЧОбъекта(СтрокаЭлементов, ИмяТЧ, СписокРеквизитов) Экспорт
	
	// Добавить в реквизиты ТЧ ОбменСКонтрагентами
	НовСтрока          = СтрокаЭлементов.Строки.Добавить();
	НовСтрока.Реквизит = ИмяТЧ;
	Для Каждого ТекЭлСписка Из СписокРеквизитов Цикл
		НовСтрокаТЧ                   = НовСтрока.Строки.Добавить();
		НовСтрокаТЧ.Реквизит          = ТекЭлСписка.Представление;
		НовСтрокаТЧ.ЗначениеРеквизита = ТекЭлСписка.Значение;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет дополнительные реквизиты в дерево данных.
//
// Параметры:
//  СтрокаДереваРазбора - СтрокаДереваЗначений - строка дерева, в которую помещаются дополнительные реквизиты;
//  ДопРеквизиты - Структура - коллекция помещаемых дополнительных реквизитов;
//  ДеревоРазбора - ДеревоЗначений - исходное дерево данных;
//  Отказ - Булево - признак возникновения ошибки выполнения метода.
//
Процедура ДобавитьДопРеквизиты(СтрокаДереваРазбора, ДопРеквизиты, ДеревоРазбора, Отказ = Ложь) Экспорт
	
	Для Каждого ТекЭл Из ДопРеквизиты Цикл
		
		Если НЕ ТипЗнч(ТекЭл.Значение) = Тип("ОбъектXDTO") Тогда
					
			Если ЗначениеЗаполнено(ТекЭл.Значение) Тогда
				Если ТипЗнч(ТекЭл.Значение) = Тип("Массив") И НЕ ТекЭл.Ключ = "ЗначенияСвойств" И НЕ ТекЭл.Ключ = "Картинки" Тогда
					Для Каждого ТекЭлМассива Из ТекЭл.Значение Цикл
						Если ТипЗнч(ТекЭлМассива) = Тип("Структура") Тогда
							ДобавитьДопРеквизиты(СтрокаДереваРазбора, ТекЭлМассива, ДеревоРазбора, Отказ);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Поищем, возможно уже есть такой реквизит с таким же значением.
					НайденнаяСтрока = СтрокаДереваРазбора.Строки.Найти(ТекЭл.Ключ, "Реквизит", Истина);
					Если НайденнаяСтрока <> Неопределено И НайденнаяСтрока.ЗначениеРеквизита = ТекЭл.Значение Тогда
						Продолжить;
					КонецЕсли;
					
					НовСтрока = СтрокаДереваРазбора.Строки.Добавить();
					НовСтрока.Реквизит          = ТекЭл.Ключ;
					НовСтрока.ЗначениеРеквизита = ТекЭл.Значение;
					// Если ИндексСтроки, то попытка найти СсылкуНаОбъект.
					Если ТипЗнч(НовСтрока.ЗначениеРеквизита) = Тип("Строка") Тогда
						НайденнаяСтрока = ДеревоРазбора.Строки.Найти(НовСтрока.ЗначениеРеквизита, "ИндексСтроки", Истина);
						Если НайденнаяСтрока <> Неопределено Тогда
							Если ЗначениеЗаполнено(НайденнаяСтрока.СсылкаНаОбъект) Тогда
								НовСтрока.СсылкаНаОбъект = НайденнаяСтрока.СсылкаНаОбъект;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет тип объекта по текстовому представлению.
//
// Параметры:
//  ОписаниеТипаОбъекта - Строка - текстовое представление типа объекта.
//
// Возвращаемое значение:
//  Строка - тип справочника.
//
Функция ТипОбъекта(ОписаниеТипаОбъекта) Экспорт
	
	ТипОбъекта = Неопределено;
	
	ИмяПрикладногоСправочника = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ИмяПрикладногоСправочника(ОписаниеТипаОбъекта);
	Если ЗначениеЗаполнено(ИмяПрикладногоСправочника) Тогда
		ТипОбъекта = "СправочникСсылка." + ИмяПрикладногоСправочника;
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Значение реквизита в дереве.
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - объект поиска.
//  ПолныйПуть - Произвольный - значение поиска.
//  СообщатьОбОшибке - Булево - если Истина сообщать об ошибках поиска.
// 
// Возвращаемое значение:
//  Произвольный - результат поиска.
//
Функция ЗначениеРеквизитаВДереве(ДеревоДанных, ПолныйПуть, СообщатьОбОшибке = Истина,
	НайденнаяСтрока = Неопределено, Типизировать = Ложь) Экспорт
	
	НайденнаяСтрока = ДеревоДанных.Строки.Найти(ПолныйПуть, "ПолныйПуть", Истина);
	Если НайденнаяСтрока <> Неопределено Тогда
		Результат = НайденнаяСтрока.Значение;
		
		Если Типизировать Тогда
			Результат = НайденнаяСтрока.ТипЗначения.ПривестиЗначение(НайденнаяСтрока.Значение);
		КонецЕсли;
		
		Возврат Результат;
	ИначеЕсли СообщатьОбОшибке Тогда
		ТекстСообщения = НСтр("ru='Не найдено поле в дереве данных по полному пути <%1>';uk='Не знайдено поле в дереві даних за повного шляху <%1>'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщения, ПолныйПуть);
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	КонецЕсли;
	
КонецФункции

// Добавляет значение в дерево данных.
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - дерево, в которое помещается новое значение;
//  ИмяРеквизита - Строка - название помещаемого реквизита;
//  ЗначениеРеквизита - Произвольный - значение помещаемого реквизита.
//
Процедура ДобавитьЗначениеВДерево(ДеревоДанных, ИмяРеквизита, ЗначениеРеквизита) Экспорт
	
	СтрокаДерева = ДеревоДанных.Строки.Найти(ИмяРеквизита);
	Если СтрокаДерева = Неопределено Тогда
		СтрокаДерева = ДеревоДанных.Строки.Добавить();
	КонецЕсли;
	НомерУровня = СтрЧислоВхождений(ИмяРеквизита, ".") + 1;
	СтрокаДерева.ПолныйПуть = ИмяРеквизита;
	СтрокаДерева["Уровень" + НомерУровня] = ЭлектронноеВзаимодействие.НазваниеКолонки(ИмяРеквизита);
	СтрокаДерева.Значение = ЗначениеРеквизита;

КонецПроцедуры

// Проверяет заполнение обязательных реквизитов дерева
// Параметры:
//  ДеревоДанных                            - деревоЗначений - дерево с данными.
//  Ошибки                                  - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                                     Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  ДатаПоФорматуФНС                        - Булево - если установлена в Истину, значения типа "Дата" будут проверяться дополнительно
//                                                     на вхождение в диапазон лет 1900-2099 (требование схем ФНС).
//
Процедура ПроверитьЗаполнениеРеквизитовДереваДанныхРекурсивно(ДеревоДанных, Ошибки, ДатаПоФорматуФНС = Ложь) Экспорт
	
	ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(ДеревоДанных, Ошибки, Ложь,,, ДатаПоФорматуФНС);
	
КонецПроцедуры

// Добавляет в ошибку в хранилище накопленных ошибок.
//
// Параметры:
//  Ошибки			 				 - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                     Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  СтрокаДерева			 		 - СтрокаДереваЗначений - строка дерева электронного документа, по реквизиту которой
//                                     фиксируется ошибка.
//  ТекстОшибки				 		 - Строка - текст фиксируемой ошибки.
//  ПодставлятьИмяРеквизита	 		 - Булево - если Истина, в начало сообщения об ошибке будет подставлено
//                                     прикладное имя реквизита.
//  НомерСтрокиДанных		 		 - Число - если указана, будет подставлена в имя реквизита.
//  ПрикладноеПредставлениеРеквизита - Строка - если указано, представление реквизита не будет получаться по строке дерева - 
//                                     будет использовано указанное представление.
//
Процедура ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки, ПодставлятьИмяРеквизита = Истина,
	НомерСтрокиДанных = Неопределено, ПрикладноеПредставлениеРеквизита = "") Экспорт
	
	// Даже если по каким-то причинам не нашли строку дерева, все равно выдаем ошибку. Лучше выдать неполное сообщение
	// об ошибке, чем пропустить некорректный документ.
	Если СтрокаДерева <> Неопределено Тогда
		ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева);
		
		ПараметрыОбработкиОшибки = ПараметрыОшибкиПоСтрокеДерева(СтрокаДерева);
	
		Если ПодставлятьИмяРеквизита Тогда
			Если Не ЗначениеЗаполнено(ПрикладноеПредставлениеРеквизита) Тогда
				ПрикладноеПредставлениеРеквизита = ПрикладноеПредставлениеПоСтрокеДерева(СтрокаДерева, НомерСтрокиДанных);
			КонецЕсли;

			ТекстОшибки = СтрШаблон("%1: %2", ПрикладноеПредставлениеРеквизита, ТекстОшибки);
		КонецЕсли;
	Иначе
		ПараметрыОбработкиОшибки = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки();
	КонецЕсли;
	
	ДобавитьОшибку(Ошибки, ТекстОшибки, ПараметрыОбработкиОшибки);

КонецПроцедуры

// Формирует дерево данных для заполнения или чтения прикладным решением.
//
// Параметры:
//  Макет - Макет - Макет с описанием структуры дерева (см. Обработка.ОбменСКонтрагентами.Макеты).
//
// Возвращаемое значение:
//  ДеревоЗначений - Дерево документа.
//
Функция ДеревоЭлектронногоДокумента(Макет) Экспорт
	
	ВысотаТаблицы = Макет.ВысотаТаблицы;
	ШиринаТаблицы = Макет.ШиринаТаблицы;
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	// Считаем колонки из макета и добавим их в таблицу значений.
	Для НомерКолонки = 1 По ШиринаТаблицы Цикл
		ОбластьШапки = Макет.Область(5,НомерКолонки);
		Если Не ЗначениеЗаполнено(ОбластьШапки.Текст) Тогда
			ОбластьШапки = Макет.Область(4,НомерКолонки);
		КонецЕсли;
		НазваниеКолонки = ОбластьШапки.Текст;
		ТаблицаЗначений.Колонки.Добавить(НазваниеКолонки);
	КонецЦикла;
	
	// Считаем все перечисленные в макете реквизиты и добавим в таблицу значений.
	Для НомерСтроки = 7 По ВысотаТаблицы Цикл
		НоваяСтрока = ТаблицаЗначений.Добавить();
		Для НомерКолонки = 0 По ШиринаТаблицы-1 Цикл
			НоваяСтрока.Установить(НомерКолонки, Макет.Область(НомерСтроки, НомерКолонки + 1).Текст);
		КонецЦикла;
		ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаЗначений, НоваяСтрока, Макет);
	КонецЦикла;
	
	// Добавим служебные колонки, не описанные в макете.
	ДобавитьСлужебныеКолонкиВТаблицуДереваДокумента(ТаблицаЗначений);
	
	// Добавим некоторые колонки при необходимости (для совместимости с макетами старого формата).
	КолонкиДереваДокумента = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.КолонкиДереваДокумента();
	Для Каждого Колонка Из КолонкиДереваДокумента Цикл
		Если ТаблицаЗначений.Колонки.Найти(Колонка) = Неопределено Тогда
			ТаблицаЗначений.Колонки.Добавить(Колонка);
		КонецЕсли;
	КонецЦикла;
	
	КолУровней = 0;
	
	// Перенесем колонки в дерево значений и заодно вычислим максимальный уровень.
	ДеревоЗначений = Новый ДеревоЗначений;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		ДеревоЗначений.Колонки.Добавить(Колонка.Имя);
		Если СтрНайти(Колонка.Имя, "Уровень") > 0 Тогда
			НомерУровня = Число(Сред(Колонка.Имя, 8, 2));
			Если НомерУровня > КолУровней Тогда
				КолУровней = НомерУровня;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Рекурсивно заполним дерево по таблице.
	ПолныйПуть = "";
	РекурсивноЗаполнитьСтрокиДерева(ДеревоЗначений, 1, КолУровней, ПолныйПуть, ТаблицаЗначений, 0);
	
	Возврат ДеревоЗначений;
	
КонецФункции

// Значение реквизита строки дерева разбора.
//
// Параметры:
//  ДеревоРазбора	 - ДеревоЗначений - объект поиска.
//  СтрокаДерева	 - КоллекцияСтрокДереваЗначений - строка дерева значений.
//  ПутьКРеквизиту	 - Строка - путь к реквизиту.
// 
// Возвращаемое значение:
//  Произвольный - результат поиска.
//
Функция ЗначениеРеквизитаСтрокиДереваРазбора(ДеревоРазбора, СтрокаДерева, ПутьКРеквизиту) Экспорт
	
	ПозТочки = СтрНайти(ПутьКРеквизиту, ".");
	Если ПозТочки > 0 Тогда
		ИмяГлавногоРеквизита     = Лев(ПутьКРеквизиту, ПозТочки - 1);
		ИмяПодчиненногоРеквизита = Прав(ПутьКРеквизиту, СтрДлина(ПутьКРеквизиту) - ПозТочки);
	Иначе
		ИмяГлавногоРеквизита     = ПутьКРеквизиту;
		ИмяПодчиненногоРеквизита = "";
	КонецЕсли;
	
	ГлавныйРеквизит = СтрокаДерева.Строки.Найти(ИмяГлавногоРеквизита, "Реквизит");
	
	Если ГлавныйРеквизит <> Неопределено Тогда
		ЗначениеГлавногоРеквизита = ГлавныйРеквизит.ЗначениеРеквизита;
		Если ИмяПодчиненногоРеквизита <> "" Тогда
			СтрокаПоСсылке = Неопределено;
			Если ЭтоСсылочноеЗначениеДереваРазбора(ДеревоРазбора, ЗначениеГлавногоРеквизита, СтрокаПоСсылке) Тогда
				Возврат ЗначениеРеквизитаСтрокиДереваРазбора(ДеревоРазбора, СтрокаПоСсылке, ИмяПодчиненногоРеквизита);
			КонецЕсли;
			
			// Нет возможности получить значение подчиненного реквизита.
			Возврат Неопределено;
		Иначе
			// Не требуется получать значение подчиненного реквизита.
			Возврат ЗначениеГлавногоРеквизита
		КонецЕсли;
	Иначе
		// Нет такого реквизита.
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// См. ЭлектронноеВзаимодействие.ДанныеЭлементаДереваЭлектронногоДокумента
Функция ДанныеЭлементаДереваЭлектронногоДокумента(Знач Дерево, Знач Путь) Экспорт
	
	ЭлементДерева = Дерево.Строки.Найти(Путь, "ПолныйПуть", Истина);
	Если ЭлементДерева = Неопределено Тогда
		ВызватьИсключение СформироватьТекстИсключения(
			"НедопустимыеПараметрыМетода", "ДанныеЭлементаДереваЭлектронногоДокумента/НеверноеЗначениеПараметра/Путь");
	КонецЕсли;
	
	Данные = Неопределено;
	
	Если ЭлементДерева.Признак = "Таблица" Тогда
		
		Данные = ДанныеТаблицыДереваЭлектронногоДокумента(ЭлементДерева);
		
	ИначеЕсли ЭлементДерева.Признак = "Группа" Тогда
		
		Данные = ДанныеГруппыДереваЭлектронногоДокумента(ЭлементДерева);
		
	ИначеЕсли ЭлементДерева.Признак = "Выбор" Тогда
		
		Данные = ДанныеВыбораДереваЭлектронногоДокумента(ЭлементДерева);
		
	Иначе
		
		Данные = ДанныеЗначенияДереваЭлектронногоДокумента(ЭлементДерева);
		
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

#КонецОбласти

#Область ОбработкаСхемыЗапросов

// Объединить запросы.
//
// Параметры:
//  Запрос1	 - Запрос - запрос приемник.
//  Запрос2	 - Запрос, Строка - запрос источник.
//
Процедура ОбъединитьЗапросы(ЗапросПриемник, ЗапросТекстИсточник) Экспорт 
	
	Схема1 = Новый СхемаЗапроса;
	Схема1.УстановитьТекстЗапроса(ЗапросПриемник.Текст);
	
	Схема2 = Новый СхемаЗапроса;
	Если ТипЗнч(ЗапросТекстИсточник) = Тип("Строка") Тогда
		Схема2.УстановитьТекстЗапроса(ЗапросТекстИсточник);
	Иначе
		// Вариант запроса.
		Схема2.УстановитьТекстЗапроса(ЗапросТекстИсточник.Текст);
		Для каждого ЭлементКоллекции Из ЗапросТекстИсточник.Параметры Цикл
			ЗапросПриемник.Параметры.Добавить(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Для каждого ЭлементКоллекции2 Из Схема2.ПакетЗапросов Цикл
		
		ИндексЗапроса2 = Схема2.ПакетЗапросов.Индекс(ЭлементКоллекции2);
		ПакетДобавлен = Ложь;
		Для каждого ЭлементКоллекции1 Из Схема1.ПакетЗапросов Цикл
			Если ТипЗнч(ЭлементКоллекции1) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				Продолжить;
			КонецЕсли;
			
			Представление1 = ЭлементКоллекции1.Представление();
			Представление2 = ЭлементКоллекции1.Представление();
			ТаблицаПомещения1 = "";
			ТаблицаПомещения2 = "";
			
			Если ТипЗнч(ЭлементКоллекции1) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				ПсевдонимИсточника1 = ЭлементКоллекции1.ИмяТаблицы;
			Иначе
				ПсевдонимИсточника1 = ЭлементКоллекции1.Операторы[0].Источники[0].Источник.Псевдоним;
				ТаблицаПомещения1   = ЭлементКоллекции1.ТаблицаДляПомещения;
			КонецЕсли;
			
			Если ТипЗнч(ЭлементКоллекции2) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				ПсевдонимИсточника2 = ЭлементКоллекции2.ИмяТаблицы;
			Иначе
				ПсевдонимИсточника2 = ЭлементКоллекции2.Операторы[0].Источники[0].Источник.Псевдоним;
				ТаблицаПомещения2   = ЭлементКоллекции2.ТаблицаДляПомещения;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Представление1)
				И ПсевдонимИсточника1 = ПсевдонимИсточника2
				И ТаблицаПомещения1 = ТаблицаПомещения2 Тогда
				ОбъединитьПакетЗапросов(ЭлементКоллекции1, Схема2.ПакетЗапросов.Получить(ИндексЗапроса2));
				ПакетДобавлен = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Не ПакетДобавлен Тогда
			// Добавление подзапроса в запрос приемник.
			ДобавитьЗапросВПакет(Схема1, ЭлементКоллекции2);
		КонецЕсли;
		
	КонецЦикла;
	
	ЗапросПриемник.Текст = Схема1.ПолучитьТекстЗапроса();
	
КонецПроцедуры

#КонецОбласти

// Получает файл из Интернета по протоколу http(s), либо ftp и сохраняет его во временное хранилище.
// Примечание: После получения файла временное хранилище необходимо самостоятельно очистить
// при помощи метода УдалитьИзВременногоХранилища. Если этого не сделать, то файл будет находиться
// в памяти сервера до конца сеанса.
//
// Параметры:
//   URL                - Строка - url файла в формате [Протокол://]<Сервер>/<Путь к файлу на сервере>.
//   ПараметрыПолучения - Структура - см. ПолучениеФайловИзИнтернетаКлиентСервер.ПараметрыПолученияФайла.
//   ПараметрыЖурналирования - Неопределено - журналирования не требуется
//                           - Структура - Необходимо вести журнал обмена. Содержит поля:
//                               * ОбщийМодуль - ОбщийМодуль - общий модуль, методы которого будут вызываться для сохранения журнала:
//                                   - Перед отправкой данных вызывается ОбщийМодуль.ПриОтправкеДанныхHTTP(URL, HTTPСоединение, HTTPЗапрос, ПараметрыЖурналирования)
//                                   - После получения ответа вызывается: ОбщийМодуль.ПриПолученииДанныхHTTP(HTTPОтвет, ИмяФайла, ПараметрыЖурналирования)
//
// Возвращаемое значение:
//   Структура - Структура со свойствами:
//      * Статус            - Булево - результат получения файла.
//      * Путь   - Строка   - адрес временного хранилища с двоичными данными файла,
//                            ключ используется только если статус Истина.
//      * СообщениеОбОшибке - Строка - сообщение об ошибке, если статус Ложь.
//      * Заголовки         - Соответствие - см. в синтаксис-помощнике описание параметра Заголовки объекта HTTPОтвет.
//      * КодСостояния      - Число - Добавляется при возникновении ошибки.
//                                    См. в синтаксис-помощнике описание параметра КодСостояния объекта HTTPОтвет.
//
Функция СкачатьФайлВоВременноеХранилище(Знач URL, ПараметрыПолучения = Неопределено, ПараметрыЖурналирования = Неопределено) Экспорт
	
	НастройкаСохранения = Новый Соответствие;
	НастройкаСохранения.Вставить("МестоХранения", "ВременноеХранилище");
	
	Возврат СкачатьФайл(URL, ПараметрыПолучения, НастройкаСохранения, ПараметрыЖурналирования);
	
КонецФункции

// Возвращает текст расшифровки кода состояния HTTP
//
// Параметры:
//  КодСостояния - Число - код состояния HTTP
// 
// Возвращаемое значение:
//  Строка - подробное описание кода.
//
Функция РасшифровкаКодаСостоянияHTTP(КодСостояния) Экспорт
	
	Если КодСостояния = 304 Тогда // Not Modified
		Расшифровка = НСтр("ru='Нет необходимости повторно передавать запрошенные ресурсы.';uk='Немає необхідності повторно передавати потрібні ресурси.'");
	ИначеЕсли КодСостояния = 400 Тогда // Bad Request
		Расшифровка = НСтр("ru='Запрос не может быть исполнен.';uk='Запит не може бути виконаний.'");
	ИначеЕсли КодСостояния = 401 Тогда // Unauthorized
		Расшифровка = НСтр("ru='Попытка авторизации на сервере была отклонена.';uk='Спроба авторизації на сервері була відхилена.'");
	ИначеЕсли КодСостояния = 402 Тогда // Payment Required
		Расшифровка = НСтр("ru='Требуется оплата.';uk='Потрібна оплата.'");
	ИначеЕсли КодСостояния = 403 Тогда // Forbidden
		Расшифровка = НСтр("ru='К запрашиваемому ресурсу нет доступа.';uk='До запитуваного ресурсу немає доступу.'");
	ИначеЕсли КодСостояния = 404 Тогда // Not Found
		Расшифровка = НСтр("ru='Запрашиваемый ресурс не найден на сервере.';uk='Запитаний ресурс не знайдено на сервері.'");
	ИначеЕсли КодСостояния = 405 Тогда // Method Not Allowed
		Расшифровка = НСтр("ru='Метод запроса не поддерживается сервером.';uk='Метод азпиту не підтримується сервером.'");
	ИначеЕсли КодСостояния = 406 Тогда // Not Acceptable
		Расшифровка = НСтр("ru='Запрошенный формат данных не поддерживается сервером.';uk='Запитаний формат даних не підтримується сервером.'");
	ИначеЕсли КодСостояния = 407 Тогда // Proxy Authentication Required
		Расшифровка = НСтр("ru='Ошибка аутентификации на прокси-сервере';uk='Помилка автентифікації проксі'");
	ИначеЕсли КодСостояния = 408 Тогда // Request Timeout
		Расшифровка = НСтр("ru='Время ожидания сервером передачи от клиента истекло.';uk='Час очікування сервером передачі від клієнта минув.'");
	ИначеЕсли КодСостояния = 409 Тогда // Conflict
		Расшифровка = НСтр("ru='Запрос не может быть выполнен из-за конфликтного обращения к ресурсу.';uk='Запит не може бути виконаний через конфліктне звернення до ресурсу.'");
	ИначеЕсли КодСостояния = 410 Тогда // Gone
		Расшифровка = НСтр("ru='Ресурс на сервере был перемешен.';uk='Ресурс на сервері було переміщено.'");
	ИначеЕсли КодСостояния = 411 Тогда // Length Required
		Расшифровка = НСтр("ru='Сервер требует указание ""Content-length."" в заголовке запроса.';uk='Сервер вимагає зазначення ""Content-length."" в заголовку запиту.'");
	ИначеЕсли КодСостояния = 412 Тогда // Precondition Failed
		Расшифровка = НСтр("ru='Запрос не применим к ресурсу';uk='Запит не можна застосувати до ресурсу'");
	ИначеЕсли КодСостояния = 413 Тогда // Request Entity Too Large
		Расшифровка = НСтр("ru='Сервер отказывается обработать, слишком большой объем передаваемых данных.';uk='Сервер відмовляється обробити, занадто великий обсяг переданих даних.'");
	ИначеЕсли КодСостояния = 414 Тогда // Request-URL Too Long
		Расшифровка = НСтр("ru='Сервер отказывается обработать, слишком длинный URL.';uk='Сервер відмовляється обробити, занадто довгий URL.'");
	ИначеЕсли КодСостояния = 415 Тогда // Unsupported Media-Type
		Расшифровка = НСтр("ru='Сервер заметил, что часть запроса была сделана в неподдерживаемом формат';uk='Сервер зауважив, що частина запиту була зроблена в неподдерживаемом формат'");
	ИначеЕсли КодСостояния = 416 Тогда // Requested Range Not Satisfiable
		Расшифровка = НСтр("ru='Часть запрашиваемого ресурса не может быть предоставлена';uk='Частина запитуваного ресурсу не може бути надана'");
	ИначеЕсли КодСостояния = 417 Тогда // Expectation Failed
		Расшифровка = НСтр("ru='Сервер не может предоставить ответ на указанный запрос.';uk='Сервер не може надати відповідь на зазначений запит.'");
	ИначеЕсли КодСостояния = 429 Тогда // Too Many Requests
		Расшифровка = НСтр("ru='Слишком много запросов за короткое время.';uk='Занадто багато запитів за короткий час.'");
	ИначеЕсли КодСостояния = 500 Тогда // Internal Server Error
		Расшифровка = НСтр("ru='Внутренняя ошибка сервера.';uk='Внутрішня помилка сервера.'");
	ИначеЕсли КодСостояния = 501 Тогда // Not Implemented
		Расшифровка = НСтр("ru='Сервер не поддерживает метод запроса.';uk='Сервер не підтримує метод запиту.'");
	ИначеЕсли КодСостояния = 502 Тогда // Bad Gateway
		Расшифровка = НСтр("ru='Сервер, выступая в роли шлюза или прокси-сервера, 
|получил недействительное ответное сообщение от вышестоящего сервера.'
|;uk='Сервер, виступаючи в ролі шлюзу або проксі-сервера, 
|отримав недійсну відповідь на повідомлення від вищестоящого сервера.'");
	ИначеЕсли КодСостояния = 503 Тогда // Server Unavailable
		Расшифровка = НСтр("ru='Сервер временно не доступен.';uk='Сервер тимчасово не доступний.'");
	ИначеЕсли КодСостояния = 504 Тогда // Gateway Timeout
		Расшифровка = НСтр("ru='Сервер в роли шлюза или прокси-сервера 
|не дождался ответа от вышестоящего сервера для завершения текущего запроса.'
|;uk='Сервер в ролі шлюзу або проксі-сервера 
|не дочекався відповіді від вищестоящого сервера для завершення поточного запиту.'");
	ИначеЕсли КодСостояния = 505 Тогда // HTTP Version Not Supported
		Расшифровка = НСтр("ru='Сервер не поддерживает указанную в запросе версию протокола HTTP';uk='Сервер не підтримує вказану в запиті версію протоколу HTTP'");
	ИначеЕсли КодСостояния = 506 Тогда // Variant Also Negotiates
		Расшифровка = НСтр("ru='Сервер настроен некорректно, и не способен обработать запрос.';uk='Сервер налаштований некоректно, і не здатний обробити запит.'");
	ИначеЕсли КодСостояния = 507 Тогда // Insufficient Storage
		Расшифровка = НСтр("ru='На сервере недостаточно места для выполнения запроса.';uk='На сервері недостатньо місця для виконання запиту.'");
	ИначеЕсли КодСостояния = 509 Тогда // Bandwidth Limit Exceeded
		Расшифровка = НСтр("ru='Сервер превысил отведенное ограничение на потребление трафика.';uk='Сервер перевищив відведене обмеження на споживання трафіка.'");
	ИначеЕсли КодСостояния = 510 Тогда // Not Extended
		Расшифровка = НСтр("ru='Сервер требует больше информации о совершаемом запросе.';uk='Сервер вимагає більше інформації про здійснюваний запит.'");
	ИначеЕсли КодСостояния = 511 Тогда // Network Authentication Required
		Расшифровка = НСтр("ru='Требуется авторизация на сервере.';uk='Потрібна авторизація на сервері.'");
	Иначе 
		Расшифровка = НСтр("ru='<Неизвестный код состояния>.';uk='<Невідомий код стану>.'");
	КонецЕсли;
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru='[%1] %2';uk='[%1] %2'"), 
		КодСостояния, 
		Расшифровка);
	
КонецФункции

// Создает структуру, описывающую выполняемую операцию. Используется в процедурах: ЭлектронноеВзаимодействиеОбработкаОшибок.ДобавитьОшибку,
// ЭлектронноеВзаимодействиеОбработкаОшибокКлиент.ДобавитьОшибку, ЭлектронноеВзаимодействиеОбработкаОшибок.ОбработатьОшибки.
// В структуру нельзя помещать мутабельные объекты, т.к. она может передаваться между клиентом и сервером.
// 
// Возвращаемое значение:
//   Структура - с ключами:
//      * ЗаголовокОперации           - Строка - заголовок, который будет выведен в форму мастера диагностики и в форму
//                                               вывода ошибок.
//      * Диагностика                 - Структура - с ключами:
//         * Ошибки                   - Массив из см. ЭлектронноеВзаимодействиеОбработкаОшибокКлиентСервер.НоваяОшибка - ошибки,
//                                               возникшие в процессе выполнения операции.
//      * ТекущаяУчетнаяЗапись        - Строка - идентификатор учетной записи, по которой возникла ошибка, используется
//                                               для управления свойством "УчетнаяЗапись" добавляемых ошибок.
//                                               После установки значения этого свойства, свойству "УчетнаяЗапись" ошибок,
//                                               добавленных в контекст будет присвоено значение свойства "ТекущаяУчетнаяЗапись".
//      * РезультатыОтправкиПолучения - Структура - с ключами:
//         * Успешные                 - Массив из ДокументСсылка.ЭлектронныйДокументВходящий - содержит ссылки на успешно
//                                               отправленные/полученные электронные документы документы или пакеты электронных
//                                               документов.
//         * -- // --                 - Массив из ДокументСсылка.ЭлектронныйДокументИсходящий - описание см. выше.
//         * -- // --                 - Массив из ДокументСсылка.ПакетЭД - описание см. выше.
//         * Неудачные                - Массив - содержит ссылки на неудачно отправленные/полученные документы, типы параметров
//                                               как у ключа Успешные.
//
Функция НовыйКонтекстОперации() Экспорт
	
	Контекст = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыйКонтекстОперации();
	Контекст.Вставить("ДатаНачалаОперации", ТекущаяДатаСеанса());
	
	Возврат Контекст;
	
КонецФункции

#Область Диагностика

// Вызывается при формировании файла с информацией для техподдержки.
//
// Параметры:
//  Текст                    - Строка - текст с описанием параметров системы, вида: "Имя параметра: [ЗначениеПараметра]".
//                                      Значения параметров заполняется из параметра ТехническаяИнформация.
//  ТехническаяИнформация    - Структура - содержит значения параметров для подстановки в текст с описанием
//                                      параметров системы, см. параметр Текст.
//
// Пример:
// Текст = Текст + "Дополнительный параметр: [ДополнительныйПараметр]";
// ТехническаяИнформация.Вставить("ДополнительныйПараметр", "значение дополнительного параметра");
//
Процедура ПриФормированииФайлаСИнформациейДляТехподдержки(Текст, ТехническаяИнформация) Экспорт
	
	// ОбменСКонтрагентами начало
	Если ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСКонтрагентами") Тогда
		МодульПодсистемы = ОбщегоНазначения.ОбщийМодуль("ОбменСКонтрагентамиСлужебный");
		МодульПодсистемы.ПриФормированииФайлаСИнформациейДляТехподдержки(Текст, ТехническаяИнформация);
	КонецЕсли;
	// ОбменСКонтрагентами конец
	
КонецПроцедуры

// Вызывается при формировании архива с информацией для техподдержки.
//
// Параметры:
//  ФайлыДляТехподдержки - Массив из Строка - содержит пути к файлам на сервере, которые будут помещены в архив
//                                  с информацией для техподдержки
//
// Пример:
// ИмяФайла = ПолучитьИмяВременногоФайла("zip");
// ПакетЭД.Записать(ИмяФайла);
// ФайлыДляТехподдержки.Добавить(ПакетЭД);
//
Процедура ПриФормированииФайловДляТехподдержки(ФайлыДляТехподдержки, КонтекстОперации) Экспорт
	
	// ОбменСКонтрагентами начало
	Если ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСКонтрагентами") Тогда
		МодульПодсистемы = ОбщегоНазначения.ОбщийМодуль("ОбменСКонтрагентамиСлужебный");
		МодульПодсистемы.ПриФормированииФайловДляТехподдержки(ФайлыДляТехподдержки, КонтекстОперации);
	КонецЕсли;
	// ОбменСКонтрагентами конец
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ЭтоСсылочноеЗначениеДереваРазбора(ДеревоРазбора, Значение, СтрокаПоСсылке = Неопределено)
	
	ЗначениеСтрокой = Строка(Значение);
	
	Если СтрНайти(ЗначениеСтрокой, "_") > 0 Тогда
		СтрокаПоСсылке =  ДеревоРазбора.Строки.Найти(ЗначениеСтрокой, "ИндексСтроки", Истина);
	КонецЕсли;
	
	Возврат ?(СтрокаПоСсылке = Неопределено, Ложь, Истина);
	
КонецФункции

// Создает пустую таблицу для размещения в нее команд ЭДО.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - описание команд ЭДО:
//
//  * Идентификатор - Строка - Идентификатор команды ЭДО, по которому менеджер ЭДО определяет печатную
//                             форму, которую необходимо сформировать.
//                             Пример: "СчетЗаказ".
//                  - Массив - список идентификаторов команд ЭДО.
//
//  * Представление - Строка            - Представление команды в меню ЭДО. 
//                                         Пример: "Просмотр документа".
//
//  * Обработчик    - Строка            - (необязательный) Клиентский обработчик команды, в который необходимо передать
//                                        управление.
//
//  * Порядок       - Число             - (необязательный) Значение от 1 до 100, указывающее порядок размещения команды
//                                        по отношению к другим командам. Сортировка команд меню ЭДО осуществляется
//                                        сначала по полю Порядок, затем по представлению.
//                                        Значение по умолчанию: 50.
//
//  * Картинка      - Картинка          - (необязательный) Картинка, которая отображается возле команды в меню ЭДО.
//                                         Пример: БиблиотекаКартинок.ФорматPDF.
//
//  * СписокФорм    - Строка            - (необязательный) Имена форм через запятую, в которых должна отображаться
//                                        команда. Если параметр не указан, то команда ЭДО будет отображаться во
//                                        всех формах объекта, где встроена подсистема ЭДО.
//                                         Пример: "ФормаДокумента".
//
//  * МестоРазмещения - Строка          - (необязательный) Имя командной панели формы, в которую необходимо разместить
//                                        команду ЭДО. Параметр необходимо использовать только в случае, когда на
//                                        форме размещается более одного подменю "ЭДО". В остальных случаях место
//                                        размещения необходимо задавать в модуле формы при вызове метода.
//                                        
//  * ФункциональныеОпции - Строка      - (необязательный) Имена функциональных опций через запятую, от которых зависит
//                                        доступность команды ЭДО.
//
Функция СоздатьКоллекциюКомандЭДО()
	
	Результат = Новый ТаблицаЗначений;
	
	// описание
	Результат.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	
	//////////
	// Опции (необязательные параметры).
	
	// Альтернативный обработчик команды.
	Результат.Колонки.Добавить("Обработчик", Новый ОписаниеТипов("Строка"));
	
	// представление
	Результат.Колонки.Добавить("Порядок", Новый ОписаниеТипов("Число"));
	Результат.Колонки.Добавить("Картинка", Новый ОписаниеТипов("Картинка"));
	Результат.Колонки.Добавить("Отображение", Новый ОписаниеТипов("ОтображениеКнопки"));
	
	// Имена форм для размещения команд, разделитель - запятая.
	Результат.Колонки.Добавить("СписокФорм", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("МестоРазмещения", Новый ОписаниеТипов("Строка"));
	// Имена функциональных опций, влияющих на видимость команды, разделитель - запятая.
	Результат.Колонки.Добавить("ФункциональныеОпции", Новый ОписаниеТипов("Строка"));
	
	Результат.Колонки.Добавить("РежимИспользованияПараметра", Новый ОписаниеТипов("РежимИспользованияПараметраКоманды"));
	
	// дополнительные параметры
	Результат.Колонки.Добавить("ДополнительныеПараметры", Новый ОписаниеТипов("Структура"));
	
	// Специальный режим выполнения команды
	// по умолчанию выполняется запись модифицированного объекта перед выполнением команды.
	Результат.Колонки.Добавить("НеВыполнятьЗаписьВФорме", Новый ОписаниеТипов("Булево"));
	
	// Для служебного использования.
	Результат.Колонки.Добавить("СкрытаФункциональнымиОпциями", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("УникальныйИдентификатор", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("Отключена", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("УправлениеВидимостью", Новый ОписаниеТипов("Структура"));
	
	Результат.Колонки.Добавить("ТолькоВоВсехДействиях", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Недоступна", Новый ОписаниеТипов("Булево"));
	
	Возврат Результат;
	
КонецФункции

// Создает подменю "ЭДО" на форме и добавляет в него команды ЭДО.
// Если команда ЭДО одна, то вместо подменю добавляется кнопка с названием печатной формы.
Процедура ДобавитьКомандыЭДО(Форма, КомандыЭДО, Знач МестоРазмещенияКоманд = Неопределено)
	
	ПараметрыУправленияВидимостьюЭДО = Новый Структура("ЕстьУсловияВидимости, КомандыСУсловиямиВидимости", Ложь, Новый Массив);
	
	МестоРазмещения = МестоРазмещенияКоманд;
	Для Каждого ОписаниеКомандыЭДО Из КомандыЭДО Цикл
		
		// Отключение команды загрузки ЭД без ЭП в формах документов.
		Если ОписаниеКомандыЭДО.Идентификатор = "ЗагрузитьЧерезБизнесСеть" Тогда
			МассивРеквизитов = Форма.ПолучитьРеквизиты();
			ЭтоФормаОбъекта = Ложь;
			Для Каждого Реквизит Из МассивРеквизитов Цикл
				Если Реквизит.Имя = "Объект" Тогда
					ЭтоФормаОбъекта = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ЭтоФормаОбъекта Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		НомерКоманды = ОписаниеКомандыЭДО.Владелец().Индекс(ОписаниеКомандыЭДО);
		ИмяКоманды = МестоРазмещенияКоманд.Имя + ОписаниеКомандыЭДО.Идентификатор + НомерКоманды;
		
		КомандаФормы = Форма.Команды.Добавить(ИмяКоманды);
		КомандаФормы.Действие = "Подключаемый_ВыполнитьКомандуЭДО";
		КомандаФормы.Заголовок = ОписаниеКомандыЭДО.Представление;
		КомандаФормы.ИзменяетСохраняемыеДанные = Ложь;
		
		Если ЗначениеЗаполнено(ОписаниеКомандыЭДО.Отображение) Тогда 
			КомандаФормы.Отображение = ОписаниеКомандыЭДО.Отображение;
		Иначе 
			КомандаФормы.Отображение = ОтображениеКнопки.КартинкаИТекст;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ОписаниеКомандыЭДО.Картинка) Тогда
			КомандаФормы.Картинка = ОписаниеКомандыЭДО.Картинка;
		КонецЕсли;
		
		ОписаниеКомандыЭДО.ИмяКомандыНаФорме = ИмяКоманды;
		Видимость = Не ОписаниеКомандыЭДО.Недоступна;
		
		Если ОписаниеКомандыЭДО.УправлениеВидимостью.Свойство("Использовать")
			И ОписаниеКомандыЭДО.УправлениеВидимостью.Использовать
			И Видимость Тогда
			
			ПараметрыУправленияВидимостьюЭДО.ЕстьУсловияВидимости = Истина;
			УсловияВидимости = Новый Структура;
			УсловияВидимости.Вставить("ИмяВФорме", ИмяКоманды);
			УсловияВидимости.Вставить("ИмяРеквизитаУсловия", Неопределено);
			УсловияВидимости.Вставить("ИмяАлгоритмаПроверкиУсловия", Неопределено);
			УсловияВидимости.Вставить("ЗначениеУсловия", Неопределено);
			ЗаполнитьЗначенияСвойств(УсловияВидимости, ОписаниеКомандыЭДО.УправлениеВидимостью);
			
			ПараметрыУправленияВидимостьюЭДО.КомандыСУсловиямиВидимости.Добавить(УсловияВидимости);
			Видимость = Ложь;
		КонецЕсли;
		
		// Для платформенной команды ввода на основании не добавляем префикс, чтобы команды не отделялись чертой.
		Если ОписаниеКомандыЭДО.МестоРазмещения = "ФормаСоздатьНаОсновании" Тогда
			МестоРазмещенияИмя = ОписаниеКомандыЭДО.МестоРазмещения;
		Иначе
			МестоРазмещенияИмя = МестоРазмещенияКоманд.Имя + ОписаниеКомандыЭДО.МестоРазмещения;
		КонецЕсли;
	
		Если Форма.Элементы.Найти(МестоРазмещенияИмя) = Неопределено Тогда
			МестоРазмещения = Форма.Элементы.Добавить(МестоРазмещенияИмя, Тип("ГруппаФормы"), МестоРазмещения);
			МестоРазмещения.Вид = ВидГруппыФормы.ГруппаКнопок;
			МестоРазмещения.Заголовок = СтрЗаменить(ОписаниеКомандыЭДО.МестоРазмещения, "КомандыЭДО", "");
		КонецЕсли;
		
		НовыйЭлемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), МестоРазмещения);
		НовыйЭлемент.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели;
		НовыйЭлемент.ИмяКоманды = ИмяКоманды;
		НовыйЭлемент.Видимость = Видимость;
		НовыйЭлемент.ТолькоВоВсехДействиях = ОписаниеКомандыЭДО.ТолькоВоВсехДействиях;
		
	КонецЦикла;
	
	Если ПараметрыУправленияВидимостьюЭДО.ЕстьУсловияВидимости Тогда
		
		Проверка = Новый Структура("ПараметрыУправленияВидимостьюЭДО", NULL);
		ЗаполнитьЗначенияСвойств(Проверка, Форма);
		
		Если Проверка.ПараметрыУправленияВидимостьюЭДО <> NULL Тогда
			Если ТипЗнч(Форма.ПараметрыУправленияВидимостьюЭДО) = Тип("Структура") 
				И Форма.ПараметрыУправленияВидимостьюЭДО.Свойство("КомандыСУсловиямиВидимости") Тогда
				ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ПараметрыУправленияВидимостьюЭДО.КомандыСУсловиямиВидимости,
				Форма.ПараметрыУправленияВидимостьюЭДО.КомандыСУсловиямиВидимости, Истина)
			КонецЕсли;
		Иначе
			ДобавляемыеРеквизиты = Новый Массив;
			Реквизит = Новый РеквизитФормы("ПараметрыУправленияВидимостьюЭДО", Новый ОписаниеТипов());
			ДобавляемыеРеквизиты.Добавить(Реквизит);
			Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты);
			
		КонецЕсли;
		
		Форма.ПараметрыУправленияВидимостьюЭДО = ПараметрыУправленияВидимостьюЭДО;
		
	КонецЕсли;
	
КонецПроцедуры

// Фильтрует список команд ЭДО в соответствии с установленными функциональными опциями.
Процедура ОпределитьВидимостьКомандЭДОПоФункциональнымОпциям(КомандыЭДО, Форма = Неопределено)
	Для НомерКоманды = -КомандыЭДО.Количество() + 1 По 0 Цикл
		ОписаниеКомандыЭДО = КомандыЭДО[-НомерКоманды];
		ФункциональныеОпцииКомандыЭДО = СтрРазделить(ОписаниеКомандыЭДО.ФункциональныеОпции, ", ", Ложь);
		ВидимостьКоманды = ФункциональныеОпцииКомандыЭДО.Количество() = 0;
		Для Каждого ФункциональнаяОпция Из ФункциональныеОпцииКомандыЭДО Цикл
			Если ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
				ВидимостьКоманды = ВидимостьКоманды Или Форма.ПолучитьФункциональнуюОпциюФормы(ФункциональнаяОпция);
			Иначе
				ВидимостьКоманды = ВидимостьКоманды Или ПолучитьФункциональнуюОпцию(ФункциональнаяОпция);
			КонецЕсли;
			
			Если ВидимостьКоманды Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		ОписаниеКомандыЭДО.СкрытаФункциональнымиОпциями = Не ВидимостьКоманды;
	КонецЦикла;
КонецПроцедуры


#Область АвтоматизированноеТестированиеСлужебныеПроцедурыИФункции

// Присваивает имена параметризованным ячейкам переданной области
//
// Параметры:
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу.
//
Процедура ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, Знач ПрефиксДляИмен, Знач ИндексПрефикса)
	
	// Обойдем все ячейки выводимой области и заполним имена для ячеек, содержащих параметры.
	Для НомерСтроки = 1 По ОбластьМакета.ВысотаТаблицы Цикл
		Для НомерКолонки = 1 По ОбластьМакета.ШиринаТаблицы Цикл
			Ячейка = ОбластьМакета.Область(НомерСтроки, НомерКолонки);
			Если Ячейка.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр
				И ЗначениеЗаполнено(Ячейка.Параметр) Тогда
				Ячейка.Имя = ПрефиксДляИмен + ИндексПрефикса + "_" + Ячейка.Параметр;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область РаботаСДеревомДанныхСлужебныеПроцедурыИФункции

Функция ДанныеГруппыДереваЭлектронногоДокумента(Знач ГруппаДерева)
	
	Данные = Новый Структура;
	
	Для каждого СтрокаДерева Из ГруппаДерева.Строки Цикл
		
		ИмяПоля = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаДерева.ПолныйПуть);
		Значение = ДанныеЭлементаДереваЭлектронногоДокумента(ГруппаДерева, СтрокаДерева.ПолныйПуть);
		
		Данные.Вставить(ИмяПоля, Значение);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеВыбораДереваЭлектронногоДокумента(Знач ВыборДерева)
	
	Данные = Новый Структура;
	
	Для каждого СтрокаДерева Из ВыборДерева.Строки Цикл
		
		ИмяПоля = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаДерева.ПолныйПуть);
		Если ИмяПоля <> ВыборДерева.Значение Тогда
			Продолжить;
		КонецЕсли;
		Значение = ДанныеЭлементаДереваЭлектронногоДокумента(ВыборДерева, СтрокаДерева.ПолныйПуть);
		
		Данные.Вставить(ИмяПоля, Значение);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеТаблицыДереваЭлектронногоДокумента(Знач ТаблицаДерева)
	
	Данные = Новый ТаблицаЗначений;
	
	СтрокаНомерСтроки = ТаблицаДерева.Строки[0];
	Для Каждого СтрокаКолонки Из СтрокаНомерСтроки.Строки Цикл
		ИмяКолонки = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаКолонки.ПолныйПуть);
		Данные.Колонки.Добавить(ИмяКолонки);
	КонецЦикла;
	
	Если Не ЗначениеЗаполнено(ТаблицаДерева.Значение) Тогда
		Возврат Данные;
	КонецЕсли;
	
	Для Каждого СтрокаНомерСтроки Из ТаблицаДерева.Строки Цикл
		
		НоваяСтрока = Данные.Добавить();
		
		Для Каждого СтрокаКолонки Из СтрокаНомерСтроки.Строки Цикл
			
			ИмяКолонки = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаКолонки.ПолныйПуть);
			НоваяСтрока[ИмяКолонки] = ДанныеЭлементаДереваЭлектронногоДокумента(СтрокаНомерСтроки, СтрокаКолонки.ПолныйПуть);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеЗначенияДереваЭлектронногоДокумента(Знач ЗначениеДерева)
	
	Значение = ЗначениеДерева.Значение;
	
	Если Не ЗначениеЗаполнено(Значение) Тогда
		
		Если ЗначениеДерева.Типы = "Строка" Тогда
			Значение = "";
		ИначеЕсли ЗначениеДерева.Типы = "Число" Тогда
			Значение = 0;
		ИначеЕсли ЗначениеДерева.Типы = "Дата" Тогда
			Значение = Дата(1, 1, 1);
		Иначе
			Значение = Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Формирует прикладное представление реквизита дерева электронного документа.
//
// Параметры:
//  СтрокаДереваДанных	 - СтрокаДереваЗначений - строка реквизита дерева электронного документа.
//  НомерСтрокиДанных	 - Число - номер строки, который будет подставлен по возможности в представление.
// 
// Возвращаемое значение:
//  Строка - прикладное представление реквизита дерева.
//
Функция ПрикладноеПредставлениеПоСтрокеДерева(СтрокаДереваДанных, НомерСтрокиДанных = Неопределено)
	
	ШаблонПрикладногоПредставления = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ПрикладноеПредставлениеРеквизита(
		СтрокаДереваДанных.КодПредставления);
		
	Если НомерСтрокиДанных = Неопределено Тогда
		ПрикладноеПредставление = ШаблонПрикладногоПредставления;
	Иначе
		Если СтрНайти(ШаблонПрикладногоПредставления, "%1") > 0 Тогда
			ПрикладноеПредставление = СтрШаблон(ШаблонПрикладногоПредставления, Формат(НомерСтрокиДанных, "ЧГ="));
		Иначе
			ПрикладноеПредставление = ШаблонПрикладногоПредставления;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПрикладноеПредставление) Тогда
		ПрикладноеПредставление = СтрЗаменить(СтрокаДереваДанных.ПолныйПуть, ".", " - ");
		
		Если ЗначениеЗаполнено(НомерСтрокиДанных) Тогда
			ПрикладноеПредставление = СтрШаблон("%1(%2)", ПрикладноеПредставление, Формат(НомерСтрокиДанных, "ЧГ="));
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПрикладноеПредставление;

КонецФункции

Функция ПараметрыОбработкиОшибкиУказаны(СтрокаДерева)

	Результат = Ложь;
	
	Если СтрокаДерева <> Неопределено Тогда
		Результат = ЗначениеЗаполнено(СтрокаДерева.ТекстОшибки)
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.ПутьКДаннымСообщения) И СтрокаДерева.КлючСообщения <> Неопределено
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.НавигационнаяСсылка)
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.ИмяФормы);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции 

Функция ПараметрыОшибкиПоСтрокеДерева(СтрокаДерева)

	ДанныеОшибки = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки(СтрокаДерева.КлючСообщения,
		СтрокаДерева.ПутьКДаннымСообщения, СтрокаДерева.НавигационнаяСсылка, СтрокаДерева.ИмяФормы, 
		СтрокаДерева.ПараметрыФормы, СтрокаДерева.ТекстОшибки);
	
	Возврат ДанныеОшибки;

КонецФункции

Функция ПолучитьПредставлениеТипаПоСтрокеДерева(Строка, ДатаПоФорматуФНС = Ложь)

	ОписанияСтроками = Новый Массив;
	
	ОписаниеТипа = Строка.ТипЗначения;
	Для Каждого Тип Из ОписаниеТипа.Типы() Цикл
		ПредставлениеТипа = НРег(Строка(Тип));
		
		Если Тип = Тип("Строка") Тогда
			Если ОписаниеТипа.КвалификаторыСтроки.Длина > 0 Тогда
				Если ОписаниеТипа.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная Тогда
					ПредставлениеСтроки = СтрШаблон(НСтр("ru='до %1 символов';uk='до %1 символів'"), ОписаниеТипа.КвалификаторыСтроки.Длина);
				Иначе
					ПредставлениеСтроки = СтрШаблон(НСтр("ru='%1 символов';uk='%1 символів'"), ОписаниеТипа.КвалификаторыСтроки.Длина);
				КонецЕсли;
				
				ПредставлениеТипа = СтрШаблон(НСтр("ru='%1 %2';uk='%1 %2'"), ПредставлениеТипа, ПредставлениеСтроки);
			КонецЕсли;
		ИначеЕсли Тип = Тип("Число") Тогда
			Если ОписаниеТипа.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный Тогда
				ПредставлениеТипа = СтрШаблон(НСтр("ru='неотрицательное %1';uk='невід''ємне %1'"), ПредставлениеТипа);
			КонецЕсли;
			
			Если ОписаниеТипа.КвалификаторыЧисла.Разрядность > 0 Тогда
				ПредставлениеТипа = СтрШаблон(НСтр("ru='%1 формата %2.%3';uk='%1 формату %2.%3'"), ПредставлениеТипа, 
					ОписаниеТипа.КвалификаторыЧисла.Разрядность - ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти,
					ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти);
			КонецЕсли;
		ИначеЕсли Тип = Тип("Дата") И ДатаПоФорматуФНС Тогда
			ПредставлениеТипа = СтрШаблон(НСтр("ru='%1 с 01.01.1900 до 31.12.2099 г.';uk='%1 з 01.01.1900 до 31.12.2099 р.'"), ПредставлениеТипа);
		КонецЕсли;
		
		ОписанияСтроками.Добавить(ПредставлениеТипа);
	КонецЦикла;
	
	Возврат СтрСоединить(ОписанияСтроками, " ИЛИ ");

КонецФункции

Процедура ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева)
	
	// Если при внедрении не указали параметры обработки ошибки для реквизитов, для которых это обязательно, будет выдано исключение.
	Если НРег(СтрокаДерева.ПараметрыОбработкиОбязательны) = "да" И Не ПараметрыОбработкиОшибкиУказаны(СтрокаДерева) Тогда
		ТекстИсключения = СтрШаблон(НСтр("ru='Не указаны параметры обработки ошибки для реквизита %1';uk='Не вказані параметри обробки помилки для реквізиту %1'"),
			СтрокаДерева.ПолныйПуть);
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

// Проверяет заполнение обязательных реквизитов дерева.
// Только для внутреннего использования.
// Параметры:
//  ДеревоДанных                            - деревоЗначений - дерево с данными.
//  Ошибки                                  - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                                     Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  ЭтоТаблица                              - Булево - если Истина, то проверяется табличная часть.
//  НомерСтроки                             - Число, Неопределено - номер проверяемой строки табличной части.
//  ПроверятьОбязательностьПараметровОшибки - Булево - определяет, нужно ли проверять, заданы ли параметры обработки ошибок
//                                                     в тех реквизитах, для которых это обязательно.
//  ДатаПоФорматуФНС                        - Булево - если установлена в Истину, значения типа "Дата" будут проверяться дополнительно
//                                                     на вхождение в диапазон лет 1900-2099 (требование схем ФНС).
//
Процедура ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(ДеревоДанных, Ошибки, ЭтоТаблица,
	НомерСтроки = Неопределено, ПроверятьОбязательностьПараметровОшибки = Истина, ДатаПоФорматуФНС = Ложь)
	
	НомерСтрокиДляПодстановки = ?(ЭтоТаблица, НомерСтроки, Неопределено);
	СтрокаДерева = Неопределено; // в этой переменной будем хранить последнюю считанную строку дерева данных
	
	Для Каждого СтрокаДерева Из ДеревоДанных.Строки Цикл
		ТекстОшибки = "";
		
		РеквизитЗаполненИлиОбязателен = ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ НРег(СтрокаДерева.Обязательное) = "да";
		
		// Проверяем заполнение самого реквизита.
		ПроверитьЗаполнениеРеквизитаДереваДанных(СтрокаДерева, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки);
	
		Если ЗначениеЗаполнено(ТекстОшибки) Тогда
			ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки,, НомерСтрокиДляПодстановки);
			
			Продолжить;
		КонецЕсли;
		
		// Запускаем проверки подчиненных реквизитов, если это структурированное значение.
		Если СтрокаДерева.Признак = "Таблица" И (ТипЗнч(СтрокаДерева.Значение) = Тип("Число") И СтрокаДерева.Значение > 0 ИЛИ СтрокаДерева.Обязательное = "Да")Тогда
			Для Каждого СтрокаТаблицы Из СтрокаДерева.Строки Цикл
				ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(СтрокаТаблицы, Ошибки, Истина, СтрокаТаблицы.Значение,
					РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
			КонецЦикла;
		ИначеЕсли СтрокаДерева.Признак = "Выбор" И (ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ СтрокаДерева.Обязательное = "Да") Тогда
			ПроверяемаяСтрока = СтрокаДерева.Строки.Найти(СтрокаДерева.ПолныйПуть + "." + СтрокаДерева.Значение, "ПолныйПуть");
			Если ЗначениеЗаполнено(ПроверяемаяСтрока) Тогда
				// Поскольку сменили текущую строку дерева, нужно проверить заполнение самого реквизита.
				ПроверитьЗаполнениеРеквизитаДереваДанных(ПроверяемаяСтрока, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки);
			
				Если ЗначениеЗаполнено(ТекстОшибки) Тогда
					ДобавитьОшибкуПроверкиДереваДанных(Ошибки, ПроверяемаяСтрока, ТекстОшибки,, НомерСтрокиДляПодстановки);
					
					Продолжить;
				КонецЕсли;
				
				ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(ПроверяемаяСтрока, Ошибки, Ложь,,
					РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
			Иначе
				ТекстОшибки = ТекстОшибкиНеЗаполненногоЗначенияДерева();
				
				ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки);
			КонецЕсли;
		ИначеЕсли СтрокаДерева.Признак = "Группа" И СтрокаДерева.Значение = Истина И СтрокаДерева.Строки.Количество() > 0 Тогда
			ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(СтрокаДерева, Ошибки, Ложь,,
				РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроверитьЗаполнениеРеквизитаДереваДанных(СтрокаДерева, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки)
	
	// Не проверяем, заполнены ли параметры обработки ошибок только если реквизит необязателен и не заполнен:
	// такая ситуация может возникнуть для условно-обязательных реквизитов. Для них параметры обработки ошибки могли быть
	// заданы только при заполнении реквизита. А поскольку заполнения не было, то и параметры не были указаны.
	РеквизитЗаполненИлиОбязателен = ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ НРег(СтрокаДерева.Обязательное) = "да";
	Если ПроверятьОбязательностьПараметровОшибки И РеквизитЗаполненИлиОбязателен Тогда
		ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева);
	КонецЕсли;
	
	// Проверим строку на заполненность, если реквизит обязательный.
	Если СтрокаДерева.Обязательное = "Да" И Не ЗначениеЗаполнено(СтрокаДерева.Значение) Тогда
		
		ТекстОшибки = ТекстОшибкиНеЗаполненногоЗначенияДерева();
		
		// Проверим строку на соответствие типу
	ИначеЕсли ЗначениеЗаполнено(СтрокаДерева.Значение) И СтрокаДерева.ТипЗначения <> Неопределено
		И Не ЗначениеВСтрокеДереваСоответствуетТипу(СтрокаДерева, ДатаПоФорматуФНС) Тогда
		
		ШаблонОшибки = НСтр("ru='неверный тип значения ""%1"" (ожидаемый тип: %2)';uk='невірний тип значення ""%1"" (очікуваний тип: %2)'");
		ПредставлениеТипаЗначения = ПолучитьПредставлениеТипаПоСтрокеДерева(СтрокаДерева, ДатаПоФорматуФНС);
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, СтрокаДерева.Значение,
		ПредставлениеТипаЗначения);
		
	КонецЕсли;
	
КонецПроцедуры

Функция ЗначениеВСтрокеДереваСоответствуетТипу(СтрокаДерева, ДатаПоФорматуФНС = Ложь)

	Результат = СтрокаДерева.ТипЗначения.ПривестиЗначение(СтрокаДерева.Значение) = СтрокаДерева.Значение;
	
	// Выполним дополнительную проверку для форматов ФНС.
	Если Результат И ДатаПоФорматуФНС И ТипЗнч(СтрокаДерева.Значение) = Тип("Дата") Тогда
		Если СтрокаДерева.Значение < Дата(1900, 1, 1) ИЛИ СтрокаДерева.Значение >= Дата(2100, 1, 1) Тогда
			Результат = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

Процедура ДобавитьСлужебныеКолонкиВТаблицуДереваДокумента(ТаблицаДерева)

	Колонки = Новый Массив;
	
	Колонки.Добавить("ТипЗначения");
	Колонки.Добавить("Значение");
	Колонки.Добавить("ПолныйПуть");
	Колонки.Добавить("ТекстОшибки");
	Колонки.Добавить("ПутьКДаннымСообщения");
	Колонки.Добавить("КлючСообщения");
	Колонки.Добавить("НавигационнаяСсылка");
	Колонки.Добавить("ИмяФормы");
	Колонки.Добавить("ПараметрыФормы");
	
	Для Каждого Колонка Из Колонки Цикл
		Если ТаблицаДерева.Колонки.Найти(Колонка) = Неопределено Тогда
			ТаблицаДерева.Колонки.Добавить(Колонка);
		КонецЕсли;
	КонецЦикла;
	
	// Сдвинем колонки "Значение" и "ПолныйПуть" в начало для удобства отладки.
	КолонкаЗначение = ТаблицаДерева.Колонки.Найти("Значение");
	ТаблицаДерева.Колонки.Сдвинуть("Значение", -ТаблицаДерева.Колонки.Индекс(КолонкаЗначение));
	КолонкаПолныйПуть = ТаблицаДерева.Колонки.Найти("ПолныйПуть");
	ТаблицаДерева.Колонки.Сдвинуть("ПолныйПуть", -ТаблицаДерева.Колонки.Индекс(КолонкаПолныйПуть));

КонецПроцедуры

Процедура РекурсивноЗаполнитьСтрокиДерева(ДеревоЗначений, Знач НомерУровня, КолУровней, Знач ПолныйПутьВДереве, ТЗ, НомерСтрокиТЗ)
	
	ЛокальныйПуть = ПолныйПутьВДереве;
	СтрокаТекУровня = Неопределено;
	Пока НомерСтрокиТЗ < ТЗ.Количество() Цикл
		СтрокаТЗ = ТЗ[НомерСтрокиТЗ];
		Для Сч = НомерУровня По КолУровней Цикл
			ИдТекУровня = "Уровень" + Сч;
			Если ТЗ.Колонки.Найти(ИдТекУровня) <> Неопределено И ЗначениеЗаполнено(СтрокаТЗ[ИдТекУровня]) Тогда
				Если НомерУровня < Сч Тогда
					РекурсивноЗаполнитьСтрокиДерева(СтрокаТекУровня, Сч, КолУровней, ЛокальныйПуть, ТЗ, НомерСтрокиТЗ);
				ИначеЕсли НомерУровня = Сч Тогда
					СтрокаТекУровня = ДеревоЗначений.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаТекУровня, СтрокаТЗ);
					СтрокаТекУровня.ТипЗначения = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ОписаниеТипаПоПараметрам(СтрокаТЗ.Типы, СтрокаТЗ.КвалификаторыЧисла, СтрокаТЗ.КвалификаторыСтроки, СтрокаТЗ.КвалификаторыДаты);
					ЛокальныйПуть = ?(ПолныйПутьВДереве = "", "", ПолныйПутьВДереве + ".") + СтрокаТекУровня["Уровень" + Сч];
					СтрокаТекУровня.ПолныйПуть = ЛокальныйПуть;
				КонецЕсли;
				НомерСтрокиТЗ = НомерСтрокиТЗ + 1;
				Прервать;
			КонецЕсли;
			Если Сч >= КолУровней Тогда
				НомерСтрокиТЗ = НомерСтрокиТЗ - 1;
				Возврат;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаМакета, СтрокаТаблицы, Макет)
	
	ИмяОбластиТипа = СтрокаТаблицы.Признак;
	
	Если Не ЗначениеЗаполнено(ИмяОбластиТипа) Тогда
		Возврат;
	КонецЕсли;
	Если Макет.Области.Найти(ИмяОбластиТипа) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МакетТипа = Макет.ПолучитьОбласть(ИмяОбластиТипа);
	
	ТаблицаТипа = ТаблицаМакета.СкопироватьКолонки();
	
	ВысотаТаблицы = МакетТипа.ВысотаТаблицы;
	ШиринаТаблицы = МакетТипа.ШиринаТаблицы;
	
	Для НомерСтроки = 1 По ВысотаТаблицы Цикл
		НоваяСтрока = ТаблицаТипа.Добавить();
		Для НомерКолонки = 1 По ШиринаТаблицы Цикл
			НоваяСтрока.Установить(НомерКолонки - 1, МакетТипа.Область(НомерСтроки, НомерКолонки).Текст);
		КонецЦикла;
		ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаТипа, НоваяСтрока, Макет);
	КонецЦикла;
	
	СдвигУровня = 0;
	СчетчикУровня = 1;
	Пока Истина Цикл
		ИмяКолонки = "Уровень" + Формат(СчетчикУровня, "ЧГ=0");
		Если ТаблицаМакета.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Прервать;
		КонецЕсли;
		ЗначениеКолонки = СтрокаТаблицы[ИмяКолонки];
		Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
			СдвигУровня = СчетчикУровня - 1;
			Прервать;
		КонецЕсли;
		СчетчикУровня = СчетчикУровня + 1;
	КонецЦикла;
	
	// Из первой строки берем только признак.
	СтрокаТаблицы.Признак = ТаблицаТипа[0].Признак;
	
	Для НомерСтроки = 2 По ТаблицаТипа.Количество() Цикл
		
		СтрокаТаблицыТипа = ТаблицаТипа[НомерСтроки - 1];
		СтрокаТаблицыМакета = ТаблицаМакета.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыМакета, СтрокаТаблицыТипа);
		
		Если ЗначениеЗаполнено(СтрокаТаблицы.КодПредставления)
			И ЗначениеЗаполнено(СтрокаТаблицыТипа.КодПредставления) Тогда
			СтрокаТаблицыМакета.КодПредставления = СтрШаблон("%1_%2", СтрокаТаблицы.КодПредставления, СтрокаТаблицыТипа.КодПредставления);
		КонецЕсли;
		
		// Вычислим текущий уровень.
		ТекущийУровень = 0;
		СчетчикУровня = 1;
		Пока Истина Цикл
			ИмяКолонки = "Уровень" + Формат(СчетчикУровня, "ЧГ=0");
			Если ТаблицаМакета.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				Прервать;
			КонецЕсли;
			ЗначениеКолонки = СтрокаТаблицыМакета[ИмяКолонки];
			Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
				ТекущийУровень = СчетчикУровня;
				Прервать;
			КонецЕсли;
			СчетчикУровня = СчетчикУровня + 1;
		КонецЦикла;
		// Сдвинем уровень.
		Если ЗначениеЗаполнено(СдвигУровня) Тогда
			НовыйУровень = ТекущийУровень + СдвигУровня;
			ИмяКолонкиТекущий = "Уровень" + Формат(ТекущийУровень, "ЧГ=0");
			ИмяКолонкиНовый = "Уровень" + Формат(НовыйУровень, "ЧГ=0");
			Если ТаблицаМакета.Колонки.Найти(ИмяКолонкиНовый) = Неопределено Тогда
				ТаблицаМакета.Колонки.Добавить(ИмяКолонкиНовый);
			КонецЕсли;
			СтрокаТаблицыМакета[ИмяКолонкиНовый] = СтрокаТаблицыМакета[ИмяКолонкиТекущий];
			СтрокаТаблицыМакета[ИмяКолонкиТекущий] = "";
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

Функция СкачатьФайл(Знач URL, Знач ПараметрыПолучения, Знач НастройкаСохранения, Знач ПараметрыЖурналирования)
	
	НастройкиПолучения = ПараметрыПолученияФайла();
	Если ПараметрыПолучения <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиПолучения, ПараметрыПолучения);
	КонецЕсли;
	
	Если НастройкаСохранения.Получить("МестоХранения") <> "ВременноеХранилище" Тогда
		НастройкаСохранения.Вставить("Путь", НастройкиПолучения.ПутьДляСохранения);
	КонецЕсли;
	
	НастройкаПроксиСервера = ПолучениеФайловИзИнтернета.НастройкиПроксиНаСервере();
	
	Перенаправления = Новый Массив;
	
	Возврат ПолучитьФайлИзИнтернет(URL, НастройкаСохранения, НастройкиПолучения,
		НастройкаПроксиСервера, Перенаправления, ПараметрыЖурналирования);
	
КонецФункции

Функция ПолучитьФайлИзИнтернет(Знач URL, Знач НастройкаСохранения, Знач НастройкаСоединения, Знач НастройкиПрокси, Перенаправления, ПараметрыЖурналирования)
	
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(URL);
	
	Сервер        = СтруктураURI.Хост;
	ПутьНаСервере = СтруктураURI.ПутьНаСервере;
	Протокол      = СтруктураURI.Схема;
	
	Если ПустаяСтрока(Протокол) Тогда 
		Протокол = "http";
	КонецЕсли;
	
	ЗащищенноеСоединение = НастройкаСоединения.ЗащищенноеСоединение;
	ИмяПользователя      = НастройкаСоединения.Пользователь;
	ПарольПользователя   = НастройкаСоединения.Пароль;
	Порт                 = НастройкаСоединения.Порт;
	Таймаут              = НастройкаСоединения.Таймаут;
	
	Если (Протокол = "https" Или Протокол = "ftps") И ЗащищенноеСоединение = Неопределено Тогда
		ЗащищенноеСоединение = Истина;
	КонецЕсли;
	
	Если ЗащищенноеСоединение = Истина Тогда
		ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение();
	ИначеЕсли ЗащищенноеСоединение = Ложь Тогда
		ЗащищенноеСоединение = Неопределено;
		// Иначе параметр ЗащищенноеСоединение был задан в явном виде.
	КонецЕсли;
	
	Если Порт = Неопределено Тогда
		Порт = СтруктураURI.Порт;
	КонецЕсли;
	
	Если НастройкиПрокси = Неопределено Тогда 
		Прокси = Неопределено;
	Иначе 
		Прокси = НовыйИнтернетПрокси(НастройкиПрокси, Протокол);
	КонецЕсли;
	
	Если НастройкаСохранения["Путь"] <> Неопределено Тогда
		ПутьДляСохранения = НастройкаСохранения["Путь"];
	Иначе
		// Временный файл должен удаляться вызывающим кодом.
		ПутьДляСохранения = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	Если Таймаут = Неопределено Тогда 
		Таймаут = АвтоматическоеОпределениеТаймаута();
	КонецЕсли;
	
	ИспользуетсяFTPПротокол = (Протокол = "ftp" Или Протокол = "ftps");
	
	Заголовки                    = НастройкаСоединения.Заголовки;
	ИспользоватьАутентификациюОС = НастройкаСоединения.ИспользоватьАутентификациюОС;
	
	Попытка
		
		Если Таймаут = АвтоматическоеОпределениеТаймаута() Тогда
			
			Соединение = Новый HTTPСоединение(
				Сервер, 
				Порт, 
				ИмяПользователя, 
				ПарольПользователя,
				Прокси, 
				7, 
				ЗащищенноеСоединение, 
				ИспользоватьАутентификациюОС);
			
			РазмерФайла = РазмерФайлаHTTP(Соединение, ПутьНаСервере, Заголовки);
			Таймаут = ТаймаутПоРазмеруФайла(РазмерФайла);
			
		КонецЕсли;
		
		Соединение = Новый HTTPСоединение(
			Сервер, 
			Порт, 
			ИмяПользователя, 
			ПарольПользователя,
			Прокси, 
			Таймаут, 
			ЗащищенноеСоединение, 
			ИспользоватьАутентификациюОС);
		
		Сервер = Соединение.Сервер;
		Порт   = Соединение.Порт;
		
		ЗапросHTTP = Новый HTTPЗапрос(ПутьНаСервере, Заголовки);
		ЗапросHTTP.Заголовки.Вставить("Accept-Charset", "UTF-8");
		ЗапросHTTP.Заголовки.Вставить("X-1C-Request-UID", Строка(Новый УникальныйИдентификатор));
		Если ПараметрыЖурналирования <> Неопределено Тогда
			ПараметрыЖурналирования.ОбщийМодуль.ПриОтправкеДанныхHTTP(
				"GET", URL, Соединение, ЗапросHTTP, ПараметрыЖурналирования);
		КонецЕсли;
		ОтветHTTP = Соединение.Получить(ЗапросHTTP, ПутьДляСохранения);
		
		Если ПараметрыЖурналирования <> Неопределено Тогда
			ПараметрыЖурналирования.ОбщийМодуль.ПриПолученииДанныхHTTP(ОтветHTTP, ПутьДляСохранения, ПараметрыЖурналирования);
		КонецЕсли;
		
	Исключение
		
		РезультатДиагностики = ПолучениеФайловИзИнтернета.ДиагностикаСоединения(URL);
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Не удалось установить HTTP-соединение с сервером %1:%2
|по причине:
|%3
|
|Результат диагностики:
|%4'
|;uk='Не вдалося встановити HTTP-з''єднання з сервером %1:%2
|з причини:
|%3
|
|Результат діагностики:
|%4'"),
			Сервер, Формат(Порт, "ЧГ="),
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			РезультатДиагностики.ОписаниеОшибки);
		
		ДописатьПредставлениеПеренаправлений(Перенаправления, ТекстОшибки);
		
		Возврат РезультатПолученияФайла(Ложь, ТекстОшибки);
		
	КонецПопытки;
	
	Попытка
		
		Если ОтветHTTP.КодСостояния = 301 // 301 Moved Permanently
			Или ОтветHTTP.КодСостояния = 302 // 302 Found, 302 Moved Temporarily
			Или ОтветHTTP.КодСостояния = 303 // 303 See Other by GET
			Или ОтветHTTP.КодСостояния = 307 // 307 Temporary Redirect
			Или ОтветHTTP.КодСостояния = 308 Тогда // 308 Permanent Redirect
			
			Если Перенаправления.Количество() > 7 Тогда
				ВызватьИсключение 
					НСтр("ru='Превышено количество перенаправлений.';uk='Перевищено кількість перенаправлень.'");
			Иначе 
				
				НовыйURL = ОтветHTTP.Заголовки["Location"];
				
				Если НовыйURL = Неопределено Тогда 
					ВызватьИсключение 
						НСтр("ru='Некорректное перенаправление, отсутствует HTTP-заголовок ответа ""Location"".';uk='Некоректне перенаправлення, відсутній HTTP-заголовок відповіді ""Location"".'");
				КонецЕсли;
				
				НовыйURL = СокрЛП(НовыйURL);
				
				Если ПустаяСтрока(НовыйURL) Тогда
					ВызватьИсключение 
						НСтр("ru='Некорректное перенаправление, пустой HTTP-заголовок ответа ""Location"".';uk='Некоректне перенаправлення, порожній HTTP-заголовок відповіді ""Location"".'");
				КонецЕсли;
				
				Если Перенаправления.Найти(НовыйURL) <> Неопределено Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru='Циклическое перенаправление.
|Попытка перейти на %1 уже выполнялась ранее.'
|;uk='Циклічне перенаправлення.
|Спроба перейти на %1 вже виконувалося раніше.'"),
						НовыйURL);
				КонецЕсли;
				
				Перенаправления.Добавить(URL);
				
				Если Не СтрНачинаетсяС(НовыйURL, "http") Тогда
					// <схема>://<хост>:<порт>/<путь>
					НовыйURL = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						"%1://%2:%3/%4", Протокол, Сервер, Формат(Порт, "ЧГ="), НовыйURL);
				КонецЕсли;
				
				Возврат ПолучитьФайлИзИнтернет(НовыйURL, НастройкаСохранения, НастройкаСоединения,
					НастройкиПрокси, Перенаправления, ПараметрыЖурналирования);
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ОтветHTTP.КодСостояния < 200 Или ОтветHTTP.КодСостояния >= 300 Тогда
			
			Если ОтветHTTP.КодСостояния = 304 Тогда
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Сервер убежден, что с вашего последнего запроса его ответ не изменился:
|%1'
|;uk='Сервер переконаний, що з вашого останнього запиту його відповідь не змінилася:
|%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			ИначеЕсли ОтветHTTP.КодСостояния < 200
				Или ОтветHTTP.КодСостояния >= 300 И ОтветHTTP.КодСостояния < 400 Тогда
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Неподдерживаемый ответ сервера:
|%1'
|;uk='Непідтримувана відповідь сервера:
|%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			ИначеЕсли ОтветHTTP.КодСостояния >= 400 И ОтветHTTP.КодСостояния < 500 Тогда 
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Ошибка при выполнении запроса:
|%1'
|;uk='Помилка при виконанні запиту:
|%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			Иначе 
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru='Ошибка сервера при обработке запроса к ресурсу:
|%1'
|;uk='Помилка сервера при обробці запиту до ресурсу:
|%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			КонецЕсли;
			
		КонецЕсли;
		
	Исключение
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Не удалось получить файл %1 с сервера %2:%3
|по причине:
|%4'
|;uk='Не вдалося отримати файл %1 з сервера %2:%3
|з причини:
|%4'"),
			URL, Сервер, Формат(Порт, "ЧГ="),
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ДописатьПредставлениеПеренаправлений(Перенаправления, ТекстОшибки);
		
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1
|
|Трассировка:
|ЗащищенноеСоединение: %2
|Таймаут: %3
|ИспользоватьАутентификациюОС: %4'
|;uk='%1
|
|Трасування:
|ЗащищенноеСоединение: %2
|Таймаут: %3
|ИспользоватьАутентификациюОС: %4'"),
			ТекстОшибки,
			Формат(Соединение.Защищенное, "БЛ=Нет; БИ=Да"),
			Формат(Соединение.Таймаут, "ЧГ=0"),
			Формат(Соединение.ИспользоватьАутентификациюОС, "БЛ=Нет; БИ=Да"));
		
		ДописатьЗаголовкиHTTP(ЗапросHTTP, СообщениеОбОшибке);
		ДописатьЗаголовкиHTTP(ОтветHTTP, СообщениеОбОшибке);
		
		ВидОперации = НСтр("ru='Получение файла через интернет';uk='Отримання файлу через інтернет'");
		ЭлектронноеВзаимодействие.ОбработатьОшибку(ВидОперации, СообщениеОбОшибке, , "ЭлектронноеВзаимодействие");
		
		Возврат РезультатПолученияФайла(Ложь, ТекстОшибки, ОтветHTTP);
		
	КонецПопытки;
	
	// Если сохраняем файл в соответствии с настройкой.
	Если НастройкаСохранения["МестоХранения"] = "ВременноеХранилище" Тогда
		КлючУникальности = Новый УникальныйИдентификатор;
		Адрес = ПоместитьВоВременноеХранилище (Новый ДвоичныеДанные(ПутьДляСохранения), КлючУникальности);
		Возврат РезультатПолученияФайла(Истина, Адрес, ОтветHTTP);
	ИначеЕсли НастройкаСохранения["МестоХранения"] = "Клиент"
		Или НастройкаСохранения["МестоХранения"] = "Сервер" Тогда
		Возврат РезультатПолученияФайла(Истина, ПутьДляСохранения, ОтветHTTP);
	Иначе
		ВызватьИсключение НСтр("ru='Не указано место для сохранения файла.';uk='Не вказано місце для збереження файлу.'");
	КонецЕсли;
	
КонецФункции

Процедура ДописатьТелоОтветаСервера(ПутьКФайлу, ТекстОшибки)
	
	ТелоОтветаСервера = ТекстИзHTMLИзФайла(ПутьКФайлу);
	
	Если Не ПустаяСтрока(ТелоОтветаСервера) Тогда 
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1
|
|Сообщение, полученное от сервера:
|%2'
|;uk='%1
|
|Повідомлення, отримане від сервера:
|%2'"),
			ТекстОшибки,
			ТелоОтветаСервера);
	КонецЕсли;
	
КонецПроцедуры

Функция ТекстИзHTMLИзФайла(ПутьКФайлу)
	
	ФайлОтвета = Новый ЧтениеТекста(ПутьКФайлу, КодировкаТекста.UTF8);
	ИсходныйТекст = ФайлОтвета.Прочитать(1024 * 15);
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ИзвлечьТекстИзHTML(ИсходныйТекст);
	ФайлОтвета.Закрыть();
	
	Возврат ТекстОшибки;
	
КонецФункции

// Функция, заполняющая структуру по параметрам.
//
// Параметры:
// УспехОперации - булево - успех или неуспех операции.
// СообщениеПуть - строка - 
//
// Возвращаемое значение - структура:
//          поле успех - булево
//          поле путь  - строка.
//
Функция РезультатПолученияФайла(Знач Статус, Знач СообщениеПуть, HTTPОтвет = Неопределено)
	
	Результат = Новый Структура("Статус", Статус);
	
	Если Статус Тогда
		Результат.Вставить("Путь", СообщениеПуть);
	Иначе
		Результат.Вставить("СообщениеОбОшибке", СообщениеПуть);
		Результат.Вставить("КодСостояния", 1);
	КонецЕсли;
	
	Если HTTPОтвет <> Неопределено Тогда
		ЗаголовкиОтвета = HTTPОтвет.Заголовки;
		Если ЗаголовкиОтвета <> Неопределено Тогда
			Результат.Вставить("Заголовки", ЗаголовкиОтвета);
		КонецЕсли;
		
		Результат.Вставить("КодСостояния", HTTPОтвет.КодСостояния);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ДописатьПредставлениеПеренаправлений(Перенаправления, ТекстОшибки)
	
	Если Перенаправления.Количество() > 0 Тогда 
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1
|
|Выполненные перенаправления (%2):
|%3'
|;uk='%1
|
|Виконані перенаправлення (%2):
|%3'"),
			ТекстОшибки,
			Перенаправления.Количество(),
			СтрСоединить(Перенаправления, Символы.ПС));
	КонецЕсли;
	
КонецПроцедуры

Функция ТаймаутПоРазмеруФайла(Размер)
	
	БайтВМегабайте = 1048576;
	
	Если Размер > БайтВМегабайте Тогда
		КоличествоСекунд = Окр(Размер / БайтВМегабайте * 128);
		Возврат ?(КоличествоСекунд > 43200, 43200, КоличествоСекунд);
	КонецЕсли;
	
	Возврат 128;
	
КонецФункции

// Возвращает прокси по настройкам НастройкаПроксиСервера для заданного протокола Протокол.
//
// Параметры:
//   НастройкаПроксиСервера - Соответствие:
//		ИспользоватьПрокси - использовать ли прокси-сервер.
//		НеИспользоватьПроксиДляЛокальныхАдресов - использовать ли прокси-сервер для локальных адресов.
//		ИспользоватьСистемныеНастройки - использовать ли системные настройки прокси-сервера.
//		Сервер       - адрес прокси-сервера.
//		Порт         - порт прокси-сервера.
//		Пользователь - имя пользователя для авторизации на прокси-сервере.
//		Пароль       - пароль пользователя.
//		ИспользоватьАутентификациюОС - Булево - признак использования аутентификации средствами операционной системы.
//   Протокол - строка - протокол для которого устанавливаются параметры прокси сервера, например "http", "https",
//                       "ftp".
// 
// Возвращаемое значение:
//   ИнтернетПрокси
// 
Функция НовыйИнтернетПрокси(НастройкаПроксиСервера, Протокол)
	
	Если НастройкаПроксиСервера = Неопределено Тогда
		// Системные установки прокси-сервера.
		Возврат Неопределено;
	КонецЕсли;
	
	ИспользоватьПрокси = НастройкаПроксиСервера.Получить("ИспользоватьПрокси");
	Если Не ИспользоватьПрокси Тогда
		// Не использовать прокси-сервер.
		Возврат Новый ИнтернетПрокси(Ложь);
	КонецЕсли;
	
	ИспользоватьСистемныеНастройки = НастройкаПроксиСервера.Получить("ИспользоватьСистемныеНастройки");
	Если ИспользоватьСистемныеНастройки Тогда
		// Системные настройки прокси-сервера.
		Возврат Новый ИнтернетПрокси(Истина);
	КонецЕсли;
	
	// Настройки прокси-сервера, заданные вручную.
	Прокси = Новый ИнтернетПрокси;
	
	// Определение адреса и порта прокси-сервера.
	ДополнительныеНастройки = НастройкаПроксиСервера.Получить("ДополнительныеНастройкиПрокси");
	ПроксиПоПротоколу = Неопределено;
	Если ТипЗнч(ДополнительныеНастройки) = Тип("Соответствие") Тогда
		ПроксиПоПротоколу = ДополнительныеНастройки.Получить(Протокол);
	КонецЕсли;
	
	ИспользоватьАутентификациюОС = НастройкаПроксиСервера.Получить("ИспользоватьАутентификациюОС");
	ИспользоватьАутентификациюОС = ?(ИспользоватьАутентификациюОС = Истина, Истина, Ложь);
	
	Если ТипЗнч(ПроксиПоПротоколу) = Тип("Структура") Тогда
		Прокси.Установить(Протокол, ПроксиПоПротоколу.Адрес, ПроксиПоПротоколу.Порт,
			НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"], ИспользоватьАутентификациюОС);
	Иначе
		Прокси.Установить(Протокол, НастройкаПроксиСервера["Сервер"], НастройкаПроксиСервера["Порт"], 
			НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"], ИспользоватьАутентификациюОС);
	КонецЕсли;
	
	Прокси.НеИспользоватьПроксиДляЛокальныхАдресов = НастройкаПроксиСервера["НеИспользоватьПроксиДляЛокальныхАдресов"];
	
	АдресаИсключений = НастройкаПроксиСервера.Получить("НеИспользоватьПроксиДляАдресов");
	Если ТипЗнч(АдресаИсключений) = Тип("Массив") Тогда
		Для каждого АдресИсключения Из АдресаИсключений Цикл
			Прокси.НеИспользоватьПроксиДляАдресов.Добавить(АдресИсключения);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Прокси;
	
КонецФункции

Функция АвтоматическоеОпределениеТаймаута()
	
	Возврат -1;
	
КонецФункции

Процедура ДописатьЗаголовкиHTTP(Объект, ТекстОшибки)
	
	Если ТипЗнч(Объект) = Тип("HTTPЗапрос") Тогда 
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1
|
|HTTP запрос:
|Адрес ресурса: %2
|Заголовки: %3'
|;uk='%1
|
|HTTP запит:
|Адреса ресурсу: %2
|Заголовки: %3'"),
			ТекстОшибки,
			Объект.АдресРесурса,
			ПредставлениеЗаголовковHTTP(Объект.Заголовки));
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPОтвет") Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1
|
|HTTP ответ:
|Код ответа: %2
|Заголовки: %3'
|;uk='%1
|
|HTTP відповідь:
|Код відповіді: %2
|Заголовки: %3'"),
			ТекстОшибки,
			Объект.КодСостояния,
			ПредставлениеЗаголовковHTTP(Объект.Заголовки));
	КонецЕсли;
	
КонецПроцедуры

Функция ПредставлениеЗаголовковHTTP(Заголовки)
	
	ПредставлениеЗаголовков = "";
	
	Для каждого Заголовок Из Заголовки Цикл 
		ПредставлениеЗаголовков = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='%1
|%2: %3'
|;uk='%1
|%2: %3'"), 
			ПредставлениеЗаголовков,
			Заголовок.Ключ, Заголовок.Значение);
	КонецЦикла;
		
	Возврат ПредставлениеЗаголовков;
	
КонецФункции

Функция ПараметрыПолученияФайла()
	
	ПараметрыПолучения = Новый Структура;
	ПараметрыПолучения.Вставить("ПутьДляСохранения", Неопределено);
	ПараметрыПолучения.Вставить("Пользователь", Неопределено);
	ПараметрыПолучения.Вставить("Пароль", Неопределено);
	ПараметрыПолучения.Вставить("Порт", Неопределено);
	ПараметрыПолучения.Вставить("Таймаут", АвтоматическоеОпределениеТаймаута());
	ПараметрыПолучения.Вставить("ЗащищенноеСоединение", Неопределено);
	ПараметрыПолучения.Вставить("ПассивноеСоединение", Неопределено);
	ПараметрыПолучения.Вставить("Заголовки", Новый Соответствие);
	ПараметрыПолучения.Вставить("ИспользоватьАутентификациюОС", Ложь);
	ПараметрыПолучения.Вставить("УровеньИспользованияЗащищенногоСоединения", Неопределено);
	
	Возврат ПараметрыПолучения;
	
КонецФункции

Функция РазмерФайлаHTTP(СоединениеHTTP, Знач ПутьНаСервере, Знач Заголовки = Неопределено)
	
	ЗапросHTTP = Новый HTTPЗапрос(ПутьНаСервере, Заголовки);
	Попытка
		ПолученныеЗаголовки = СоединениеHTTP.ПолучитьЗаголовки(ЗапросHTTP);// HEAD
	Исключение
		Возврат 0;
	КонецПопытки;
	РазмерСтрокой = ПолученныеЗаголовки.Заголовки["Content-Length"];
	
	ТипЧисло = Новый ОписаниеТипов("Число");
	РазмерФайла = ТипЧисло.ПривестиЗначение(РазмерСтрокой);
	
	Возврат РазмерФайла;
	
КонецФункции

Процедура ИнициализацияСообщенийОшибок(СообщенияОшибок)
	
	// Общие коды ошибок
	СообщенияОшибок.Вставить("001", );
	СообщенияОшибок.Вставить("002", );
	СообщенияОшибок.Вставить("003", );
	СообщенияОшибок.Вставить("004", );
	СообщенияОшибок.Вставить("005", );
	СообщенияОшибок.Вставить("006", , );
	СообщенияОшибок.Вставить("007", , );
	// Коды ошибок 1С
	СообщенияОшибок.Вставить("0", );
	СообщенияОшибок.Вставить("2", );
	СообщенияОшибок.Вставить("3", );
	СообщенияОшибок.Вставить("4", );
	СообщенияОшибок.Вставить("5", );
	СообщенияОшибок.Вставить("6", );
	СообщенияОшибок.Вставить("7", );
	СообщенияОшибок.Вставить("8", );
	СообщенияОшибок.Вставить("9", );
	СообщенияОшибок.Вставить("10", );
	СообщенияОшибок.Вставить("11", );
	СообщенияОшибок.Вставить("12", );
	СообщенияОшибок.Вставить("13", );
	СообщенияОшибок.Вставить("14", );
	СообщенияОшибок.Вставить("15", );
	СообщенияОшибок.Вставить("16", );
	СообщенияОшибок.Вставить("17", );
	СообщенияОшибок.Вставить("18", );
	СообщенияОшибок.Вставить("19", );
	СообщенияОшибок.Вставить("21", );
	
	СообщенияОшибок.Вставить("100", );
	СообщенияОшибок.Вставить("101", );
	СообщенияОшибок.Вставить("102", );
	СообщенияОшибок.Вставить("103", );
	СообщенияОшибок.Вставить("104", );
	СообщенияОшибок.Вставить("105", );
	
	СообщенияОшибок.Вставить("110", );
	СообщенияОшибок.Вставить("111", );
	СообщенияОшибок.Вставить("112", );
	СообщенияОшибок.Вставить("113", );
	СообщенияОшибок.Вставить("114", );
	СообщенияОшибок.Вставить("115", );
	
	СообщенияОшибок.Вставить("106", );
	СообщенияОшибок.Вставить("107", );
	
	СообщенияОшибок.Вставить("121", );
	СообщенияОшибок.Вставить("122", );
	СообщенияОшибок.Вставить("123", );
	СообщенияОшибок.Вставить("124", );
	СообщенияОшибок.Вставить("125", );
	СообщенияОшибок.Вставить("126", );
	СообщенияОшибок.Вставить("127", );
	СообщенияОшибок.Вставить("128", );
	СообщенияОшибок.Вставить("129", );
	
	// Коды ошибок оператора Такском.
	// Метод CertificateLogin: идентификация и авторизация.
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("2501", ); // Не указан идентификатор вендора (название параметра?) 400 0501.
	СообщенияОшибок.Вставить("3109", ); // Не указан сертификат 403 3100.
	СообщенияОшибок.Вставить("3107", ); // Некорректное тело сертификата 403 3107.
	СообщенияОшибок.Вставить("3101", ); // Сертификат просрочен 403 3101.
	СообщенияОшибок.Вставить("3102", ); // Для указанного сертификата не удалось построить цепочку доверия 403 3102.
	
	// Синхронный режим с обращением в БД.
	СообщенияОшибок.Вставить("1301", ); // Вендор с указанным идентификатором не прошел авторизацию 401 1300.
	СообщенияОшибок.Вставить("3103", );
	СообщенияОшибок.Вставить("3104", );
	СообщенияОшибок.Вставить("3105", );
	СообщенияОшибок.Вставить("3106", );
	СообщенияОшибок.Вставить("1102", );
	СообщенияОшибок.Вставить("1101", );
	СообщенияОшибок.Вставить("3108", );
	
	// Метод SendMessage: загрузка транспортных контейнеров
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("1201", ); // Истек 5-ти минутный срок действия токена (требуется повторная авторизация) 401 1200
	СообщенияОшибок.Вставить("2118", ); // Размер отправляемого контейнера не соответствует допустимому диапазону от 0 до (цифра!) 400 0100
	СообщенияОшибок.Вставить("2107", ); // Отправляемый контейнер не является ZIP-архивом 400 0107
	СообщенияОшибок.Вставить("2108", ); // В контейнере отсутствует необходимый файл meta.xml 400 0108
	СообщенияОшибок.Вставить("2109", ); // Файл meta.xml не является XML-файлом (стандарты?) 400 0109
	СообщенияОшибок.Вставить("2111", ); // Структура файла meta.xml не соответствует принятой схеме 400 0111
	СообщенияОшибок.Вставить("2101", ); // В файле meta.xml не указан корректный идентификатор документооборота (DocFlowID) 400 0101
	СообщенияОшибок.Вставить("2102", ); // В отправляемом контейнере обнаружены файлы, связанные более чем с одним документооборотом 400 0102
	СообщенияОшибок.Вставить("2113", ); // В данном документообороте возможна отправка только одного файла 400 0113
	СообщенияОшибок.Вставить("2103", ); // В файле meta.xml отсутствует код регламента (ReglamentCode) 400 0103
	СообщенияОшибок.Вставить("2114", ); // В файле meta.xml указан некорректный код регламента (ReglamentCode) 400 0114
	СообщенияОшибок.Вставить("2104", ); // В файле meta.xml отсутствует код транзакции (TransactionCode) 400 0104
	СообщенияОшибок.Вставить("2303", ); // Транзакция с кодом <TransactionCode> недопустима в документообороте < ReglamentCode > 400 0300
	СообщенияОшибок.Вставить("3108", ); // Файл <имя файла>, указанный в meta.xml, не найден в отправляемом контейнере 400 0105
	СообщенияОшибок.Вставить("0110", ); // Файл card.xml не является XML-файлом 400 0110
	СообщенияОшибок.Вставить("0112", ); // Структура файла card.xml не соответствует принятой схеме 400 0112
	СообщенияОшибок.Вставить("0106", ); // Неверный формат идентификатора отправителя (название параметра?) в файле card.xml 400 0106
	СообщенияОшибок.Вставить("0115", ); // Неверный формат идентификатора получателя (название параметра?) в файле card.xml 400 0115
	
	// Синхронный режим с обращением к БД
	СообщенияОшибок.Вставить("0201", ); // Идентификатор отправителя (название параметра?) соответствует учетной записи 400 0201
	СообщенияОшибок.Вставить("0401", ); // Документооборот с указанным идентификатором уже зарегистрирован (DocFlowID) 400 0401
	СообщенияОшибок.Вставить("0402", ); // Документооборот с указанным идентификатором не зарегистрирован (DocFlowID) 400 0402
	СообщенияОшибок.Вставить("0301", ); // Данная транзакция <код транзакции> уже была осуществлена для данного документооборота < DocFlowID > 400 0301
	
	// Асинхронный режим
	СообщенияОшибок.Вставить("0202", ); // Получатель с указанным идентификатором не зарегистрирован 0202
	СообщенияОшибок.Вставить("0203", ); // Получатель с указанным идентификатором не является контрагентом отправителя 0203
	СообщенияОшибок.Вставить("3200", ); // Документ не может быть отправлен в связи с ограничениями тарификации 3200
	
	// Метод GetMessageList: получение входящих транспортных контейнеров
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("0503", ); // Отсутствует обязательный параметр «метка времени (название параметра)» 400 0503
	СообщенияОшибок.Вставить("0504", ); // Некорректный формат метки времени 400 0504
	
	// Метод GetMessage: выгрузка входящих транспортных контейнеров
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("0505", ); // Отсутствует обязательный параметр идентификатор контейнера (документооборота) 400 0505
	СообщенияОшибок.Вставить("0502", ); // Неправильный формат идентификатора документооборота 400 0502
	
	// Синхронный режим с обращением к БД
	СообщенияОшибок.Вставить("4100", ); // Сообщение с данным <DocFlowID> идентификатором документооборота не найдено 404 4100
	
	// Общие ошибки сервера Такском
	СообщенияОшибок.Вставить("5101", ); // Внутренняя ошибка сервера 500 0000
	
КонецПроцедуры

#Область ОбработкаСхемыЗапросов

// Объединить пакет запросов.
//
// Параметры:
//  Запрос1 - ПакетЗапросовСхемыЗапроса - пакет запроса являющимся приемником.
//  Запрос2 - ПакетЗапросовСхемыЗапроса - пакет запроса являющимся источником.
//
Процедура ОбъединитьПакетЗапросов(Запрос1, Запрос2)
	
	Если Запрос2.Операторы.Количество() > 1 Тогда
		ВызватьИсключение НСтр("ru='Объединение запросов производится только для одного оператора';uk='Об''єднання запитів проводиться тільки для одного оператора'");
	КонецЕсли;
	
	// Обработка операторов.
	Для каждого Источники2 Из Запрос2.Операторы[0].Источники Цикл
		
		Если Запрос1.Операторы[0].Источники.НайтиПоПсевдониму(Источники2.Источник.Псевдоним) = Неопределено Тогда
			Запрос1.Операторы[0].Источники.Добавить(Источники2.Источник.ИмяТаблицы, Источники2.Источник.Псевдоним);
		КонецЕсли;
		
	КонецЦикла;
	
	// Добавление выбираемых полей.
	Для каждого ВыбираемоеПоле2 Из Запрос2.Операторы[0].ВыбираемыеПоля Цикл
		ИндексКолонки2 = Запрос2.Операторы[0].ВыбираемыеПоля.Индекс(ВыбираемоеПоле2);
		Колонка2 = Запрос2.Колонки.Получить(ИндексКолонки2);
		Колонка1 = Запрос1.Колонки.Найти(Колонка2.Псевдоним);
		Если Колонка1 = Неопределено Тогда
			Запрос1.Операторы[0].ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2));
			// Установка имени колонки.
			Колонка1 = Запрос1.Колонки.Получить(Запрос1.Колонки.Количество()-1);
			Колонка1.Псевдоним = Колонка2.Псевдоним;
		Иначе
			Запрос1.Операторы[0].ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2),
				Запрос1.Колонки.Индекс(Колонка1));
		КонецЕсли;
	КонецЦикла;
	
	Для каждого Источники2 Из Запрос2.Операторы[0].Источники Цикл
		
		Если Источники2.Соединения.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Источник1 = Запрос1.Операторы[0].Источники.НайтиПоПсевдониму(Источники2.Источник.Псевдоним);
		ПсевдонимыИсточника1 = Новый Массив;
		Для каждого Соединение1 Из Источник1.Соединения Цикл
			ПсевдонимыИсточника1.Добавить(Соединение1.Источник.Источник.Псевдоним);
		КонецЦикла;
		
		СписокКорректировкиСоединений = Новый Соответствие;
		Для каждого Соединение2 Из Источники2.Соединения Цикл
			
			Псевдоним2 = Соединение2.Источник.Источник.Псевдоним;
			Если ПсевдонимыИсточника1.Найти(Псевдоним2) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ИсточникСхемы = Запрос1.Операторы[0].Источники.НайтиПоПсевдониму(Псевдоним2);
			Если ИсточникСхемы = Неопределено Тогда
				Источник1.Соединения.Добавить(Соединение2.Источник, Строка(Соединение2.Условие));
			Иначе
				Источник1.Соединения.Добавить(ИсточникСхемы, Строка(Соединение2.Условие));
				ПоследнееСоединение = Источник1.Соединения.Получить(Источник1.Соединения.Количество()-1);
				Если ПоследнееСоединение.ТипСоединения <> Соединение2.ТипСоединения Тогда
					СписокКорректировкиСоединений.Вставить(ПоследнееСоединение, Соединение2.ТипСоединения);
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
		Если СписокКорректировкиСоединений.Количество() Тогда
			Для каждого Соединение1 Из СписокКорректировкиСоединений Цикл
				Соединение1.Ключ.ТипСоединения = Соединение1.Значение;
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	// Перебор и подстановка полей запроса.
	Для каждого Колонка2 Из Запрос2.Колонки Цикл
		Колонка1 = Запрос1.Колонки.Найти(Колонка2.Псевдоним);
		Если Колонка1 <> Неопределено Тогда
			Если ПоляСхемыЗапросовИдентичны(Колонка1.Поля, Колонка2.Поля) Тогда
				Продолжить;
			КонецЕсли;
			ИндексКолонки1 = Запрос1.Колонки.Индекс(Колонка1);
			ИндексКолонки2 = Запрос2.Колонки.Индекс(Колонка2);
			Запрос1.Операторы[0].ВыбираемыеПоля.Установить(ИндексКолонки1, Запрос2.Операторы[0].ВыбираемыеПоля.Получить(ИндексКолонки2));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавить запрос в пакет запросов.
//
// Параметры:
//  Схема1 - СхемаЗапроса - пакет запроса являющимся приемником.
//  Запрос2 - ПакетЗапросовСхемыЗапроса - пакет запроса являющимся источником.
//
Процедура ДобавитьЗапросВПакет(Схема1, ЗапросСхемы2)
	
	ЗапросСхемы1 = Схема1.ПакетЗапросов.Добавить(ТипЗнч(ЗапросСхемы2));
	ЗаполнитьЗначенияСвойств(ЗапросСхемы1, ЗапросСхемы2);
	
	Если ТипЗнч(ЗапросСхемы2) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
		// Для уничтожения таблицы ничего не заполняется.
		Возврат;
	КонецЕсли;
	
	// Кэширование полей в колонках источника.
	ПоляПоКолонкам2 = Новый Соответствие;
	Для каждого ЭлементКоллекцииКолонки2 Из ЗапросСхемы2.Колонки Цикл
		Для каждого ЭлементКоллекцииПоляКолонок2 Из ЭлементКоллекцииКолонки2.Поля Цикл
			ПоляПоКолонкам2.Вставить(ЭлементКоллекцииПоляКолонок2, ЗапросСхемы2.Колонки.Индекс(ЭлементКоллекцииКолонки2));
		КонецЦикла;
	КонецЦикла;
	
	// Добавление операторов запроса.
	Для каждого ОператорЗапросаСхемы2 Из ЗапросСхемы2.Операторы Цикл
		
		// Обход автоматического создания первого оператора запроса.
		Если ЗапросСхемы2.Операторы.Индекс(ОператорЗапросаСхемы2) = 0 Тогда
			ОператорЗапросаСхемы1 = ЗапросСхемы1.Операторы.Получить(0);
		Иначе
			ОператорЗапросаСхемы1 = ЗапросСхемы1.Операторы.Добавить();
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ОператорЗапросаСхемы1, ОператорЗапросаСхемы2);
		
		// Добавление источников запроса.
		Для каждого Источники2 Из ОператорЗапросаСхемы2.Источники Цикл
			Источник1 = ОператорЗапросаСхемы1.Источники.Добавить(Источники2.Источник.ИмяТаблицы, Источники2.Источник.Псевдоним);
		КонецЦикла;
		
		// Добавление выбираемых полей.
		Для каждого ВыбираемоеПоле2 Из ОператорЗапросаСхемы2.ВыбираемыеПоля Цикл
			
			ИндексКолонки2 = ОператорЗапросаСхемы2.ВыбираемыеПоля.Индекс(ВыбираемоеПоле2);
			Колонка2 = ЗапросСхемы2.Колонки.Получить(ИндексКолонки2);
			Колонка1 = ЗапросСхемы1.Колонки.Найти(Колонка2.Псевдоним);
			
			ИндексКолонки = ПоляПоКолонкам2.Получить(ВыбираемоеПоле2);
			Если Колонка1 = Неопределено Тогда
				ОператорЗапросаСхемы1.ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2));
				// Установка имени колонки.
				Колонка1 = ЗапросСхемы1.Колонки.Получить(ЗапросСхемы1.Колонки.Количество()-1);
				Колонка1.Псевдоним = Колонка2.Псевдоним;
			Иначе
				ОператорЗапросаСхемы1.ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2), ИндексКолонки);
			КонецЕсли;
		КонецЦикла;
		
		// Добавление соединений.
		СписокКорректировкиСоединений = Новый Соответствие;
		Для каждого Источники2 Из ОператорЗапросаСхемы2.Источники Цикл
			Источник1 = ОператорЗапросаСхемы1.Источники.Получить(ОператорЗапросаСхемы2.Источники.Индекс(Источники2));
			Для каждого Соединение2 Из Источники2.Соединения Цикл
				Источник1.Соединения.Добавить(Соединение2.Источник.Источник.Псевдоним, Строка(Соединение2.Условие));
				ПоследнееСоединение = Источник1.Соединения.Получить(Источник1.Соединения.Количество()-1);
				Если ПоследнееСоединение.ТипСоединения <> Соединение2.ТипСоединения Тогда
					СписокКорректировкиСоединений.Вставить(ПоследнееСоединение, Соединение2.ТипСоединения);
				КонецЕсли;
			КонецЦикла;
			Если СписокКорректировкиСоединений.Количество() Тогда
				Для каждого Соединение1 Из СписокКорректировкиСоединений Цикл
					Соединение1.Ключ.ТипСоединения = Соединение1.Значение;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		// Добавление отборов.
		Для каждого ОтборыЗапроса2 Из ОператорЗапросаСхемы2.Отбор Цикл
			ОператорЗапросаСхемы1.Отбор.Добавить(Строка(ОтборыЗапроса2));
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Служебная функция - определение идентичности полей схемы запросов.
//
// Параметры:
//  Коллекция1	 - ПоляСхемыЗапроса - поля схемы приемника.
//  Коллекция2	 - ПоляСхемыЗапроса - поля схемы источника.
// 
// Возвращаемое значение:
//  Булево - результат сравнения.
//
Функция ПоляСхемыЗапросовИдентичны(Коллекция1, Коллекция2)
	
	Если Коллекция1.Количество() <> Коллекция2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для НомерИндекса = 0 По Коллекция1.Количество() - 1 Цикл
		Если Коллекция1[НомерИндекса] <> Коллекция2[НомерИндекса] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#КонецОбласти



